
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Life Matrix</title>
  <meta name="author" content="Steven Liu <stevenliucx@gmail.com>&#8221;>

  
  <meta name="description" content="A Conversation with Alan Kay Big talk with the creator of Smalltalk—and much more. 原文：http://queue.acm.org/detail.cfm?id=1039523, PDF版 ACM相关链接：访谈, &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hack.the-lifematrix.net">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Life Matrix" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       jax: ["input/TeX", "output/HTML-CSS"],
       tex2jax: {
          inlineMath: [ ['$', '$'] ],
          displayMath: [ ['$$', '$$']],
          procehssEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       },
       messageStyle: "none",
       "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
     });
   </script>
   <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Life Matrix</a></h1>
  
    <h2>Machine learning, Hacking, Web app</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hack.the-lifematrix.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/resources">Resources</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/a-conversation-with-alan-kay/">A Conversation With Alan Kay</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-30T12:14:50+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="a-conversation-with-alan-kay">A Conversation with Alan Kay</h2>

<h3 id="big-talk-with-the-creator-of-smalltalkand-much-more">Big talk with the creator of Smalltalk—and much more.</h3>

<p>原文：<a href="http://queue.acm.org/detail.cfm?id=1039523">http://queue.acm.org/detail.cfm?id=1039523</a>, <a href="http://delivery.acm.org/10.1145/1040000/1039523/p20-feldman.pdf?ip=52.74.127.172&amp;id=1039523&amp;acc=OPEN&amp;key=4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E6D218144511F3437&amp;CFID=689541297&amp;CFTOKEN=83565474&amp;__acm__=1435818417_611f83d394c1ac8eb74a175e9c45c2d3">PDF版</a></p>

<p>ACM相关链接：<a href="http://queue.acm.org/listing.cfm? qc_type=interviews&amp;page_title=Interviews">访谈</a>,  <a href="http://queue.acm.org/listing.cfm?item_topic=Programming%20Languages&amp;qc_type=theme_list&amp;filter=Programming%20Languages&amp;page_title=Programming%20Languages&amp;order=desc">编程语言</a></p>

<p>When you want to gain a historical perspective on personal computing and programming languages, why not turn to one of the industry’s preeminent pioneers? That would be Alan Kay, winner of last year’s Turing Award for leading the team that invented Smalltalk, as well as for his fundamental contributions to personal computing.</p>

<p>如你想获得有关个人计算和编程语言的历史性观点，为什么不问问业界的某个先驱呢？这可能就是Alan Kay, 他因为领导团队发明Smalltalk, 以及他对个人计算的根本性贡献，荣获去年的图灵奖。
<br /></p>

<p>Kay was one of the founders of the Xerox Palo Alto Research Center (PARC), where he led one of several groups that together developed modern workstations (and the forerunners of the Macintosh), Smalltalk, the overlapping window interface, desktop publishing, the Ethernet, laser printing, and network client-servers.</p>

<p>Kay是施乐帕洛阿尔托研究中心(Xerox Palo Alto Research Center, PARC)的创始人之一，他在那里领导了几个小组中的一个，这些组共同开发了现代工作站(Machintosh的前身)，Smalltalk，重叠式的窗口界面，桌面出版，以太网，激光打印，以及网络的客户-服务器。</p>

<p>Prior to his work at PARC, Kay earned a Ph.D. in 1969 from the University of Utah, where he designed a graphical object-oriented personal computer and was a member of the research team that developed pioneering 3-D graphics work for the Advanced Research Projects Agency (ARPA). Kay was also a “slight participant” in the original design of the ARPANet, which later became the Internet. He holds undergraduate degrees in mathematics and molecular biology from the University of Colorado. After leaving Xerox PARC, Kay went on to become chief scientist of Atari, a Fellow of Apple Computer, and vice president of research and development at The Walt Disney Company.</p>

<p>在他工作于PARC之前，Kay于1969年从犹他州立大学获得博士学位。在那里，他设计了一个图形化的面向对象的个人电脑，同时他是为研究小组的成员，这个组为高级研究项目管理局(ARPA)开发开创性的3-D图形工作。Kay也是一个ARPANet原始设计的少量参与者，其后来变成了互联网。他在科罗拉多州立大学获得数学和分子生物学的研究生学位。离开施乐PARC之后，Kay继续成为Atari的首席科学家，这是苹果电脑的同类，以及沃特迪斯尼公司的研发副总裁。</p>

<p>Today he is Senior Fellow at Hewlett-Packard Labs and president of Viewpoints Research Institute, a nonprofit organization whose goal is to change how children are educated by creating a sample curriculum with supporting media for teaching math and science. This curriculum will use Squeak as its media, and will be highly interactive and constructive. Kay’s deep interests in children and education have been the catalysts for many of his ideas over the years.</p>

<p>今天，他是惠普公司的高级研究员以及Viewpoint研究所的总裁，这是一个非盈利组织，其目标是通过创造带有支持媒体的样本课程来教授数学和科学，从而改变儿童受教育的方式。这个课程将使用Squeak语言作为媒介，将具有高度交互性和建设性。Kay对儿童和教育的深度兴趣，是他多年来很多创意的催化剂。</p>

<p>In addition to winning the Turing Award, Kay recently received the Draper Prize from the National Academy of Engineering and the Kyoto Prize in Advanced Technology, awarded every four years by the Inamori Foundation.</p>

<p>除了图灵奖，Kay最近从美国国家工程院获得了Draper奖，以及高等技术的Kyoto奖(京都赏)，此奖由Inamori基金会每4年颁发一次。</p>

<p>Guiding our tour through personal computing history with Kay is Stuart Feldman of IBM Research, where he is vice president and on-demand business transformation area strategist. Since joining IBM in 1995, Feldman has also served as vice president for Internet technology and was head of computer science in the research division.</p>

<p>带领我们和Kay一起游览个人计算历史的是IBM研究院的Stuart Feldman，他是研究院的副总裁以及on-demand业务转化领域的战略家。Feldman也曾经作为Internet技术的副总裁，是研究事业部中计算机科学的领导人。</p>

<p>Feldman also spent 11 years at Bellcore, where he held several research management positions in software engineering and computing systems, and 10 years at Bell Labs, where he was a computer science researcher. Feldman was a member of the original Unix team and is best known as the creator of the Make configuration management system and as the author of the first Fortran-77 compiler. He has a Ph.D. in applied mathematics from the Massachusetts Institute of Technology. He is a member of the Queue Advisory Board.</p>

<p>Feldman也在Bellcore(Bell Communications Research)待了11年，在那里他做过多个软件工程和计算系统的研究管理职位，并在Bell实验室待了10年，那里他作为计算机科学研究员。Feldman是原始Unix团队的成员，以Make配置管理系统的创建者和第一个Fortran-77编译器的作者而著称。他从麻省理工学院取得应用数学的博士学位。他是Queue顾问委员会的成员。</p>

<p>STUART FELDMAN One of the topics that some of the younger people on our Queue editorial board keep asking about is the history of programming languages. The Queue board has a bimodal generation distribution, and those members who are in their 20s or 30s seem genuinely confused about where programming languages might actually come from. It’s my observation that we have one big language and one smaller language every decade—that appears to be all the field can afford. Smalltalk is one of those five- or 10-year events.</p>

<p><strong>STUART FELDMAN</strong> 一些更年轻的人在我们Queue编委会上持续问到的一个主题是编程语言的历史。Queue委员会年龄分布是双峰模式，那些20或30岁的成员普遍对编程语言到底从何而来感到困惑。我的观察是，每十年有一个主流语言(one big language)和一个较小众的语言，这看起来所有的领域（对编程语言的需要）都能对付。Smalltalk是那些5年或10年的现象。</p>

<p><strong>ALAN KAY</strong> In the late 1960s, Jean Sammet was able to track down and chronicle about 3,000 programming languages that were extant then. When things were simpler in a sense—but theoretically harder because the machines were slower, smaller, didn’t have hard drives most of the time, and had bad tools—people nonetheless rolled their own operating systems and programming languages whenever they felt like it. So there are zillions of them around.</p>

<p><strong>ALAN kay</strong> 在1960年代晚期，Jean Sammet能追溯和记录当时存在大约3000种编程语言。在某种意义上，事情更简单了，但是理论上却更困难了。因为机器更慢、更小，大多数时候没有硬盘，工具很糟糕 - 尽管如此，人们运行着他们自己的操作系统和编程语言，只要他们喜欢。因此，到处都是繁多的编程语言和操作系统。</p>

<p>For a Scientific American article 20 years ago, I came up with a facetious sunspot theory, just noting that there’s a major language or two every 101⁄2 years, and in between those periods are what you might call hybrid languages. These could be looked at as either an improvement on the old thing or almost a new thing. I chronicled Fortran as an improvement on an old thing or almost a new thing, and Algol and Lisp were the new thing.</p>

<p>对《科学美国人》20年前的一篇文章，我想出一个俏皮的支持理论，每10.5年，将有一到两个主要的语言，在这个期间的语言，你可称为混合语言。这些可看做对旧事物的改进，或者几乎是全新的事物。我将Fortran编目为旧事物的改进或者几乎一个新事物，而Algol和Lisp是新事物。</p>

<p>Then there was Simula, which the designers thought of as an extension of Algol. It was basically a preprocessor to Algol the way C++ was a preprocessor for C. It was a great concept and I was lucky enough to see it as almost a new thing. Smalltalk and Prolog happened in the early 1970s. The predecessor of Prolog was a wonderful thing that Carl Hewitt did in the late 1960s called Planner.</p>

<p>然后是Simula, 设计者们把它看做Algol的扩展。它根本上是Algol的一个预处理器，如同C++是C预处理的方式。这是个伟大的概念，我足够幸运将它看做几乎全新的事物。Smalltalk和Prolog出现在1970年代早期。Prolog的预处理器是非常棒，由Carl Hewitt在1960年代晚期做出来，叫做Planner。</p>

<p>Perhaps it was commercialization in the 1980s that killed off the next expected new thing. Our plan and our hope was that the next generation of kids would come along and do something better than Smalltalk around 1984 or so. We all thought that the next level of programming language would be much more strategic and even policy-oriented and would have much more knowledge about what it was trying to do. But a variety of different things conspired together, and that next generation actually didn’t show up. One could actually argue—as I sometimes do—that the success of commercial personal computing and operating systems has actually led to a considerable retrogression in many, many respects.</p>

<p>大概是1980年代的商业化扼杀了期待的下一个新事物。我们的计划和希望是下一代的年轻人一起来干，做一些比1984年前后Smalltalk更好的东西，等等。我们都认为，编程语言的下一层次本应更战略性，甚至是面向策略，本应包含更多所尝试去做之事的知识。但是，很多不同的事情凑在一起，让下一代事实上没有显现出来。有人可能会争辩 - 如我偶尔做的 - 商业化个人计算和操作系统的成功事实上导致了在很多很多方面的显著退步。</p>

<p>You could think of it as putting a low-pass filter on some of the good ideas from the ’60s and ’70s, as computing spread out much, much faster than educating unsophisticated people can happen. In the last 25 years or so, we actually got something like a pop culture, similar to what happened when television came on the scene and some of its inventors thought it would be a way of getting Shakespeare to the masses. But they forgot that you have to be more sophisticated and have more perspective to understand Shakespeare. What television was able to do was to capture people as they were.</p>

<p>你可以把它想成，随着计算向外传播远快于教育未开化之人的速度，而对一些来自60或70年代的良好想法放置了低通滤镜。在过去大约25年，我们事实上得到一些类似流行文化的东西，类似于当电视机出现时所发生的。一些发明者想这是让莎士比亚戏剧走向大众的一个途径，但是他们忘记了为了理解莎士比亚，你必须更加精于世事并有多个视角。电视能够做的是捕捉人们本来的样子。</p>

<p>So I think the lack of a real computer science today, and the lack of real software engineering today, is partly due to this pop culture.</p>

<p>因此我想今天缺少真正的计算机科学，缺少真正的软件工程，部分归因于这一流行文化。</p>

<p><strong>SF</strong> So Smalltalk is to Shakespeare as Excel is to car crashes in the TV culture?</p>

<p><strong>SF</strong> 因此Smalltalk对于莎士比亚，就如Excel对于电视文化中的车祸？</p>

<p><strong>AK</strong> No, if you look at it really historically, Smalltalk counts as a minor Greek play that was miles ahead of what most other cultures were doing, but nowhere near what Shakespeare was able to do.</p>

<p><strong>AK</strong> 不，如果你真从历史角度去看它，Smalltalk可当做小型的希腊戏剧，比大部分其它文明要领先几英里，但还没有接近莎士比亚所能做的。</p>

<p>If you look at software today, through the lens of the history of engineering, it’s certainly engineering of a sort—but it’s the kind of engineering that people without the concept of the arch did. Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.</p>

<p>如果你从工程的历史透镜去看今天的软件，它的确是某类工程 - 但它是那些对拱形结构都没有概念的人所做的工程。绝大多数今天的软件，非常象用数百万砖块堆积的埃及金字塔，没有结构的一致性，但仅靠蛮力和成千上万的奴隶。</p>

<p><strong>SF</strong> The analogy is even better because there are the hidden chambers that nobody can understand.</p>

<p><strong>SF</strong> 这个类比甚至更绝妙，因为这样里面，有无人能理解的暗室。</p>

<p><strong>AK</strong> I would compare the Smalltalk stuff that we did in the ’70s with something like a Gothic cathedral. We had two ideas, really. One of them we got from Lisp: late binding. The other one was the idea of objects. Those gave us something a little bit like the arch, so we were able to make complex, seemingly large structures out of very little material, but I wouldn’t put us much past the engineering of 1,000 years ago.</p>

<p><strong>AK</strong> 我将我们在70年代做的Smalltalk标本，比作哥德式教堂。事实上，我们有两个想法。其一来自Lisp: 延迟绑定。另一个是对象的想法。这些给了我们一些有点象拱形结构的东西，因此我们能够做从小的材料中，做出复杂的、看起来大型的结构，但是我不会将我们放到10000年前的工程。</p>

<p>If you look at [Doug] Engelbart’s demo [a live online hypermedia demonstration of the pioneering work that Engelbart’s group had been doing at Stanford Research Institute, presented at the 1968 Fall Joint Computer Conference], then you see many more ideas about how to boost the collective IQ of groups and help them to work together than you see in the commercial systems today. I think there’s this very long lag between what you might call the best practice in computing research over the years and what is able to leak out and be adapted in the much more expedient and deadline-conscious outside world.</p>

<p>如果你看看Englebart的演示，那么你会看见比今天商业系统中更多的创意，关于如何提升团体的共同智商并帮助他们一起工作。我想，在计算研究过去数年中你可能称为的最佳实践，与什么可能渗入并被更为应急和注重最终期限的外部世界所采纳的之间，有相当大的延滞。</p>

<p>It’s not that people are completely stupid, but if there’s a big idea and you have deadlines and you have expedience and you have competitors, very likely what you’ll do is take a low-pass filter on that idea and implement one part of it and miss what has to be done next. This happens over and over again. If you’re using early-binding languages as most people do, rather than late-binding languages, then you really start getting locked in to stuff that you’ve already done. You can’t reformulate things that easily.</p>

<p>这并不是说人们都彻头彻尾愚蠢，但是如果有个大点子而你有最终能够，你有应急手段，还有竞争者，那么非常可能你将做的，就是对那个点子放置低通滤镜，然后实施其中一部分，并想着下次必须做的。这一而再地发生。如果你使用绝大多数人使用的早期绑定语言(early-binding languages)，而非滞后绑定语言，那么你事实上开始被你已经做的锁定住了。你难以重新规划它。</p>

<p>Let’s say the adoption of programming languages has very often been somewhat accidental, and the emphasis has very often been on how easy it is to implement the programming language rather than on its actual merits and features. For instance, Basic would never have surfaced because there was always a language better than Basic for that purpose. That language was Joss, which predated Basic and was beautiful. But Basic happened to be on a GE timesharing system that was done by Dartmouth, and when GE decided to franchise that, it started spreading Basic around just because it was there, not because it had any intrinsic merits whatsoever.</p>

<p>让我们来说手，编程语言的采纳经常有些偶然性，过去经常是强调实施一个编程语言多么容易，而非它实际的优点和特性。例如，Basic本不该浮出水面，因为对于那个目的已经有一个语言优于Basic。这个语言是Joss，早于Basic，非常漂亮。但是Basic碰巧在由Dartmouth完成的GE分时系统上，当GE决定经销它时，它开始四处传播它，仅仅因为它就在那里，而非它有任何丝毫的内在优点。</p>

<p>This happens over and over again. The languages of Niklaus Wirth have spread wildly and widely because he has been one of the most conscientious documenters of languages and one of the earlier ones to do algorithmic languages using p-codes (pseudocodes)—the same kinds of things that we use. The idea of using those things has a common origin in the hardware of a machine called the Burroughs B5000 from the early 1960s, which the establishment hated.</p>

<p>这又一而再地发生。Niklaus Wirth的语言野蛮而广泛地传播，是因为他是语言的最勤勤恳恳的文档撰写者之一，最早使用p代码–和我们使用的是同一类，作为算法语言的人之一。使用那些东西的想法有个共同的出处，是在来自1960年代早期称为Burroughs B5000的硬件机器。</p>

<p><strong>SF</strong> Partly because there wasn’t any public information on most of it.</p>

<p>部分原因是对绝大多数这样的事情，没有任何公开的信息。</p>

<p><strong>AK</strong> Let me beg to differ. I was there, and Burroughs actually hired college graduates to explain that machine to data-processing managers. There was an immense amount of information available. The problem was that the DP managers didn’t want to learn new ways of computing, or even how to compute. IBM realized that and Burroughs didn’t.</p>

<p><strong>AK</strong> 让我说点不同的。我在那里，Burroughs的确雇佣了大学研究生去向数据处理经理解释那个机器。有巨大数量的信息。问题是那个经理不想学习计算的新方式，或甚至如何计算。IBM认识到那点了，但Burroughs没有。</p>

<p><strong>SF</strong> If memory serves, I was fascinated by that machine at the time, but I was unable to get the detail that made me understand it.
如果资金许可，那时我会被这机器迷住的，但是我无法获得让我理解它的细节。</p>

<p><strong>AK</strong> In fact, the original machine had two CPUs, and it was described quite adequately in a 1961 paper by Bob Barton, who was the main designer. One of the great documents was called “The Descriptor” and laid it out in detail. The problem was that almost everything in this machine was quite different and what it was trying to achieve was quite different.</p>

<p><strong>AK</strong> 事实上，原始的机器有两个CPU，这已经在主要设计者Bob Barton于1961年写的一篇文章中非常充分地讨论了。其中一篇伟大的文献称为“描述子”(Descriptor)，并详细设计了它。问题是这个机器几乎所有的东西都是不同的，而且它试图达到的目标也完全不同。</p>

<p>The reason that line lived on—even though the establishment didn’t like it—was precisely because it was almost impossible to crash it, and so the banking industry kept on buying this line of machines, starting with the B5000. Barton was one of my professors in college, and I had adapted some of the ideas on the first desktop machine that I did. Then we did a much better job of adapting the ideas at Xerox PARC (Palo Alto Research Center).</p>

<p>那条线存活的原因，即使当权派不喜欢它，恰恰是它几乎不可能崩溃，所以从B5000开始，银行业不断地购买这条线的机器。Barton是我大学时的教授之一，我在做第一个桌面机器时采用其中一些想法。然后我们在施乐PARC采纳这些想法做出了更加出色的工作。</p>

<p>Neither Intel nor Motorola nor any other chip company understands the first thing about why that architecture was a good idea.</p>

<p>无论是英特尔还是摩托罗那，或其它任何芯片公司，都不理解第一要务，为什么那个架构是个好点子。</p>

<p>Just as an aside, to give you an interesting benchmark—on roughly the same system, roughly optimized the same way, a benchmark from 1979 at Xerox PARC runs only 50 times faster today. Moore’s law has given us somewhere between 40,000 and 60,000 times improvement in that time. So there’s approximately a factor of 1,000 in efficiency that has been lost by bad CPU architectures.</p>

<p>仅仅插一句，给你一个有趣的指标 - 对大致相同的机器，大致用相同的方式优化，根据施乐Xerox在1979的基准，今天的机器只快了50倍。在这个期间，摩尔定律给了我们大概40000到60000倍的提升。因此，由于糟糕的CPU架构设计，大约有因子为1000倍的效率损失了。</p>

<p>The myth that it doesn’t matter what your processor architecture is—that Moore’s law will take care of you—is totally false.</p>

<p>不用在意你处理器的架构，摩尔定律将照顾你。这个神话，是完全错误的。</p>

<p><strong>SF</strong> It also has something to do with why some languages succeed at certain times.</p>

<p><strong>SF</strong> 也可以来看看为什么一些语言在特定时间会成功。</p>

<p><strong>AK</strong> Yes, actually both Lisp and Smalltalk were done in by the eight-bit microprocessor—it’s not because they’re eight-bit micros, it’s because the processor architectures were bad, and they just killed the dynamic languages. Today these languages run reasonably because even though the architectures are still bad, the level 2 caches are so large that some fraction of the things that need to work, work reasonably well inside the caches; so both Lisp and Smalltalk can do their things and are viable today. But both of them are quite obsolete, of course.</p>

<p>是的，事实上Lisp和Smalltalk都在8位微处理器上完成 - 这不是因为他们是8位的微指令，而是因为糟糕的处理器架构，它们刚好扼杀了动态语言。今天，这些语言合情合理地运行着，因为即使架构仍然糟糕，但是L2缓冲如此大，有些需要做的事情，在缓冲中合理地运行良好；因此Lisp和Smalltalk能够做他们的事情，在今天是切实可行的。但是，当然他们两个快要过时了。</p>

<p>The stuff that is in vogue today is only about “one-half” of those languages. Sun Microsystems had the right people to make Java into a first-class language, and I believe it was the Sun marketing people who rushed the thing out before it should have gotten out. They made it impossible for the Sun software people to do what needed to be done.
今天在流行的东西，只是那些语言的“一半”。Sun公司有正确的人将Java变成第一流的语言。我相信这是Sun的营销人员在其本该出现之前，赶制出来的。他们使得Sun的软件人员不可能去做需要做的事。</p>

<p><strong>SF</strong> What should Java have had in it to be a first-quality language, not just a commercial success?</p>

<p>为了成为第一流的语言，而非商业的成功，Java本身还需具备什么？</p>

<p><strong>AK</strong> Like I said, it’s a pop culture. A commercial hit record for teenagers doesn’t have to have any particular musical merits. I think a lot of the success of various programming languages is expeditious gap-filling. Perl is another example of filling a tiny, short-term need, and then being a real problem in the longer term. Basically, a lot of the problems that computing has had in the last 25 years comes from systems where the designers were trying to fix some short-term thing and didn’t think about whether the idea would scale if it were adopted. There should be a half-life on software so old software just melts away over 10 or 15 years.</p>

<p>如同我前面说的，这是个流行文化。给十多岁青少年听的流行唱片，不是必须要有特别的音乐价值。我认为各种编程语言的很大成功是应急的填坑。Perl是另一个例子，为了满足细微而短期的需求，然而成为更长期内的一个实际麻烦。根本上，过去25年中计算方面的很多问题，都来自于这样的系统，设计者试图修复一些事情，并没有思考如果采纳的话，这个点子应具扩展性。软件本该只有一半的寿命，从而旧软件在10到15年间消逝掉。</p>

<p>It was a different culture in the ’60s and ’70s; the ARPA (Advanced Research Projects Agency) and PARC culture was basically a mathematical/scientific kind of culture and was interested in scaling, and of course, the Internet was an exercise in scaling. There are just two different worlds, and I don’t think it’s even that helpful for people from one world to complain about the other world — like people from a literary culture complaining about the majority of the world that doesn’t read for ideas. It’s futile.</p>

<p>在1960和70年代，有着不同的文化；高级研究项目管理局(ARPA)和帕洛阿尔托研究中心(PARC)的文化，根本上讲，是一种数学/科学性的文化，对扩展性感兴趣，当然，Inernet就是规模化的一个练习。恰恰有两个不同的世界，我不认为，一个世界的人抱怨另一个世界的人们甚至有什么帮助，就好像来自一个文学文化的人们抱怨世界上大多数的人不能读懂意思。这是无用的。</p>

<p>I don’t spend time complaining about this stuff, because what happened in the last 20 years is quite normal, even though it was unfortunate. Once you have something that grows faster than education grows, you’re always going to get a pop culture. It’s well known that I tried to kill Smalltalk in the later ’70s. There were a few years when it was the most wonderful thing in the world. It answered needs in a more compact and beautiful way than anything that had been done before. But time moves on. As we learned more and got more ambitious about what we wanted to do, we realized that there are all kinds of things in Smalltalk that don’t scale the way they should—for instance, the reflection stuff that we had in there. It was one of the first languages to really be able to see itself, but now it is known how to do all levels of reflection much better—so we should implement that.</p>

<p>我不想花时间抱怨这个事，因为在过去20年发生的非常正常，即使这是不幸的。一旦你有些东西，它比教育增长得更快，你总会得到一个流行文化。众所周知，我试图在70年代晚期终结Smalltalk。它在一些年头是世界上最漂亮的东西。它以比之前做过的任何东西更为紧致和漂亮的方式去回应了需要。但是时间在往前走。随着我们学会更多，对我们想做的事更有抱负的时候，我们认识到在Smalltalk中所有种类的事物，不能以它们本该的方式去扩展 – 例如，发射。它是真正看到它自身的最早的语言之一，但是现在知道了如何更好地做所有层次的发生 – 因此，我们必须实现之。</p>

<p>We saw after a couple of years that this could be done much better. The object model we saw after a couple of years could be done much better, etc. So the problem is—I’ve said this about both Smalltalk and Lisp—they tend to eat their young. What I mean is that both Lisp and Smalltalk are really fabulous vehicles, because they have a meta-system. They have so many ways of dealing with problems that the early-binding languages don’t have, that it’s very, very difficult for people who like Lisp or Smalltalk to imagine anything else.</p>

<p>几年之后我们看到，这可以做得更好。我们几年之后看到的对象模型可以做得更好，等等。因此，问题是，我曾经说过关于Smalltalk和Lisp – 它们常常吃掉它们的幼崽。我的意思是，Lisp和Smalltalk是真正绝妙的载体，因为它们有一个元系统。它们有那些早期绑定语言不具备的如此多的方式去处理问题，以至于对于喜欢Lisp或Smalltalk的人非常难想象哈有其它什么。</p>

<p>Now just to mention a couple of things about Java: it really doesn’t have a full meta-system. It has always had the problem—for a variety of reasons—of having two regimes, not one regime. It has things that aren’t objects, and it has things that it calls objects. It has real difficulty in being dynamic. It has a garbage collector. So what? Those have been around for a long time. But it’s not that great at adding to itself.</p>

<p>现在谈到Java的一些事情：它确实没有一个全面的元系统。它总因为不同的原因，存在有两个体制，而非一个体制的问题。它有一些不是对象的东西，它有一些称为对象的东西。它成为动态的有实际的困难。它有一个垃圾收集器。那又怎么样？这些已经四处都是很长时间了。只将垃圾收集器加到它里面，没那么高明。</p>

<p>For many years, the development kits for Java were done in C++. That is a telling thing.</p>

<p>在很多年，Java的开发工具用C++完成。这是个有说服力的事情。</p>

<p>We looked at Java very closely in 1995 when we were starting on a major set of implementations, just because it’s a lot of work to do a viable language kernel. The thing we liked least about Java was the way it was implemented. It had this old idea, which has never worked, of having a set of paper specs, having to implement the VM (virtual machine) to the paper specs, and then having benchmarks that try to validate what you’ve just implemented — and that has never resulted in a completely compatible system.</p>

<p>我们在1995年仔细观察Java，当时我们正着手一个主要的实现集，仅仅因为做一个可行的核有很多事情要干。我们最不喜欢的事情，是Java实现的方式。它有这样的陈旧想法，从来没有奏效过，即：定义一组纸面的规范，要求按照纸面规范去实现VM(虚拟机)，然后用标杆去试图验证你刚刚实现的。这个想法从来没有产生一个完全兼容的系统。</p>

<p>The technique that we had for Smalltalk was to write the VM in itself, so there’s a Smalltalk simulator of the VM that was essentially the only specification of the VM. You could debug and you could answer any question about what the VM would do by submitting stuff to it, and you made every change that you were going to make to the VM by changing the simulator. After you had gotten everything debugged the way you wanted, you pushed the button and it would generate, without human hands touching it, a mathematically correct version of C that would go on whatever platform you were trying to get onto.</p>

<p>我们用在Smalltalk上的技术是用它自己来写虚拟机，因此有一个VM的Smalltalk仿真器，它本质上就是VM的唯一规范。通过将材料提交给它，你可以调试，你可以回答任何问题，关于VM可以做什么。一旦你将所有事情都以你想的方式调试过，你按一下按钮，不需要人去插手，它将生成一个数学上正确的C版本，可以在你想尝试的任何平台上去运行。</p>

<p>The result is that this system today, called Squeak, runs identically on more than two dozen platforms. Java does not do that. If you think about what the Internet means, it means you have to run identically on everything that is hooked to the Internet. So Java, to me, has always violated one of the prime things about software engineering in the world of the Internet.</p>

<p>其结果就是，今天这个称为Squeak的系统，在超过20个平台上无差别第运行。Java做不到这点。如果你想想Internet意味着什么，它意味着你必须无差别地运行任何挂在Internet上的东西。因此，Java，对我来说，常常违反关于软件工程在Internet世界的一个初衷。</p>

<p>Once we realized that Java was likely not to be compatible from platform to platform, we basically said we’ll generate our own system that is absolutely compatible from platform to platform, and that’s what we did.</p>

<p>一旦我们认识到，Java很可能在跨平台不能兼容，我们从根本上决定，我们将生成我们自己的系统，它在平台到平台之间是绝对兼容的。这就是我们做的。</p>

<p>Anybody can do that. If the pros at Sun had had a chance to fix Java, the world would be a much more pleasant place. This is not secret knowledge. It’s just secret to this pop culture.</p>

<p>任何人都能做到。假使Sun的正方有机会修正Java，世界机会是更为愉悦的地方。这里没有机密的知识。仅仅对这一流行文化是个秘密。</p>

<p><strong>SF</strong> If nothing else, Lisp was carefully defined in terms of Lisp.
如果没有其它的，Lisp是仔细以Lisp的方式定义的。</p>

<p><strong>AK</strong> Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.
是的，当我在研究生院时，这对我是个巨大的启示 – 当我最终理解Lisp 1.5版手册第13页下部的半页代码，是Lisp自己的时候。这就是“软件中的麦克斯韦方程”。整个的编程世界可以放在聊聊几行中 – 可以放在我的掌心。</p>

<p>I realized that anytime I want to know what I’m doing, I can just write down the kernel of this thing in a half page and it’s not going to lose any power. In fact, it’s going to gain power by being able to reenter itself much more readily than most systems done the other way can possibly do.</p>

<p>我认识到，任何时候当我想知道我正在做的，我就将这件事的核心写在半页纸上，这没有失去任何力量。事实上，通过能够比大多数系统尽可能用其它方式所做的，更容易地重新进入事情，将会获得力量。</p>

<p>All of these ideas could be part of both software engineering and computer science, but I fear—as far as I can tell—that most undergraduate degrees in computer science these days are basically Java vocational training.</p>

<p>所有这些想法，可以是软件工程和计算机科学的一部分，但是我害怕 - 就我能说的 - 计算机科学里的大多数本科学位，根本上讲，是Java的职业培训。</p>

<p>I’ve heard complaints from even mighty Stanford University with its illustrious faculty that basically the undergraduate computer science program is little more than Java certification.</p>

<p>我从甚至强大的、带有杰出教师队伍的斯坦福大学那里听到的抱怨是，根本上讲，本科计算机科学课程，没有比Java认证多出什么。</p>

<p><strong>SF</strong> Well, I must admit I was surprised recently when I discovered in a group of very good developers I managed, almost none of them knew C well enough to write expert low-level stuff. All of them were really good Java jocks.</p>

<p><strong>SF</strong> 好的，我必须承认，最近我有些惊讶，当我发现我管理的一个优秀开发人员组成的团队，几乎没有人足够好的了解C，能写出专家级的底层工作。他们都确实是Java的好手。</p>

<p><strong>AK</strong> In the 1960s Ted Steele spent several years promoting an idea called UNCOL (universal computer-oriented language), and, to me, by a weird and interesting process—mainly because it’s easy to implement—C turned out to be UNCOL. I don’t think any human being should write in it, but it’s a great target for anybody who wants to do multiplatform things—especially if you pick the right subset.</p>

<p>在1960年代，Ted Steele花了好几年推广一个称为UNCOL(universal computer-oriented language，通用面向计算机语言)的想法。对我，通过一个怪诞和有趣的过程，主要是因为它容易实施 - C转到UNCOL。我不认为任何人必须用它写程序，但是对于任何想做多平台事情的人，它是一个伟大的目标，特别是如果你选择了正确的子集。</p>

<p>The problem with the Cs, as you probably know if you’ve fooled around in detail with them, is that they’re not quite kosher as far as their arithmetic is concerned. They are supposed to be, but they’re not quite up to the IEEE standards. You have to pick a subset of C and you have to have some side information to get to a mathematically perfect transform of your VM.</p>

<p>SF To what do you attribute the long-term love of Smalltalk? There is a certain set of languages that I would assert people seem to love, not just use. I know many people who love C. I know very few who love C++, even though they may make their living on it.</p>

<p>AK You have to be a different kind of person to love C++. It is a really interesting example of how a well-meant idea went wrong, because [C++ creator] Bjarne Stroustrup was not trying to do what he has been criticized for. His idea was that first, it might be useful if you did to C what Simula did to Algol, which is basically act as a preprocessor for a different kind of architectural template for programming. It was basically for super-good programmers who are supposed to subclass everything, including the storage allocator, before they did anything serious. The result, of course, was that most programmers did not subclass much. So the people I know who like C++ and have done good things in C++ have been serious iron-men who have basically taken it for what it is, which is a kind of macroprocessor. I grew up with macro systems in the early ’60s, and you have to do a lot of work to make them work for you—otherwise, they kill you.</p>

<p>SF Well, C++, after all, was programmed as a macro processor, in essence.</p>

<p>AK Yes, exactly. But so was Simula.</p>

<p>SF I put Smalltalk in this category of languages that have true devotees—people who genuinely like it or love it, not simply appreciate and use it.</p>

<p>AK In a history of Smalltalk I wrote for ACM, I characterized one way of looking at languages in this way: a lot of them are either the agglutination of features or they’re a crystallization of style. Languages such as APL, Lisp, and Smalltalk are what you might call style languages, where there’s a real center and imputed style to how you’re supposed to do everything. Other languages such as PL/I and, indeed, languages that try to be additive without consolidation have often been more successful. I think the style languages appeal to people who have a certain mathematical laziness to them. Laziness actually pays off later on, because if you wind up spending a little extra time seeing that “oh, yes, this language is going to allow me to do this really, really nicely, and in a more general way than I could do it over here,” usually that comes back to help you when you’ve had a new idea a year down the road. The agglutinative languages, on the other hand, tend to produce agglutinations and they are very, very difficult to untangle when you’ve had that new idea.</p>

<p>Also, I think the style languages tend to be late-binding languages. The agglutinative languages are usually early-binding. That makes a huge difference in the whole approach. The kinds of bugs you have to deal with, and when you have to deal with them, is completely different.</p>

<p>Some people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope. If you combine Simula and Lisp—Lisp didn’t have data structures, it had instances of objects—you would have a dynamic type system that would give you the range of expression you need.</p>

<p>It would allow you to think the kinds of thoughts you need to think without worrying about what type something is, because you have a much, much wider range of things. What you’re paying for is some of the checks that can be done at runtime, and, especially in the old days, you paid for it in some efficiencies. Now we get around the efficiency stuff the same way Barton did on the B5000: by just saying, “Screw it, we’re going to execute this important stuff as directly as we possibly can.” We’re not going to worry about whether we can compile it into a von Neumann computer or not, and we will make the microcode do whatever we need to get around these inefficiencies because a lot of the inefficiencies are just putting stuff on obsolete hardware architectures.</p>

<p>I just think that’s a two-culture divide. I’ve seen many meetings where people are unable to communicate just because of the stylistic differences in approaches.</p>

<p>SF I would characterize style languages as those with a very rigorous kernel that describes them intellectually. As Smalltalk went through a number of revolutions, to what extent did those change the core kernel, as opposed to improving the range of usefulness?</p>

<p>AK We’ll never know the exact answer to your question because during the development of the system, from when Xerox put it out to this day, all the changes happened in a single thread of development at Xerox PARC. To the outside world, Smalltalk has changed almost not at all. Basically, it’s just built on bigger and bigger libraries of different kinds.</p>

<p>But the good thing about the changes in Smalltalk was that it never got diluted, and the scope of the practical things you could think about doing in Smalltalk expanded dramatically during the period at Xerox PARC.</p>

<p>Basically what happened is this vehicle became more and more a programmer’s vehicle and less and less a children’s vehicle—the version that got put out, Smalltalk ’80, I don’t think it was ever programmed by a child. I don’t think it could have been programmed by a child because it had lost some of its amenities, even as it gained pragmatic power.</p>

<p>So the death of Smalltalk in a way came as soon as it got recognized by real programmers as being something useful; they made it into more of their own image, and it started losing its nice end-user features.</p>

<p>But that’s OK. This project that we started in 1995 was to make Squeak as an implementation vehicle for another end-user system for children. That was done quite well and is being used by many, many thousands of children around the world. The other way of looking at this is to realize that computers are made to be programmed by human beings. Let’s just roll our own. Let’s not complain about Java, or even about Smalltalk.</p>

<p>In fact, let’s not even worry about Java. Let’s not complain about Microsoft. Let’s not worry about them because we know how to program computers, too, and in fact we know how to do it in a meta-way. We can set up an alternative point of view, and we’re not the only ones who do this, as you’re well aware.</p>

<p>There are numerous examples on the Internet of people who have gone to one level or another by making their own point of view. Squeak is the most comprehensive because it spans the whole field. It doesn’t require any particular operating system to run because it’s self-sufficient and has a full set of tools and applications and so forth, but there are many interesting functional languages, particularly in Europe, that are of interest.</p>

<p>One of my favorite old languages is one called Lucid by Ed Ashcroft. It was a beautiful idea. He said, “Hey, look, we can regard a variable as a stream, as some sort of ordered thing of its values and time, and use Christopher Strachey’s idea that everything is wonderful about tail recursion and Lisp, except what it looks like.” When he looked at Lisp, he had a great insight: which was that tail-recursive loops and Lisp are so clean because you’re generating the right-hand side of all the assignment statements before you do any rebinding. So you’re automatically forced to use only old values. You cannot rebind, so there are no race conditions on anything.</p>

<p>You just write down all of those things, and then when you do the tail recursion, you rebind all of those variables with these new values. Strachey said, “I can write that down like a sequential program, as a bunch of simultaneous assignment statements, and a loop that makes it easier to think of.” That’s basically what Lucid did—there is no reason that you have to think recursively for things that are basically iteration, and you can make these iterations as clean as a functional language if you have a better theory about what values are.</p>

<p>This idea, by the way, was used in [Squeak contributor] Dave Reed’s fantastic thesis for coordinating object siblings where you have one logical object but many physical manifestations of the same object on different machines, and you have to make them track each other by transactions.</p>

<p>The way to get rid of these things (like Smalltalk) is to make something that is much, much more powerful as a computation model and much more expressive for the core programmer who is trying to write programs. In these late programming languages, you can disappear the old guy and just leave the new guy behind. So we are doing that at this moment.</p>

<p>SF What do you think a programming language should achieve and for whom, and then what is the model that goes with that idea?</p>

<p>AK Even if you’re designing for professional programmers, in the end your programming language is basically a user-interface design. You will get much better results regardless of what you’re trying to do if you think of it as a user-interface design. PARC is incorrectly credited with having invented the GUI. Of course, there were GUIs in the ’60s. But I think we did do one good thing that hadn’t been done before, and that was to realize the idea of change being eternal.</p>

<p>SF You never walk in the same river, otherwise known as Strachey streams.</p>

<p>AK The user interface, which is still the predominant approach today, is a user interface as the access to function. If the area is interesting, you eventually wind up with something that looks like the control panel of a nuclear reactor. So this is the agglutination of features.</p>

<p>SF Yes, a button on every pixel.</p>

<p>AK Corporate buyers often buy in terms of feature sets. But at PARC our idea was, since you never step in the same river twice, the number-one thing you want to make the user interface be is a learning environment—something that’s explorable in various ways, something that is going to change over the lifetime of the user using this environment. New things are going to come on, and what does it mean for those new things to happen?</p>

<p>This means improvements not only in the applications but also in the user interface itself. Some of those ideas were quite manifest in the original Macintosh, but are much less manifest in the Macs of today—and of course never really made it to Microsoft. That just wasn’t their way of thinking about things, and I think a programming language is the same way. Even if the user is an absolute expert, able to remember almost everything, I’m always interested in the difference between what you might call stark meaning and adjustable meaning.</p>

<p>I did quite a bit of study on that over the years to understand the influence of having something that you can read. It’s known that our basic language mechanism for both reading and hearing has a fast and a slow process. The fast process has basically a surface phrasal-size nature, and then there’s a slower one. This is why jokes require pauses; the joke is actually a jump from one context to another, and the slower guy, who is dealing with the real meanings, has to catch up to it.</p>

<p>There have been many, many studies of this. This argues that the surface form of a language, whatever it is, has to be adjustable in some form.SF As you probably know, recent research has looked at how different parts of the brain recognize and react to jokes. Physically, they are quite distinct.</p>

<p>AK Yes. All creativity is an extended form of a joke. Most creativity is a transition from one context into another where things are more surprising. There’s an element of surprise, and especially in science, there is often laughter that goes along with the “Aha.” Art also has this element. Our job is to remind us that there are more contexts than the one that we’re in—the one that we think is reality.</p>

<p>In the ’60s, one of the primary goals of the computer science community was to arrive at an extensible language. As far as I know, only three ever actually worked, and the first Smalltalk was one of those three. Another very interesting one was done by Ned Irons, who invented the term syntax-directed compiler and did one of the first ones in the ’60s. He did a wonderful extensible language called Imp.</p>

<p>One of the things that people realized from these extensible languages is that there is the unfortunate difficulty of making the meta-system easy to use. Smalltalk-72 was actually used by children. You’re always extending the language without realizing it when you are making ordinary classes. The result of this was that you didn’t have to go into a more esoteric place like a compiler compiler—Yacc or something like that—to add some extension to the language.</p>

<p>But the flip side of the coin was that even good programmers and language designers tended to do terrible extensions when they were in the heat of programming, because design is something that is best done slowly and carefully.</p>

<p>SF And late-night extensible programming is unsupportable.</p>

<p>AK Exactly. So Smalltalk actually went from something that was completely extensible to one where we picked a syntax that allowed for a variety of forms of what was fixed, and concentrated on the extensibility of meaning in it.</p>

<p>This is not completely satisfactory. One of the things that I think should be done today is to have a fence that you have to hop to forcibly remind you that you’re now in a meta-area—that you are now tinkering with the currency system itself, you are not just speculating. But it should allow you to do it without any other overhead once you’ve crossed this fence, because when you want to do it, you want to do it.</p>

<p>I could go on and on. I feel like my answers are quite trivial since nobody really knows how to design a good language, including me.</p>

<p>SF What do you wish you had done differently in the Smalltalk era?</p>

<p>AK I had the world’s greatest group, and I should have made the world’s two greatest groups. I didn’t realize there are benefits to having real implementers and real users, and there are benefits to starting from scratch every few months. I hired finishers because I’m a good starter and a poor finisher, but it took me a long time to realize that I was interfering with them by trying to improve things.</p>

<p>I believe that the only kind of science computing can be is like the science of bridge building. Somebody has to build the bridges and other people have to tear them down and make better theories, and you have to keep on building bridges.</p>

<p>SF And every so often, you have to watch one fall into the drink.</p>

<p>LOVE IT, HATE IT? LET US KNOW</p>

<p>feedback@acmqueue.com or www.acmqueue.com/forums</p>

<p>© 2004 ACM 1542-7730/04/1200 $5.00</p>

<p>acmqueue</p>

<p>Originally published in Queue vol. 2, no. 9— 
see this item in the ACM Digital Library</p>

<p>Related:
Erik Meijer, Kevin Millikin, Gilad Bracha - Spicing Up Dart with Side Effects 
A set of extensions to the Dart programming language, designed to support asynchrony and generator functions</p>

<p>Dave Long - META II: Digital Vellum in the Digital Scriptorium 
Revisiting Schorre’s 1962 compiler-compiler</p>

<p>Bo Joel Svensson, Mary Sheeran, Ryan Newton - Design Exploration through Code-generating DSLs 
High-level DSLs for low-level programming</p>

<p>Andy Gill - Domain-specific Languages and Code Synthesis Using Haskell 
Looking at embedded DSLs</p>

<p>Comments</p>

<table>
  <tbody>
    <tr>
      <td>sebastian</td>
      <td>Fri, 16 Dec 2011 17:40:27 UTC</td>
    </tr>
  </tbody>
</table>

<p>love it.
Fantastic conversation.</p>

<table>
  <tbody>
    <tr>
      <td>Norberto Ortigoza</td>
      <td>Tue, 27 Aug 2013 02:09:20 UTC</td>
    </tr>
  </tbody>
</table>

<p>Really great! Congrats Stuart.
Geraldo Coen | Sun, 29 Sep 2013 00:09:57 UTC</p>

<p>Great text. Great ideas by a person who built computer science and applied software concepts. Just one point: Algol 68 is not mentionned as a language with a meta-language.
Dan | Tue, 15 Oct 2013 16:51:01 UTC</p>

<p>I dabbled in SmallTalk for a biz app in mid 90’s but it was too slow so abandoned. The language was the best I have used. I cannot help but think if it came out today with good support for GUI widgets on each platform that it would take off like wild fire. Persistent classes/objects modifying themselves (what Kay calls Late-Binding) talking over a mesh network. For example, a group of objects may notice they are doing the same over and over and decide to create a new object to handle the job more efficiently. JVM’s do some of this now but we are long ways off from true interaction and development.
Post a Comment:</p>

<p>Comment: (Required - 4,000 character limit - HTML syntax is not allowed and will be removed) </p>

<p>© 2014 ACM, Inc. All Rights Reserved.</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/concepts-in-lisp/">Concepts in LISP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-01T12:07:42+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="forms">Forms</h3>

<p>The things which you type to the LISP interpreter are called forms; the LISP interpreter repeatedly reads a form, evaluates it, and prints the result. This procedure is called the read-eval-print loop.</p>

<p>你键入到Lisp中的东西，称为form。Lisp 反复地读取一个form，对它求值，然后打印结果。这个过程称为，“读取-求值-打印”循环，缩写为REPL。</p>

<p>In general, a form is either an atom (for example, a symbol, an integer, or a string) or a list. If the form is an atom, LISP evaluates it immediately. Symbols evaluate to their value; integers and strings evaluate to themselves. If the form is a list, LISP treats its first element as the name of a function; it evaluates the remaining elements recursively, and then calls the function with the values of the remaining elements as arguments.</p>

<p>通常，一个form要么是原子(例如，符号、整数或字符串)，或者是列表。原子，也称为正常form或自求值form(normal form or self-evaluating form)。符号求值为它们的值；整数和字符串求值为他们自己。如果form是列表，也称为复合form(compound form)。LISP将其第一个元素视为函数名；它迭代地对剩下的元素求值，然后将剩下元素的值作为参数来调用函数。</p>

<h4 id="special-form">Special Form</h4>

<p>A special form is a form with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both. A special operator has access to the current lexical environment and the current dynamic environment. Each special operator defines the manner in which its subexpressions are treated—which are forms, which are special syntax, etc. </p>

<p>The set of special operator names is fixed in Common Lisp; no way is provided for the user to define a special operator. The next figure lists all of the Common Lisp symbols that have definitions as special operators.</p>

<p>(来源：<a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm">http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm</a>)</p>

<p>特殊form是一个form, 带有特殊语法或特殊求值规则，或兼有。它可能操纵求值环境、控制流，或兼有。一个特殊的运算符访问当前的词法环境和当前的动态环境。每个特殊的运算符定义了，如何处理其子表达式的方式，哪些是form，哪些是特殊语法，等等。</p>

<p>在Common Lisp中，特殊运算名的集合是固定的。没有给用户提供定义特殊运算符的方式。如下列出了所有作为特殊运算符定义的Common Lisp符号。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>block</td>
      <td>let*</td>
      <td>return-from</td>
    </tr>
    <tr>
      <td>catch</td>
      <td>load-time-value</td>
      <td>setq</td>
    </tr>
    <tr>
      <td>eval-when</td>
      <td>locally</td>
      <td>symbol-macrolet</td>
    </tr>
    <tr>
      <td>flet</td>
      <td>macrolet</td>
      <td>tagbody</td>
    </tr>
    <tr>
      <td>function</td>
      <td>multiple-value-call</td>
      <td>the</td>
    </tr>
    <tr>
      <td>go</td>
      <td>multiple-value-prog1</td>
      <td>throw</td>
    </tr>
    <tr>
      <td>if</td>
      <td>progn</td>
      <td>unwind-protect</td>
    </tr>
    <tr>
      <td>labels</td>
      <td>progv</td>
      <td> </td>
    </tr>
    <tr>
      <td>let</td>
      <td>quote</td>
      <td> </td>
    </tr>
  </tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/big-data-system-2/">Lambda Architechture</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T17:03:39+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="what-is-data-system">What is Data System</h2>

<p>query = function(all data)</p>

<h2 id="section">大数据系统的要求</h2>

<p>一个数据系统，就是要向应用提供数据的存储、加工、修改和查询的系统。<a href="http://manning.com/marz/">Big Data</a>一书中，总结大数据系统必须满足如下要求：</p>

<ul>
  <li>容错性
包含两方面，物理容错性和人为容错性
    <ul>
      <li>物理容错性
由于允许数据分区，也就是分布式存储。那不可避免有些机器会宕机或者系统软件等出现故障，导致其不可访问。局部的错误，不会导致整体系统不可访问。</li>
      <li>人为容错性
程序可能有bug, 对数据进行错误的修改。那么应该有办法恢复，然后用修正后的程序重新计算。</li>
    </ul>
  </li>
  <li>
    <p>可扩展性
这是一个广泛使用，但容易引起混淆的概念。这里指的是，通过增加资源，系统在更大负载下，保持性能的能力。尽管系统有扩展性，但<strong>线性扩展性</strong>，才是有意义的。如果是与负载呈平方或者四次方的扩展性，是不实用的。</p>
  </li>
  <li>
    <p>低延迟的读或修改
绝大多数应用对于读，需要很小的延迟，在几毫米到几百毫秒。而对于修改的延迟，不同的应用要求不同，从几毫秒到几小时不等。</p>
  </li>
  <li>
    <p>普遍性(Generalization)
一个普遍的系统应能支持很大范围的应用，比如财务管理系统、社交媒体分析、科学应用、社交网络等等。</p>
  </li>
  <li>
    <p>延展性(Extensibility)
可延展的系统，允许以较小的开发成本增加新的特性或功能。</p>
  </li>
  <li>
    <p>维护最小化(Minimal maintenance)</p>

    <p>维护是对开发者收的税。维护是为了确保系统平滑运行而需要做的工作。最小化维护量的一个重要举措，是选择部署复杂度尽可能小的部件。</p>
  </li>
  <li>
    <p>可调试性(Debuggability)</p>

    <p>一个大数据系统必须在出错时，提供必要的信息来调试系统。其关键是能够追踪，对于系统中的每个值，恰恰是什么导致了这个值。</p>
  </li>
</ul>

<h2 id="lambda-">Lambda 架构</h2>

<p>本书主要是介绍Lambda架构，作为大数据的新范式，见下图：</p>

<p><img src="../images/bigdata/LambdaArchitecture.png" alt="" /></p>

<p>Lambda架构认为，</p>

<ul>
  <li>batch view = function(all data)</li>
  <li>realtime view = function(realtime view, new data)</li>
  <li>query = function(batch view. realtime view)</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/big-data-system-1/">Why Big Data System?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-08T10:38:19+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:38 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://nathanmarz.com">Nathan Marz</a> 的新书 <a href="http://manning.com/marz/">Big Data</a> 对大数据系统及Lambda架构有深入和详尽的讨论。加上自己对数据库使用的多年经验和思考，准备写一组博文，作为读书笔记和思考总结。</p>

<h2 id="section">为何大数据</h2>

<p>大数据是与互联网相伴而生的。传统的应用系统和数据库，都是针对企业层面的应用，而且主要用于事务处理。企业也只是占据整个市场的一定份额，因此数据量有限。而由于网络的规模效应，在互联网上更容易产生“赢者通吃”的结果，所以互联网企业往往面对的是社会化的普遍需求，用户数、数据量和访问量都巨大。大数据表现在：</p>

<ul>
  <li>
    <p>数据量大</p>

    <p>用户数少则几百万，上千万，过亿很普遍。随着商业的繁荣、市场细分和个性化需求的挖掘，商品数SKU，经常达到几十万。日均交易上千万笔。
 搜索引擎的网页数据库，也达到几千TB。</p>
  </li>
  <li>
    <p>访问量
 无论是读取(浏览、查询)还是写入(修改、增加)</p>
  </li>
  <li>数据多样化
 除过通常的交易类数据，还有：
    <ul>
      <li>文档</li>
      <li>网页
搜索引擎的网页缓存</li>
      <li>图片
Facebook, 微信, Flickr的图片分享</li>
      <li>视频</li>
      <li>搜索引擎的索引数据库
 这些都不是RDBMS擅长管理的。</li>
    </ul>
  </li>
  <li>数据处理方式
除过事务型处理外，还有批量处理，如机器学习、在线学习、流式处理等。</li>
</ul>

<h2 id="section-1">为什么需要大数据系统</h2>

<p>大家对关系型数据库(RDBMS)并不陌生。早期的商业系统主要为了处理交易，比如银行存取款、证券交易、销售、采购、订票等。这也称为OLTP(在线事务处理)系统。其对数据操作的特点是，基于索引定位的单记录(少数记录)操作较多，读写随机，而且高并发性，数据记录的改变反映了资源的变化、状态的迁移或相关活动的触发。OLTP属于业务关键性应用，所以数据的一致性、并发控制和容错，至关重要。而RDBMS比较完美地解决了OLTP对持久化存储的需要，因而占据了主导地位。RDBMS有很多共性：</p>

<ul>
  <li>逻辑结构
    <ul>
      <li>基于关系代数的逻辑结构和建模方法</li>
      <li>SQL结构化查询语言</li>
    </ul>
  </li>
  <li>数据一致性保证
    <ul>
      <li>事务处理</li>
      <li>锁机制</li>
      <li>日志</li>
    </ul>
  </li>
  <li>容错
    <ul>
      <li>数据文件镜像</li>
      <li>备份与恢复</li>
      <li>高可用性复制</li>
    </ul>
  </li>
</ul>

<p>那么为什么会有大数据和NoSQL数据库的出现呢？这就要说到RDBMS的局限，因为它是基于关系代数设计的：</p>

<ol>
  <li>
    <p>由于关系代数强调的是遵循范式和数据一致性，所以在性能上不是最优的。数据文件存放在磁盘上，而磁盘IO速度远低于内存速度，很多数据库的优化都不得不绕过范式，实现更快的性能。</p>
  </li>
  <li>
    <p>关系性建模要求一开始就把数据模型确定下来，随后的调整很费力。但随着迭代式开发模式的普及，数据结构需具灵活性、易于调整。而且有些数据不适合以关系模型去描述，比如key-value、文档数据库等。</p>
  </li>
  <li>
    <p>对于批量处理的应用，如数据仓库、数据挖掘和机器学习等，数据库事务控制会增加很大的开销，但又不是必须的。</p>
  </li>
</ol>

<p>而且，传统的RDMBS实际上是单机系统。虽然RDMBS也有集群版本，但所有的集群必须共享一个存储源(通常是磁盘阵列)。无论有再多的服务器，RMDBS只有一个日志系统、一个统一的事务控制。就好比一个人不能有两个脑袋。从CAP定理来看，RDBMS保证了一致性(Consistency)和可用性(Availability)，但因此必须牺牲分区容受性(Patition Tolerance)。)这致使RDMBS面对大数据时，就会捉襟见肘。</p>

<ol>
  <li>
    <p>数据量的局限
互联网应用的数据达到TB、PB级，不是单机可以存储的。即便通过数据分片，将数据物理地分散在多个存储设备上，也有存储设备本身的限制。而传统的磁盘阵列价格高昂。</p>
  </li>
  <li>
    <p>吞吐量的限制
无论数据如何分散到多个存储设备，整个数据库还是有中心控制机制。这必然造成锁、消息队列等关键资源的瓶颈，限制了并发性。换言之，传统的RDBMS是中心化的设计，和去中心化设计的思路是相反的。只有去中心化后，才能实现分区化。</p>
  </li>
  <li>
    <p>应用特点不同
互联网的应用不同于OLTP的特点。一次写入，多次读出；写后一般不会修改；数据以添加的方式写入。</p>
  </li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/notes-on-the-books-big-data-system/">Notes on the Books Big Data System</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-05T14:02:04+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>5</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content">
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/color-space/">Color Space</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-28T11:07:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Primary Color
	Color, Blue, and Yellow</p>

<p>Secondary Color
	Orange, Green and Violet </p>

<p>Tertiary Color
	Red-Orange, Yellow-Orange, Yellow-Green, Blue-Green, Blue-Violet and Red-Violet</p>

<p>Neutral Color: 不带色彩的颜色。白、黑、灰</p>

<p>Achromatic color 没有色彩。它们包含：白、黑和灰。中性色改变所有色彩的密度和值。</p>

<h3 id="scheme">Scheme</h3>

<h4 id="monochromatic-color-scheme">Monochromatic Color Scheme(单色主题)</h4>
<p>由任何颜色或中性色的色泽(tint), 色调(tone)和阴影的复合。</p>

<h4 id="analogous-color-scheme">Analogous Color Scheme(相似色主题)</h4>
<p>在色轮中，相互毗邻的3组颜色组成。</p>

<h4 id="extended-analogous-color-scheme">Extended Analogous Color Scheme(扩展的相似色主题)</h4>
<p>在色轮中，相互毗邻的4组颜色组成。</p>

<h4 id="complementary-color-scheme">Complementary Color Scheme(互补色主题)</h4>
<p>在色轮中，相对的两组颜色组成。</p>

<h4 id="split-complementary-color-scheme">Split Complementary Color Scheme(分离互补色主题)</h4>
<p>由一组颜色与它相对处毗邻的两组颜色组成。</p>

<h4 id="triadic-color-scheme">Triadic Color Scheme(三色系主题)</h4>
<p>由色轮中等距相隔的三组颜色组成。</p>

<h4 id="section">对比色</h4>

<h3 id="hsv">HSV</h3>

<ul>
  <li>Value(颜色值)：指一个颜色的相对亮度(brightness)或暗度。</li>
  <li>Saturation(or purity, 饱和度或纯度)：描述一个颜色有多纯。一个纯粹的颜色是干净而明亮的(clear and bright)，增加黑让它变模糊和暗(muddy and dark)，给它一个阴影。加白让颜色被冲洗(washed out)或着色(tinted)。</li>
</ul>

<h3 id="section-1">色温</h3>
<p>颜色可以分为两类：
* 暖色(aggressive, 前进色)：红、黄、棕
* 冷色(receding, 后退色)：绿、蓝、紫
* </p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/understanding-features/">Understanding Features</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-27T16:10:06+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:10 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="feature-detection">Feature Detection</h3>

<h3 id="feature-description">Feature Description</h3>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/an-introduction-to-computer-vision/">An Introduction to Computer Vision</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-10T17:58:15+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:58 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://www.slideshare.net/alagala/computer-vision-with-android-google-gtug-bangkok-2011?qid=836f92da-83e3-478c-8ad5-63884666fa32&amp;v=qf1&amp;b=&amp;from_search=4">Computer Vision with Android (Google GTUG Bangkok 2011)</a></p>

<p>YCbCr, 类似于彩色电视广播所用的YUV色空间，到RGB转化。
人的视觉对亮度比对色相更敏感。</p>

<p>灰度图像能从YCbCr直接转化得到，不需进一步处理。</p>

<p>图像边缘探测 Image edge detection</p>

<p>形态学morphology</p>

<p>直方图分析</p>

<p>人脸识别的三种方法：</p>

<ul>
  <li>EigenFaces</li>
  <li>FisherFaces</li>
  <li>Local Binary Paths Histogram(LBPH)</li>
  <li></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/ble-beacons-ibeacons/">BLE Beacons iBeacons</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-09T18:00:43+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>6:00 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>BLE是低功耗蓝牙的意思：BlueTooth LE(low energy)。由于低功耗，电池寿命常。</p>

<h4 id="promixity-vs-location">Promixity vs Location</h4>

<p>定位是指物理位置。而Promixity是强调移动设备接近目标。</p>

<p>Beacon是近场定位。 </p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/about-creative-commons/">About Creative Commons</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-08T16:33:00+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:33 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>参考slide share:</p>

<p><a href="http://www.slideshare.net/ramblinglibrarian/creative-commons-what-how-why">http://www.slideshare.net/ramblinglibrarian/creative-commons-what-how-why</a></p>

<p>一个creative commons license包含三个部分：</p>

<ul>
  <li>机器识别的</li>
  <li>人可读的</li>
  <li>法律条文</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/06/a-conversation-with-alan-kay/">A Conversation With Alan Kay</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/concepts-in-lisp/">Concepts in LISP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/big-data-system-2/">Lambda Architechture</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/big-data-system-1/">Why Big Data System?</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/notes-on-the-books-big-data-system/">Notes on the Books Big Data System</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Steven Liu <stevenliucx@gmail.com> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
