
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Life Matrix</title>
  <meta name="author" content="Steven Liu <stevenliucx@gmail.com>&#8221;>

  
  <meta name="description" content="第零部分： LISP和解释器
Part Zero LISP and Interpreters 递归方程
Recursion Equations Contrary to popular belief, LISP was not originally derived from
Church’s λ— &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hack.the-lifematrix.net">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Life Matrix" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       jax: ["input/TeX", "output/HTML-CSS"],
       tex2jax: {
          inlineMath: [ ['$', '$'] ],
          displayMath: [ ['$$', '$$']],
          procehssEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       },
       messageStyle: "none",
       "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
     });
   </script>
   <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Life Matrix</a></h1>
  
    <h2>Hacking, Machine learning</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hack.the-lifematrix.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/resources">Resources</a></li>
  <li><a href="/lisp-resource">Lisp Resource</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/the-art-of-interpreter-ii/">The Art of Interpreter II</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-18T16:52:51+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:52 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="lisp">第零部分： LISP和解释器</h3>
<p>Part Zero 
LISP and Interpreters</p>

<h4 id="section">递归方程</h4>
<p>Recursion Equations</p>

<p>Contrary to popular belief, LISP was not originally derived from
Church’s λ—calculus [Church] [LISP History]. The earliest LISP did not
have a well—defined notion of free variables or procedural objects. Early
LISP programs were similar to recursion equations, defining functions on
symbolic expressions (“S—expressions”). They differed from the equations
of pure recursive function theory [Kleene] by introducing the conditional
expression construction (often called the “McCarthy conditional”), to avoid
“pattern-directed invocation”. That is, in recursive function theory one
would define the factorial function by the following two equations:</p>

<p>与流行的说法相反，LISP最初不是从邱奇的λ演算中派生出来的。最早的LISP没有一个对自由变量和过程对象的良好定义的记号。早期的LISP程序与递归方程类似，在符号表达式(“S-expressions”)上定义函数。他们不同于纯粹递归函数理论公式，是在于引入了条件表达式构造(经常称为”McCarthy条件”)，从而避免“模式导向的调用”。也就是，在递归函数理论中，可以通过如下两个方程定义阶乘函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factorial(0) = 1
</span><span class="line">factoria1(successor(x)) = successor(x) * factorial(x)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In early LISP, however, one would have written:</p>

<p>但是在早期的LISP中，需要写成这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factoria1[x] = [x=0 -&gt; 1; T -&gt; x*factorial[x-1]]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where “[a -&gt; b; T —&gt; c]” essentially means “if a then b else c”. The
recursive function theory version depends on selecting which of two
equations to use by matching the argument to the left-hand sides (such a
discipline is actually used in the PROLOG language [Warren]); the early
LISP version represents this decision as a conditional expression.</p>

<p>这里 [a -&gt; b; T —&gt; c] 根本上意指 “如果a就b，或者c”。这个递归函数理论的版本在于，通过将参数匹配到左侧(这样的规则的确在PROLOG语言中用到)，来选择要使用哪个公式；早期的LISP版本将这个决策表示为一个条件表达式。</p>

<p>The theory of recursion equations deals with functions over the
natural numbers. In LISP, however, one is interested in being able to manipulate algebraic expressions, programs, and other symbolic expressions
as data structures. While such expressions can be encoded as numbers
(using the technique of “arithmetization” developed by Kurt Godel), such an
encoding is not very convenient. Instead, a new kind of data called “S-
expressions” .(for “symbolic expressions”) is introduced specifically to
provide convenient encodings. S-expressions can be defined by a set of
formal inductive axioms analogous to the Peano Postulates used to define
natural numbers. Here we will give only an informal and incomplete definition of S—expressions; for a more complete description, see {Note S-
expression Postulates and Notation}.</p>

<p>递归公式处理自然数的函数。然而，在LISP里，人们的兴趣在于能够操作代数表达式、程序和如数据结构一样的符号表达式。虽然这样的表达式能用数字编码(使用Kurt Godel开发的”算术化“技术)，但这样的编码不是很方便。相反，一种称为”S表达式“(即：符号化表达式, symbolic expression)的新的类型的数据被特别引入进来，为了提供方便的编码。S-表达式能通过一组正规的归纳公理来定义，它与Peano假定用以定义自然数的类似。这里，我们仅给出一个非正规和不完备的S表达式定义；对于一个更为完备的描述，请看注释{Note S-
expression Postulates and Notation}。</p>

<p>For our purposes we will need only the special cases of S-expressions called atoms and lists. An atom is an “indivisible” data object, which we denote by writing a string of letters and digits; if only digits are used, then the atom is considered to be a number. Many special characters such as “-“ and “+” are considered to be letters; we will see below that it is not necessary to specially reserve them for use as operator symbols. A list is a (possibly empty) sequence of S—expressions, notated by writing the S—expressions in order, between a set of parentheses and separated by spaces. A list of the atoms “F00”, “43”, and “BAR” would be written “(F00 43 BAR)”. Notice that the definition of a list is
recursive. For example,</p>

<p>对于我们的目的，我们只需要S表达式特殊的情形，称为atom和list。一个“原子”是不可分割的数字对象，我们表示为字母和数字的串；如果只用到数字，那么原子就被认为是数字。许多特殊的字符，比如”-“和”+“，被认为是字母；我们将在后面看到，没有必要特别地将它们保留下来作为操作符号。一个列表是S表达式的序列(可能是空的)，表示为按顺序写S表达式，用空格分开，在一组括号中间。原子”F00”, “43”和”BAR”的列表写为”(FOO 43 BA)”。注意列表的定义是递归的。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (SECOND X) (CAR (CUR X)))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>is a list of three things: the atomic symbol DEFINE, a list of the two
atomic symbols SECOND and X, and another list of two other things.</p>

<p>是有3个事物的列表：原子符号 DEFINE，一个有两个原子符号SECOND和X的列表，和另一个列表，它包含两个其它事物。</p>

<p>We can use S-expressions to represent algebraic expressions by
using “Cambridge Polish” notation, essentially a parenthesized version of
prefix Polish notation. Numeric constants are encoded as numeric atoms;
variables are encoded as non—numeric atoms (which henceforth we will call
atomic symbols); and procedure invocations are encoded as lists, where the
first element of the list represents the procedure and the rest represent
the arguments. For example, the algebraic expression “a<em>b+c</em>d” can be
represented as “(+ (* a b) (* c d))”. Notice that LISP does not need the
usual precedence rules concerning whether multiplication or addition is
performed first; the parentheses explicitly define the order. Also, all
procedure invocations have a uniform syntax, no matter how many arguments
are involved. Infix, superscript, and subscript notations are not used;
thus the expression “$J_p (x^2+1)$” would be written “(J p (+ (^ x 2) 1))”.</p>

<p>我们通过使用”剑桥波兰“记号来表示代数表达式，它本质上是加括号的前缀波兰版本。数字常数被编码为数字原子；变量被编码为非数字的原子(今后我们将称其为原子符号)；一个过程的调用被编码为列表，其中列表的第一个元素代表过程，剩余的部分代表参数。例如，代数表达式”a<em>b+c</em>d”可以表示为”(+ (* a b) (* c d))”。注意LISP不需要通常的优先级规则，比如先执行乘法还是加法；括号已经显式地定义了次序。而且，所有的过程调用有一致的语法，无论有多少个参数。没有用到，中缀、上标或下标：因此表达式”$J_p (x_2+1)$”，将被写成”(J p (+ (^ x 2)1))”。</p>

<p>To encode a conditional expression：</p>

<p>为了编码一个条件表达式：</p>

<script type="math/tex; mode=display">[p_1 -> e_1; p_2 -> e_2; ... ; p_n -> e_n]</script>

<p>(which means to evaluate the predicates p_i in order until a true one is found, at which point the value of $e_j$ is taken to be the value of the
conditional) we write the S-expression</p>

<p>其含义是对判定式p_i按顺序求值，直到发现一个为真，此时$e_j$会被取出作为条件的值。我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(COND (p_1 e_1) (p_2 e_2) ... (p_n e_n))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we can now encode sets of LISP recursion equations as S-expressions. For the equation</p>

<p>我们能将一组LISP递归等式编码为S表达式的形式。对于等式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factoria1[x] = [x=0 -&gt; 1; T -&gt; x*factoria1[x-1]]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we write the S-expression</p>

<p>我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (FACTORIAL x)
</span><span class="line">	(COND ((= X 0) 1)
</span><span class="line">		  (T (* x (FACTORIAL (- x 1))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(we could also have written</p>

<p>(我们也能写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (FACTORIAL X) (cond ((=
</span><span class="line">x 0) 1) (T (* x (FACTORIAL (- x
</span><span class="line">1))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>but we conventionally lay out S-expressions so that they are easy to read.)</p>

<p>但是我们习惯上会排版S表达式以便易于阅读。</p>

<p>We now have a complete encoding for algebraic expressions and LISP
recursion equations in the form of S-expressions. Suppose that we now want
to write a LISP program which will take such an S-expression and perform
some useful operation on it, such as determining the value of an algebraic
expression. We need some procedures for distinguishing, decomposing, and
constructing S-expressions.</p>

<p>我们现在已经有了对代数表达式的完整编码，以及S表达式的形式下的递归等式。假设我们现在想写一个LISP程序，它能拿起这样的S表达式并对其执行一些有用的操作，比如确定代数表达式的值。我们需要一些过程来区分、分解、构造S表达式。</p>

<p>The predicate ATOM, when applied to an S-expression, produces true
when given an atom and false otherwise. The empty list is considered to be
an atom. The predicate NULL is true of only the empty list; its argument
need not be a list, but may be any S-expression. The predicate NUMBERP is
true of numbers and false of atomic symbols and lists. The predicate EQ,
when applied to two atomic symbols, is true if the two atomic symbols are
identical. It is false when applied to an atomic symbol and any other S-
expression. (We have not defined EQ on two lists yet; this will not
become important, or even meaningful, until we discuss side effects.)</p>

<p>断言ATOM，当应用到S表达式上，如果给的是原子，则产生真，否则为假。空列表被认为是一个原子。断言NULL只有对空列表是为真；它的参数不必要是列表，可以是任何表达式。当一个原则符号和列表是数字时，断言NUMBERP是真，否则为假。断言EQ，当应用到两个原子符号时，如果两个原子符号相等，则为真。如果应用到一个原子符号，和任何其他S表达式上，则为假。(我们还没有定义两个列表的EQ；这将不那么重要，或甚至有意义，直到我们讨论副作用。)</p>

<p>The decomposition operators for lists are traditionally called CAR
and CDR for historical reasons. [LISP History] CAR extracts the first
element of a list, while CDR produces a list containing all elements but
the first. Because compositions of CAR and CDR are commonly used in LISP,
an abbreviation is provided: all the C’s and R’s in the middle can be
squeezed out. For example, ‘(CDR (CDR (CAR (CDR X))))’ can be written as
“(CDDADR X)”.</p>

<p>由于历史的原因，列表的分解操作符传统上被称为car和cdr。[LISP History] CAR提取列表的第一个元素，而CDR生成一个除过第一个元素之外的所有剩余元素的列表。因为car和cdr的组合在LISP中经常用到，就提供了一个缩写：所有中间的C和R可以积压出去。例如’(CDR (CDR (CAR (CDR X))))’，可以写为”(CDDADR X)”。</p>

<p>The construction operator CONS, given an S-expression and a list,
produces a new list whose CAR is the S-expression and whose CDR is the
list. The operator LIST can take any number of arguments (a special
feature), and produces a list of its arguments.</p>

<p>构造操作符CONS，给定S表达式和一个列表，生成一个新的列表，其CAR是S表达式，而CDR是列表。操作符LIST能接收任意数目的参数(一个特殊特性)，然后产生这些参数的列表。</p>

<p>We can now write some interesting programs in LISP to deal with S-expressions. For example, we can write a predicate EQUAL, which determines whether two S-expressions have the same CAR-CDR structure:</p>

<p>我们现在可用LISP写一些有趣的程序，来处理S表达式。例如，我们写一个断言EQUAL, 它确定两个S表达式有相同的CAR-CDR结构。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (EQUAL X Y)
</span><span class="line">          (COND ((NUMBERP X)
</span><span class="line">                 (COND ((NUMBERP Y) (= X Y))
</span><span class="line">                       (T NIL)))
</span><span class="line">                ((ATOM X) (EQ X Y))
</span><span class="line">                ((ATOM Y) NIL)
</span><span class="line">                ((EQUAL (CAR X) (CAR Y)) 
</span><span class="line">                 (EQUAL (CDR X) (CDR Y)))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we have used the standard names T and NIL to represent ture and false.
(Traditionally NIL is also considered to be the empty list, but we will
avoid this here, writing “()” for the empty list.)</p>

<p>这里我们使用标准的名字T和NIL来表示和false。(传统上，NIL也被认为是空列表，但是我们将在这里避免这些，写”()”代表空列表)。</p>

<p>Because LISP programs are represented as LISP data structures (S-expressions), there is a difficulty with representing constants. For
example, suppose we want to determine whether or not the value of the
variable X is the atomic symbol “FOO”. we might try writing:</p>

<p>因为LISP程序表示为LISP数据结构(S表达式)，在表达常量时有些困难。比如，假设我们想确定变量X的值是否为原子符号”F00”，我们可能试图写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQ X FOO)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This doesn’t work. The occurrence of “FOO” does not refer to the atomic
symbol FOO as a constant; it is treated as a variable, just as “X” is.</p>

<p>这不能奏效。FOO的出现没有将FOO引用为一个常量；它被看做一个变量，如同X一样。</p>

<p>The essential problem is that we want to be able to write any 5-
expression as a constant in a program, but some S—expressions must be used
to represent other things, such as variables and procedure invocations. To
solve this problem we invent a new notation: (QUOTE X) in a program
represents the constant S-expression x. {Note QUOTE Mapping} Thus we can
write our test as “(EQ X (QUOTE FOO)”. Similarly,</p>

<p>本质的问题是，我们想能够在程序中将任何S表达式按照常量的方式书写，但是一些S表达式必须被用来表示其它一些，比如变量和过程调用。为了解决这个问题，我们发明了一个新记号：(QUOTE X)在程序中表示常数S表达式X。{注释： QUOTE Mapping} 因此我们能将我们的测试写为：(EQ X (QUOTE FOO)。类似的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQUAL X (LIST Y Z))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>constructs a list from the values of Y and z, and compares the result to
the value of X, while</p>

<p>从X和Y的值中构造一个列表，然后将结果与X的值比较，而：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQUAL X (QUOTE (LIST Y Z)))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>compares the value of X to the constant S-expression “(LIST Y Z)”. Because
the QUOTE construction is used so frequently in LISP, we use an abbreviated
notation: “‘FOO” is equivalent to “(QUOTE FOO)”. This is only a notational
convenience; the two notations denote the same S-expression. (S-
expressions are not character strings, but data objects with a certain
structure. We use character strings to notate S-expressions on paper, but
we can use other notations as well, such as little boxes and arrows. We 
can and do allow several different character strings to denote the same S-
expression.) </p>

<p>将X的值与常数表达式(LIST Y Z)去比较。因为在LISP中QUOTE构造经常被用到，我们使用一个缩写记号：”’FOO”等价于”(QUOTE FOO)”。这只是一个记号的惯例。两个记号表示相同的S表达式。(S表达式不是字符串，而是带有特定结构的数据对象。我们使用字符串去表示文章中的S表达式。我们能够且也允许几种不同的字符串去表示相同的S表达式)。</p>

<h4 id="lisp-">LISP 递归等式的解释器</h4>
<p>An Interpreter for LISP Recursion Equations</p>

<p>We now have enough machinery to begin our examination of the
genetic history of LISP. We first present a complete interpreter for LISP
recursion equations. The language interpreted is a dialect of LISP which
allows no free variables except for names of primitive or defined
procedures, and no definitions of procedures within other procedures.</p>

<p>我们现在有足够的机制去开始对LISP起源历史的检视。我们首先展现一个LISP递归等式的完全解释器。被解释的语言是LISP的一个方案，它不允许自由变量，除过原语或已定义过程的名字，在别的过程中没有过程的定义。</p>

<p>The driver loop reads in definitions of procedures of the form:</p>

<p>驱动循环的读取 form的过程定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (F A B C ...) &lt;expression in A B C ... and F G H ...&gt;)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and saves them. It can also read in requests to apply some defined
procedure to some arguments (or, more generally, to evaluate any
expression), in which case it prints the resulting value. An expression
may consist of variable references, constants (numbers and quoted s-
expressions), procedure calls, and conditional expressions (COND). The
defined procedures may refer to each other and to initially supplied
primitive procedures (such as CAR, CONS, etc.). Definitions may contain
“forward references”, as long as all necessary definitions are present at
the time of a request for a computation. The interpreter itself is
presented here as a set of such definitions, and so is meta—circular.</p>

<p>并保存它们。它也能读入请求去将一些定义的过程应用到一些参数(或者，更通常，去求值任意表达式)，在这种情况下它打印结果值。一个表达式可以包含变量引用，常数(数字和引号的S-表达式)，过程调用和条件表达式。被定义的过程可能相互引用，并引用到初始提供的原语过程(比如CAR, CONS，等等)。定义可能包括“向前引用”，只要所有必须的定义在请求计算的那一刻是存在的。这呈现的解释器自身是一组如此的定义，也就是元循环。</p>

<p>The language is intended to be evaluated in applicative order; that is, all arguments to a procedure are fully evaluated before an attempt
is made to apply the procedure to the arguments. (It is necessary to state
this explicitly here, as it is not inherent in the form of the meta-circular definition. See [Reynolds] for an explication of this problem.)</p>

<p>The driver loop (see Figure 1) is conceptually started by a request
to invoke DRIVER with no arguments. Its task is to first print the message
“LITHP ITH LITHTENING” (a tradition of sorts) and then invoke DRIVER—LOOP.
The expression &lt;THE-PRIMITIVE-PROCEDURES) is intended to represent a constant
list structure, containing definitions of primitive procedures, to be
supplied to DRIVER—LO0P.</p>

<p>(DEFINE (DRIVER)
(DRIVER-LOOP (THE-PRIMITIVE—PROCEDURES) (PRINT ‘|LITHP ITH LITHTENlNG|)))</p>

<p>(DEFINE (DRIVER—LO0P PROCEDURES HUNOZ)
(DRIVER—LOOP—l PROCEDURES (READ)))</p>

<p>(DEFINE (DRIVER-LOOP-1 PROCEDURES FORM)
(COND ((ATOM FORM)
(DRIVER-LOOP PROCEDURES (PRINT (EVAL FORM ‘() PROCEDURES))))
((EO (CAR FORM) ‘DEFINE)
(DRIVER-LOOP (BIND (LIST (CAADR FORM))
(LIST (LIST (CDADR FORM) (CADDR FORM)))
PROCEDURES)
(PRINT (CAADR FORM))))
(T (DRIVER-LOOP PROCEDURES (PRINT (EVAL FORM ‘() PROCEDURES))))))</p>

<p>Figure 1
Top Level Driver Loop for a Recursion Equations Interpreter</p>

<p>DRIVER-LOOP reads an S—expression from the input stream and passes
it, along with the current procedure definitions, to DRIVER-LOOP-1. This
procedure in turn determines whether the input S-expression is a</p>

<p>definition. If it is, then it uses amp (described below) to produce an_</p>

<p>augmented set of procedure definitions, prints the name of the defined
procedure, and calls DRIVER-LOOP to repeat the process. The augmented set of
procedures is passed to DRIVER-LOOP, and so the variable PROCEDURES always
contains all the accumulated definitions ever read. If the input S-
expression is not a definition, then it is given to the evaluator EVAL,
whose purpose is) to determine the values of expressions. {Note Value
Quibble) The set of currently defined procedures is also passed to EVAL.</p>

<p>The process carried on by the driver loop is often called the “top
level”;— all user programs and requests are run‘ “under” it. The growing</p>

<p>set of procedure definitions is called the “top—level environment”; this _</p>

<p>environment changes in the course of the user interaction, and contains the
state of the machine as perceived by the user._ It is within this
environment that user programs are executed. ‘
Steele and Sussman 9 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__E</strong>__</p>

<p>(DEFINE (EVAL EXP ENV PROCEDURES)
(coND ((ATOM EXP)
(COND ((Eo EXP ‘NlL) ‘NIL)</p>

<p>((Eo EXP ‘7) ‘1)
((NUMBERP EXP) EXP)
(T (vALDE EXP ENV))))</p>

<p>((Eo (cAR ExP) ‘QUOTE)</p>

<p>(CADR ExP))</p>

<p>((EQ (cAR EXP) ‘COND)</p>

<p>(EVCOND (cDR EXP) ENV PRocEDuREs))
(T (APPLY (VALUE (CAR EXP) PROCEDURES)
(EVLIS (cDR EXP) ENV PROCEDURES)
PRocEDuREs))))</p>

<p>(DEFINE (APPLY FUN ARGS PRocEDuREs)
(COND ((PRlMOP FUN) (PRIMOP-APPLY FUN ARes))
(T (EVAL (CADR FUN)
(BIND (cAR FUN) ARGS ‘())
PRocEDuREs))))</p>

<p>(DEFINE (EVCOND CLAUSES ENV PROCEDURED)
(COND ((NULL CLAUSES) (ERROR))
((EVAL (CAAR CLAUSES) ENV PROCEDURES)
(EVAL (CADAR CLAUSES) ENV PROCEDURES))
(T (EVCOND (COR CLAUSES) ENV PROCEDURES))))</p>

<p>(DEFINE (EVLIS ARGLIST ENV PROCEDURES)
(COND ((NULL ARGLIST) ‘())
(T (CONS (EVAL (CAR ARGLIST) ENV PROCEDURES)
(EVLIS (CDR ARGLIST) ENV PROCEDURES)))))</p>

<p>Figure 2
Evaluator for a Recursion Equations Interpreter</p>

<p>The evaluator proper (see Figure 2) is divided into two conceptual
components: EvAL and APHX. EVAL classifies expressions and directs their
evaluation. Simple expressions (such as constants and variables) can be
evaluated directly. For the complex case of procedure invocations
(technically called “combinations”), EVAL looks up the procedure
definition, recursively evaluates the arguments (using EVLIS), and then
calls APPLY. APPLY classifies procedures and directs their application.
Simple procedures (primitive operators) are applied directly. For the
Complex case of user-defined procedures, ANY uses DIND to build an
environment, a kind of symbol table, associating the formal parameters from
the procedure definition with the actual argument values provided by EVAL.
The body of the procedure definition is then passed to EVAL, along with the
environment just constructed, which is used to determine the values of
Steele and Sussman ‘ ‘ 10 The Art of the Inter reter</p>

<p>variables occurring in the body.</p>

<p>In more detail, EvAL is a case analysis on the structure of the S-
expression EXP. If it is an atom, there are several subcases. The special
atoms T and NIL are defined to evaluate to T and NIL (this is strictly for
convenience, because they are used as truth values). Similarly, for
convenience numeric atoms evaluate to themselves. (These cases could be
eliminated by requiring the user to write lots of QUOTE forms: ‘T, ‘N1L,
‘43, etc. This would have been quite inconvenient in early LISP, before
the “”” notation had been introduced; one would have had to write (QUOTE
43), etc.) Atomic symbols, however, encode variables; the value
associated with that symbol is extracted from the environment Euy using the
function VALUE (see below). - .</p>

<p>If the expression to be evaluated is not atomic, then it may be a
QUOTE form, a coup form, or a combination. For a Quote: form, EVAL extracts
the S-expression constant using CADR. Conditionals are handled by -EVCOND,
which calls EVAL on a predicate expression; if the predicate is true,
EVCOND evaluates the corresponding result expression (by calling EVAL, of</p>

<p>course); if the predicate is false, EVCOND calls itself to test the”</p>

<p>predicate of the next clause of the COND body. For combinations, the
procedure is obtained, the arguments evaluated (using EvL1s), and APPLY
called as described earlier. Notice that VALUE is used to get the
procedure definition from the set PROCEDURES; we can do this because, as an</p>

<p>engineering trick, we arrange for ENV and PROCEDURES to have the same
structure, because they are both symbol tables.</p>

<p>EVLIS is a simple recursive function which calls EVAL on successive
arguments in ARGLIST and produces a list of the values in order.</p>

<p>APPLY distinguishes two kinds of procedures: primitive and user-
defined. For now we avoid describing the precise implementation of
primitive procedures by assuming the existence of a predicate PRIMOP which
is true only of primitive procedures, and a function PRmoP-APPLY which deals
with the application of such primitive procedures. (See’{Note Primitive
Operators} for the details of a possible implementation of PRIMOP and PRmoP-
APPLY.) we consider primitive procedures to be a kind of atomic S-
expression other-than numbers and atomic symbols; we define no particular
written notation for them here. However, primitive procedures are not to
be confused with the atomic symbols used as their names. The result of
(VALUE ‘CAR PROCEDURES) is not the atomic symbol CAR, but rather some bizarre
object which is meaningful only to PRIMOP-APPLY.</p>

<p>User-defined procedures are represented here as lists. These lists</p>

<p>are constructed by DRIVER-LOOP-1. The car of the list is the list of formal
parameters, and the cadr is the body of the definition.
Steele and Sussman 11 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong><em>~</em></strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__E</strong>___</p>

<p>(DEFINE (BIND VARS ARGS ENV)
(COND ((= (LENGTH VARS) (LENGTH ARGS))
(CONS (CONS VARS ARGS) ENV))
(T (ERROR))))</p>

<p>(DEFINE (VALUE NAME ENV)
‘ (VALUEI NAME (LOOKUP NAME ENv)))</p>

<p>(DEFINE (VALUEI NAME SLOT)
(CQND ((E0 SLOT ‘&amp;UNBOUND) (ERROR))
(T (CAR SLOT))))</p>

<p>(DEFINE (LOOKUP NAME ENv)
(coND ((NULL ENv) ‘&amp;UNBOUND)
(T (LOOKUPI NAME (CAAR ENv) (CDAR ENv) ENV))))</p>

<p>(DEFINE (LOOKUPI NAME VARS vALs ENv)
(COND ((NULL VARS) (LOOKUP NAME (con ENV)))
((EQ NAME (CAR VARS)) vALs)
(T (LOOKUPI NAME (con VARS) (con VALS) ENV))))</p>

<p>Figure 3
Utility Routines for Maintaining Environments</p>

<p>The interpreter uses several utility procedures for maintaining
symbol tables (see Figure 3). A symbol table is represented as a list of
buckets; each bucket is a list whose car is a list of names and whose cdr
is a list of corresponding values. {Note This ain’t A—lists} If a variable
name occurs in more than one bucket. the leftmost such bucket has priority;
in this way new symbol defnntions added to the front of the list can
supersede old ones.</p>

<p>BIND takes a list of names, a list of values, and a symbol table,
and produces a new symbol table which is the old one augmented by an extra
bucket containing the new set of associations. (It‘also performs a useful
error check —-LENGTH returns the length of a list.)</p>

<p>VMDE is essentially an interface to Loomw. we define it because
later. in Part Three, we will want to use different versions of- vALuE1</p>

<p>without changing the underlying algorithm in Loomw. The check for &amp;UNBOUND
catches incorrect references to undefined variables.</p>

<p>Loomw takes a name and a symbol table, and returns that portion off</p>

<p>a bucket whose car is the associated value. (This definition will be more
useful later than one in which the value itself is returned.)</p>

<p>Note carefully the use of the variable PmmEmmEs in the
interpreter. when omvERlomL1 calls EVM_ it passes the current list of
defined procedures (both primitive and user-defined). DRIvEm¢ooP-1 is the
only routine which augments the value of PmmEmmEs, and this value is only
Steele and Sussman 12 The Art of the Inter reter</p>

<p>used in EVAL, when it is passed to VALUE. However, a_l_l of the routines
APPLY, evconp, and evus have to know about PROCEDURES, and dutifully pass it
along so that it may be eventually used by EVAL. The set of definitions
must be passed along because there is no provision for free variables or
side effects; there is no way to have “memory” or “state” other than in
passed variables. The absence of free variables effectively causes our
language to be referentially transparent. However, we sense a disturbing
lack of modularity in the use of PROCEDURES (and, to a lesser extent, in the
use of ENV — look at cvcorm and EVLI‘S). we will return to this point later.</p>

<p>Our recursion equations language has no special iteration or
looping constructs, such as the Algol for statement or the FORTRAN D0 loop.
All loops are constructed by arranging for recursive procedures to call
themselves or each other. For example, EVCOND (see Figure 2) iterates over
the clauses of a couo by calling itself on successive “tails” of the list
of clauses. Now such recursive calls may strike the reader familiar with
other languages (such as Algol, FORTRAN, PL/I, etc.) on an intuitive level
as being rather inefficient for implementing real programs. Even granted
that calls might be made fast, they would seem to consume space in the form
of return addresses and other control information. Examination of the
recursion equations evaluator will show, however, that this phenomenon does
not have to occur. This is because no extra information is saved if there
is nothing left to do on return from a recursive call. See [SCHEME] and
[Debunking] for a more thorough discussion of this.
Steele and Sussman 13 I The Art of the Inter reter
<strong><em>.</em></strong><strong>__</strong>~<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><em>£</em>___</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/the-art-of-interpreter-i/">The Art of Interpreter I</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-18T10:22:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文地址：<a href="http://c2.com/cgi/wiki?TheArtOfTheInterpreter">http://c2.com/cgi/wiki?TheArtOfTheInterpreter</a>
<br /></p>
<hr />

<center> 
MASSACHUSETTSINSTYTUTECHTTECHNOLOCY ARTIFICIAL INTELLIGENCE LABORATORY
<br />

AI Memo No.453                May 1978
<br />

<strong>The Art of the Interpreter
<br />
or, The Modularity Complex
(Parts Zero, One, and Two)</strong>

<br />
by
<br />

Guy Lewis Steele Jr.* and Gerald Jay Sussman**

</center>

<h3 id="section">摘要</h3>
<p>Abstract:</p>

<p>We examine the effects of various language design decisions on the
programming styles available to a user of the language, with particular
emphasis on the ability to incrementally construct modular systems. At
each step we exhibit an interactive meta-circular interpreter for the
language under consideration. Each new interpreter is the result of an
incremental change to a previous interpreter.</p>

<p>我们检验了现存编程风格上的语言设计决策对语言使用者的影响，特别关注增量构造模块化系统的能力。在每一个步，针对所考虑的语言，我们展示了一个交互式的元-循环解释器。每个新的解释器都是对先前解释器增量修改的结果。</p>

<p>We explore the consequences of various variable binding disciplines
and the introduction of side effects. We find that dynamic scoping is
unsuitable for constructing procedural abstractions, but has another role
as an agent of modularity, being a structured form of side effect. More
general side effects are also found to be necessary to promote modular
style. We find that the notion of side effect and the notion of equality
(object identity) are mutually constraining; to define one is to define
the other.</p>

<p>我们探索了不同变量绑定纪律的后果，并引入了副作用(side-effect)。我们发现，动态范围不适合构造过程的抽象，但是有作为模块代理的另一作用，是副作用的一个结构化形式。也发现了更多普遍的副作用，对提升模块化风格是必要的。我们发现副作用的记号和相等的记号(对象同一性)是相互约束的。为了定义其中一个，就必须定义另一个。</p>

<p>The interpreters we exhibit are all written in a simple dialect of
LISP, and all implement LISP-like languages. A subset of these interpreters constitute a partial historical reconstruction of the actual evolution of LISP.</p>

<p>我们展示的解释器都用LISP的简单方言写出，它们都实现了类LISP的语言。这些解释器的子集包含LISP实际进化的部分历史再现。</p>

<p>Keywords: abstraction, actors, applicative order, bindings, control structures, debugging, dynamic scoping, environments, fluid variables, FUNARG
problem, functional objects, interactive programming, lambda-calculus.
lexical scoping, LISP, modularity, procedural data, recursion equations,referential transparency, SCHEME, side effects, static scoping, structured programming</p>

<p>This report describes research done at the Artificial Intelligence
Laboratory of the Massachusetts Institute of Technology. Support for the
laboratory’s artificial intelligence research is provided in part by the</p>

<p>Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N000l4-75-C-0643.</p>

<h3 id="section-1">内容</h3>

<ul>
  <li>Introduction
    <ul>
      <li>Modularity</li>
      <li>LISP-like Languages</li>
      <li>Structure of the Paper</li>
    </ul>
  </li>
  <li>Part Zero-— LISP and Interpreters
    <ul>
      <li>Recursion{Equations</li>
      <li>An Interpreter for LISP Recursion Equations</li>
    </ul>
  </li>
  <li>Part One —— Variable Scoping Disciplines
    <ul>
      <li>Procedures as Data</li>
      <li>Local Procedures</li>
      <li>Lexical Scoping</li>
      <li>Top Levels versus Referential Transparency</li>
    </ul>
  </li>
  <li>Part Two — State
    <ul>
      <li>Decomposition of State</li>
      <li>Side Effects and Local State</li>
      <li>Side Effects in the Interpreter</li>
      <li>Equipotency of SETQ and RPLACA</li>
      <li>Side Effects and Equality</li>
      <li>Dynamic Scoping as a State-Decomposition Discipline</li>
    </ul>
  </li>
  <li>Summary</li>
  <li>Acknowledgements</li>
  <li>Notes
    <ul>
      <li>{Can George do Better?}</li>
      <li>{Debugging}</li>
      <li>{Driver Loop with Side Effects}</li>
      <li>{EVALQUOTE}</li>
      <li>{Gaussian}</li>
      <li>{LABEL5}</li>
      <li>{LABEL5 with Side Effects}*</li>
      <li>{Primitive Operators}</li>
      <li>{PROGN wizardry}</li>
      <li>{QUOTE Mapping}</li>
      <li>{QUOTE Shafts the Compiler}</li>
      <li>{RPLACA Can Alter CAR Instead}</li>
      <li>{S—expression Postulates and Notation}</li>
      <li>{This ain’t A-lists}</li>
      <li>{Value Quibb1e}</li>
      <li>{Weber}</li>
      <li>{Y-operator}</li>
    </ul>
  </li>
  <li>References</li>
</ul>

<h3 id="section-2">介绍</h3>
<p>Introduction</p>

<h4 id="section-3">模块化</h4>
<p>Modularity</p>

<p>The entities constructed by programming are extremely complex.
Accurate construction of large programs would be impossible without
specific techniques for controlling this complexity. Most such techniques
are based on finding ways to decompose a problem into almost independently
solvable subproblems, allowing a programmer to concentrate on one
subproblem at a time, ignoring the others. When the subproblems are
solved, the programmer must be able to combine the solutions with a minimum
of unanticipated interactions. To the extent that a decomposition succeeds
in breaking a programming problem into manageable pieces, we say that the
resulting program is modular; each part of the solution is called a
module. Well—designed programming languages provide features which support
the construction of modular programs.</p>

<p>编程产生的实体极端复杂。如果没有控制这一复杂性的特定技术，要准确无误地构造大型程序是不可能的。绝大多数这样的技术是基于寻找一些方法，将问题分解为几乎独立可求解的子问题，允许程序员一次聚焦于一个子问题，而忽略其它的。当自问题被解决了，程序员必须能够以最小的不可预见的互作用，将解决方案组合在一起。如果一个分解达到了成功地将一个编程问题拆分成可管理部分的程度，我们称如此生成的程序是模块化的；解决方案的每个部分称为一个模块。设计良好的编程语言提供了支持构建模块化程序的特性。</p>

<p>One decomposition strategy is the packaging of common patterns of
the use of a language. For example, in Algol a for loop captures a common
pattern of if and goto statements. Packages of common patterns are not
necessarily merely abbreviations to save typing. While a simple
abbreviation has little abstraction power because a user must know what the
abbreviation expands into, a good package encapsulates a higher level
concept which has meaning independent of its implementation. Once a
package is constructed the programmer can use it directly, without regard
for the details it contains, precisely because it corresponds to a single
notion he uses in dealing with the programming problem.</p>

<p>一个分解策略是将使用一个语言的共同模式打包。例如，在Algol中，一个for loop 语句捕获了if和goto语句的共同模式。共同模式的包并非只是为了节约打字的缩写而需的。虽然一个简单的缩写没有什么抽象能力，因为用户必须知道缩写扩展成什么，但是一个好的包，能在更高层次的概念上封装，具有独立于实现的含义。一旦一个包构造出来，程序员能直接使用它，不需要考虑它包含的细节，正好是因为程序员在处理编程问题时将它作为单一的记号来使用。</p>

<p>A package is most useful if its behavior is independent of the
context of its use, thus reducing possible interference with other
packages. Such a package is called referentially transparent.
Intuitively, referential transparency requires that the meanings of parts
of a program be apparent and not change, so that such meanings can be
reliably depended upon. In particular, names internal to one module should
not affect or be affected by other modules — the external behavior of a
module should be independent of the choice of names for its local
identifiers.</p>

<p>如果一个包的行为独立于使用它的上下文，它是最有用的，从而减少了与其它包可能的干扰。这样的包被称为<strong>引用透明(referentially transparent)</strong>。直觉地，引用透明要求一个程序某部分的意思是明明白白的，不会改变，从而能可靠地依赖此意思。特别地，一个模块内部的名字不能影响到其它模块，或者被影响 – 一个模块的外部行为必须独立于它局部标识符的名字的选择。</p>

<p>To make a modular program, it is often necessary to think of a
computational process as having state. In such cases, if the state can be
naturally divided into independent parts, an important decomposition may be
the division of the program into pieces which separately deal with the
parts of the state.</p>

<p>为了编写模块化程序，经常有必要想起带状态的计算过程。在这些案例中，如果状态能被自然地分解为独立的部分，一种重要的分解可能是将程序划分为独立处理状态各部分的片段。</p>

<p>We will discuss various stylistic techniques for achieving
modularity. One would expect these techniques to complement each other.
We will instead discover that they can come into conflict. Pushing one to
an extreme in a language can seriously compromise others.</p>

<p>我们将讨论达到模块化的不同的风格化技术。有人会期待这些技术会相互补充。相反，我们将发现它们会产生冲突。在语言中，将一个推到极致能严重地损害其它的。</p>

<h3 id="lisp">类LISP语言</h3>
<p>LISP-like Languages</p>

<p>Of the hundreds or thousands of computer languages which have been
invented, there is one particular family of languages whose common ancestor
was the original LISP, developed by McCarthy and others in the late 1950’s.
[LISP History] These languages are generally characterized by in simple,
fully parenthesized (“Cambridge Polish”) syntax; the ability to manipulate
general, linked—list data structures; a standard representation for
programs of the language in terms of these structures; and an interactive
programming system based on an interpreter for the standard representation.
Examples of such languages are LISP 1.5 [LISP 1.5M], MacLISP [Moon],
InterLISP [Teitelman], CONNIVER [HcDermott and Sussman], QA4 [Rulifson],
PLASMA [Smith and Hewitt] [Hewitt and Smith], and SCHEME [SCHEME] [Revised
Report]. We will call this family the LISP—like languages.</p>

<p>在成百上千被发明的计算机语言中，有特殊的一个语言家族，其祖先是原始的LISP，由McCarthy和其他人在1950年代后期开发出来。这些语言的特征是：通常都与简单、封闭括号的语法(Cambridge Polish)；能够操作普遍的、链式列表数据结构；以这些结构的方式对程序的标准表示；有基于标准表示解释器的一个交互式编程系统。这样语言的例子是LISP 1.5, MacLISP, InterLISP, CONNIVER, QA4, PLASMA和Scheme。我们称这个家族为类LISP语言。</p>

<p>The various members of this family differ in some interesting and
often subtle ways. These differences have a profound impact on the styles
of programming each may encourage or support. We will explore some of
these differences by examining a series of small (“toy”) evaluators which
exhibit these differences without the clutter of “extra features” provided
in real, production versions of LISP-like language systems.</p>

<p>这个家族的各种成员的不同之处，在一些有趣和经常微妙的地方。这些差别对鼓励或支持每种编程风格有深刻的影响。我们将探索这些差别的一些，通过检视一系列小(玩具)求值器，这些求值器展示了这些差别，而没有被类LISP语言系统的真实、生产性版本所提供的“附加特性”搞乱。</p>

<p>The series of evaluators to be considered partially constitute a
reconstruction of what we believe to be the paths along which the family
evolved. These paths can be explained after the fact by viewing the historical changes to the language as being guided by the requirements of
various aspects of modularity.</p>

<p>这些被考虑的求值器系列，部分构成了一个再现，我们认为是此语言家族进化所沿着的路径。这些路径可以被这样的事实来解释，即看到对语言历史上所做的改变，是被模块化各种方面的需求推动引导着。</p>

<h4 id="section-4">文章的结构</h4>
<p>Structure of the Paper</p>

<p>Our discussion is divided into several parts, which form a linear
progression. In addition, there are numerous large digressions which
explore interesting side developments. These digressions are placed at the
end as notes, cross-referenced to and from the text.</p>

<p>我们的讨论分为几个部分，它们形成线性的推进。此外，有很多大的题外话，去探索有趣的侧面开发。这些题外话放在最后作为注解，被交叉引用到或来自正文。</p>

<p>We exhibit a large number of LISP interpreters whose code differs
from one to another in small ways (though their behavior differs greatly!).
In order to avoid writing identical pieces of code over and over, each
figure exhibits only routines which differ, and also contains cross-
references to preceding figures from which missing routines for that figure
are to be drawn.</p>

<p>我们展示很多LISP解释器，它们的代码相互间有很小的差别（但是它们的行为差别巨大）。为了避免到处写出相同的片段，每个图仅展示不同的例程，也包含一个交叉引用到前面的图，在那里图中缺失的例程被画出来。</p>

<p>Part Zero introduces the restricted dialect of the LISP language in
which most of our examples are written. It also discusses the basic
structure of an interpreter, and exhibits a meta-circular interpreter for
the language.</p>

<p>第零部分介绍了LISP语言中受限制的方言，我们大多数的例子都它写成。这部分也讨论解释器的基本结构，并展示了语言的一个元-循环解释器。</p>

<p>Part One introduces procedural data as an abstraction mechanism,
and considers its impact on variable scoping disciplines in the language.
We are forced through a series of such disciplines as unexpected
interactions are uncovered and fixed. Interpreters are exhibited for
dynamic scoping and lexical scoping.</p>

<p>第一部分介绍作为一个抽象机制的过程数据，并考虑它在语言的变量范围规则中的影响。随着未曾预期的交互性被发现和修正，我们被迫使穿越一些列这样的规则。为了动态范围和词法范围而展示了解释器。</p>

<p>Part Two considers the problems associated with the decomposition of state. Side effects are introduced as a mechanism for effecting such decompositions. We find that the notion of side effect is inextricably wound up with the notion of identity. Dynamic scoping is retrospectively viewed as a restricted kind of side effect.</p>

<p>第三部分考虑与分解状态相伴的问题。副作用被引入，作为影响如此分解的一个机制。我们发现，副作用的记号无法摆脱地与相等性的记号缠绕在一起。回想起来，动态范围被看作一种受限的副作用类别。</p>

<p>With this we summarize and conclude with many tantalizing questions yet unanswered.</p>

<p>带着这些，我们总结并给出结论，很多扰人的问题尚未有答案。</p>

<p>In Part Three (in a separate paper) we will find that the
introduction of side effects forces the issue of the order of evaluation of
expressions. We will contrast call-by-name and its variants with call—by-
value, and discuss how these control disciplines arise as a consequence of
different models of packaging. In particular, call-by-name arises
naturally from the syntactic nature of the Algol 60 copy rule. As before,
many little interpreters for these disciplines will be exhibited. </p>

<p>在第三部分(一个单独的论文)，我们将发现，副作用的引入将催生表达式求值的次序问题。我们将通过名称调用(call-by-name)及它的变体，与通过值调用，进行比较。然后讨论这些控制记录如何作为不同包建模的结果而产生。特别地，按名称调用自然地从Algol 60拷贝机制的语法属性中自然产生。正如以前，这些规则的很多小解释器也被展示出来。</p>

<p>In Part Four we will be led to generalize the notion of a syntactic package. We will discuss meta-procedures, which deal with the representations of procedures. The distinction between a procedure and its representation will be more carefully considered. Macro processors, algebraic simplifiers, and compilers will be considered as meta-procedures. Various interpreters, compilers, and simplifiers will be exhibited.</p>

<p>在第四部分，我们将导向推广语法包的记号。我们将讨论元过程，这处理过程的表示。过程及其表示的区分将被更加仔细地考虑。宏处理器，代数化简器和编译器，将被看做元过程。不同的解释器、编译器和化简器将被展示。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/haskell-resources/">Haskell Resources</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-07T15:31:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="books">Books</h2>

<ul>
  <li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></li>
  <li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
  <li></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/implementing-arithmetic-in-lisp/">在Lisp中实现算术</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-27T11:51:18+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:51 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上一篇文章中，Paul Graham介绍了Lisp的基础。通过7个原语操作，就可定义一些基本函数，进而实现对表达式求值函数eval.。本文将探索，基于这些Lisp的基本语言素材，如何实现算术。</p>

<p>整个背后的想法是，只要我们定义了语言的原语操作，就可推演出整个语言的体系。数字，本质上也是符号。而算术，则是对符号的操作。</p>

<h3 id="section">预备函数</h3>

<p>我们需要增加几个函数，作为预备：</p>

<p>(neq. x y) 判断x和y是否不相等。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; (defun neq. (x y)
</span><span class="line">    (not. (eq x y))) </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(member. x y)判断x是否是列表y的元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">member.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="ss">&#39;t</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">member.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(reverse. x) 反转整个列表x</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(findsub. x y) 在y中找元素x，如果找到，返回包含x在内的尾部。找不到，返回空。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">findsub.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(longer. x y) 比较两个列表x和y，哪个更长，即元素更多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">longer.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">()))</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;LT</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">longer.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">实现整数加法</h3>

<p>我们先实现整数的加法，而且先不考虑负数的情况。我们用列表表示数字，例如1234，表示为(1 2 3 4)。
高位在左，低位在右，以便符合人的阅读习惯。</p>

<p>我们先定义函数(basecomp. x y)，比较单个数字符号的大小。思路是比较它们在符号列表(0 1 2 3 4 5 6 7 8 9)中的位置，哪个靠前，哪个小。具体的算法，是处理相等的情况，直接返回相等。然后取得含有y的符号列表的尾部，如果包含x，则x要靠后，否则靠前。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">basecomp.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">         <span class="p">((</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)))</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;LT</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;3</span> <span class="ss">&#39;4</span><span class="p">)</span>
</span><span class="line"><span class="nv">LT</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;8</span><span class="p">)</span>
</span><span class="line"><span class="nv">EQ</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;9</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="nv">GT</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后，我们可以定义单个数字的加法，就如同小学时学的加法表一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">baseadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;GT</span><span class="p">)</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="ss">&#39;0</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">2</span> <span class="p">((</span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">3</span> <span class="p">((</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">4</span> <span class="p">((</span><span class="mi">4</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">5</span> <span class="p">((</span><span class="mi">5</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">6</span> <span class="p">((</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">7</span> <span class="p">((</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">8</span> <span class="p">((</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">7</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">9</span> <span class="p">((</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">8</span><span class="p">))))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>先按照x, 再按y，查找加法表，返回结果。如果有进位，就返回列表，比如(1 5)。由于加法表，要求y&gt;=x。所以用到比较函数basecomp.，如果x大于y，则将次序调换在调用baseadd.。如果不要求x和y的次序，亦可，但加法表要多写一倍，这是冗余而无趣的工作。</p>

<p>试试我们的一位数加法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;2</span> <span class="ss">&#39;3</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;5</span> <span class="ss">&#39;0</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>万事俱备了，可以写最终的加法函数。但别急，还有点小的问题。我们知道多位数的加法，是先算低位再算高位。但是，我们的数字用列表表示时，是高位在左，低位在右。用lisp的car, cdr要先取出最右边(尾部)的元素很不方便。一个解决办法是，先将列表反转过来计算，计算完毕后，再反转回来。</p>

<p>这个就是整数加法的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">y</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>反转后列表的加法函数，intaddreverse. 如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))</span>
</span><span class="line">                   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                            <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看看效果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">应用</h3>

<p>利用上面的加法函数，我们可以写一个计算列表长度的函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">length.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">length.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">k</span> <span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>(1 4)就是14。</p>

<h3 id="section-3">回顾</h3>

<p>上面通过简单的符号计算规则，就实现了整数的加法运算，让我们更进一步理解，一切计算皆是符号的本质。当然，基本规则的定义稍有冗余。上面定义了自然数的大小和加法表。更简洁的定义，只需包含三个部分：</p>

<ul>
  <li>自然数 $a_0$ = 1</li>
  <li>$a_n$ = $a_{n-1}$ + 1</li>
  <li>十进制的进位和表示法</li>
</ul>

<p>循着类似的思路，减法运算也可定义出来。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/the-roots-of-lisp/">LISP的根本</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-14T14:30:54+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">前言</h3>
<p>《黑客与画家》的作者Paul Graham极力推崇Lisp，并使用Lisp获得了巨大的商业成功。他也写了一篇<a href="http://ep.yimg.com/ty/cdn/paulgraham/jmc.ps">《The roots of Lisp》</a>(postscript文件)来介绍Lisp。本文是其文章内容的学习和理解，再加上Lisp Manual 1.5的内容。</p>

<p><br /></p>
<hr />

<p><br /></p>

<p>Lisp的伟大之处，在于John McCarthy采用了类似于欧氏几何的公理化体系。欧氏几何通过几个简单的公理，借助逻辑推演，构建了整个几何体系。其结构之整洁、推理之严密，有一种深深的数学之美和逻辑的力量。MaCarthy在1960年的文章中展示了，如何通过少数几个简单的运算符和函数定义的记号，就可以构建整个编程语言。这个语言被称为Lisp，即列表处理(List Processing的意思)。而列表是表达数据和代码的一种简单数据结构。</p>

<p>值得去理解，McCarthy所发现的，不仅仅是计算机历史上的地标，而且是在今天我们的时代里，编程发展所趋向成为的一个模型。迄今为止，存在两个真正干净、一致的编程模型：C模型和Lisp模型。这两个是平地上的高点，在其之间是沼泽地带。随着计算机变得更为强大，正在开发的新语言正稳定地向Lisp模型靠拢。在过去20年中新编程语言的流行配方是采用C计算模型，然后从Lisp模型中抓取一点诸如运行时类型、垃圾回收等零碎的东西，加到里面。</p>

<p>本文将解释McCarthy发现的最简单的术语。要点不是仅仅学会一个40年前就有人弄明白的有趣的理论结果，而是去看看语言朝哪方面去发展。事实上，关于Lisp不寻常的事 - Lisp决定性的品质，是它是用自身写成的。为了理解McCarthy想说明的意思，我们将追溯他的脚步，将他的数学符号转译为可运行的Common Lisp代码。</p>

<h3 id="symbolic-expressions">符号性表达式(Symbolic Expressions)</h3>

<p><em>注：本节是由译者添附，内容来自<a href="http://en.wikipedia.org/wiki/S-expression">http://en.wikipedia.org/wiki/S-expression</a>，先交代基本概念，便于理解</em></p>

<p>符号表达式，即S表达式中最基本的类型，是原子。</p>

<p><strong>原子</strong>符号，是由字母和数字组成的字符串。其首字符必须字母。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">a</span>
</span><span class="line"><span class="nv">abc</span>
</span><span class="line"><span class="nv">a123</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一个S表达式，可以递归地定义为：</p>

<ol>
  <li>一个原子</li>
  <li>形式为(X . Y)的表达式，其中X和Y都是S表达式</li>
</ol>

<p>例如： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">foo</span> <span class="o">.</span> <span class="p">(</span><span class="nv">bar</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更方便的是将列表写成不带点记号的任意长度的列表：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它等价于 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">e</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有过编程经验的朋友，会觉得List貌似和数组类似。其实不然。List的长度不固定，它是一种递归结构。在计算机内部的List结构是：</p>

<p><img src="http://hack.the-lifematrix.net/images/lisp/list_structure.png" alt="" /></p>

<p><em>注：此图来自Lisp Manual 1.5</em></p>

<h3 id="seven-primitive-operators">7个原语操作符(Seven Primitive Operators)</h3>

<p>在算术中，表达式1+1的值是2。合法的Lisp表达式也有值。如果一个表达式$e$有个值$v$，我们说$e$返回$v$。</p>

<p>如果一个表达式是一个列表，我们称其第一个元素为操作符，剩下的为参数。我们将定义7个原语操作符：quote, atom, eq, car, cdr, cons 和 cond。</p>

<p>*注：如下代码均在GNU CLISP 2.49下调试通过，CLISP内部会将符号转换为大写，所以输出时会是大写的符号。这和The roots of Lisp原文的代码输出，略有不同 *</p>

<p>1.(quote A)返回$A$, 为了可读性，我们将(quote A)缩写为’A</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="ss">&#39;a</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2.(atom x)返回原子t，如果x是原子，否则返回空列表。在Lisp中我们用atom t代表布尔值的真值，用NIL或空列表代表假值。二者是一回事。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="err">􏰛</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">()</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们有了一个运算符，它的参数会被求值。我们可以看看quote针对什么。一个未被引用的列表，作为参数传给atom这样的运算符，其代码是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>通过引用一个列表，我们可以避免它被求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这对应我们在英语中使用引用的方式。Cambridge是麻省的一个镇，有9万人。而“Cambridge”是有9个字母的单词。</p>

<p>引用是可能看似陌生的概念，因为很少有其它语言具有任何类似的东西。它与Lisp最引人注目的特性联系在一起：<strong>代码和数据都由相同的数据结构产生出来，而引用操作符是我们区分它们的方式</strong>。</p>

<p>3.(eq x y)返回t，如果x, y的值是相同的原子，或者二者是空列表。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.(car x)期待x的值是一个列表，并返回它的第一个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="nv">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.(cdr x)期待x的值是一个列表，并返回它除过第一个元素之外的所有部分。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6.(cons x y) 期待y的值是一个列表，返回一个列表，其第一个元素是x的值，而后是y的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>7.(cond ($p_1$ $e_1$) … ($p_n$ $e_n$))的求值如下：表达式$p$会按顺序求值，直到遇到一个为真。当这个表达式找到后，对应的表达式$e$的值，就会被返回作为整个cond表达式的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="ss">&#39;first</span><span class="p">)</span>
</span><span class="line">            <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;second</span><span class="p">))</span>
</span><span class="line"><span class="nv">SECOND</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这七个操作符原语的后5个，当对这个操作符开始的表达式求值时，参数总是会被求值。我们称这样的操作符，为<strong>函数</strong>。</p>

<h3 id="denoting-function">2. 函数的表示(denoting function)</h3>

<p>接着我们来定义一个记号来描述函数。一个函数被表达为 (lambda ($p_1$ … $p_n$) $e$), 这里$p_1$ … $p_n$ 是原子(被称为参数），而$e$是一个表达式。一个这样的表达式，</p>

<p>((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>被称为函数调用。对其求值的方法如下：先对每个表达式$a_i$求值，然后再对$e$求值。在对$e$求值时，任何出现$p_i$的值，都是最近一次函数调用中对应$a_i$的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">)))</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">Z</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果一个表达式：
($f$ $a_1$ … $a_n$)
其第一个元素$f$不是一个操作原语，而$f$的值是一个函数(lambda ($p_1$ … $p_2$) $e$)，那么表达式的值就是：((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>换言之，在表达式中参数可与当操作符用，如同函数参数一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span>  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class="line"><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有另外一种标记函数的方式，使得函数可以引用它自己，这给我们很方便的途径去定义递归函数。
记号：
(label $f$ (lambda ($p_1$ … $p_2$) $e$))
标记了行为如同(lambda ($p_1$ … $p_2$) $e)的函数。 </p>

<p>我们进一步将 f = (label $f$ (lambda ($p_1$ … $p_2$) $e$))缩写为：
(defun f ($p_1$ … $p_2$) $e$)</p>

<p>假设我们想定义一个函数(subst $x$ $y$ $z$)，它接收一个表达式$x$, 一个原子$y$, 一个列表$z$，然后返回类似于$z$的列表，但是$z$中每个$y$的实例都会被替换成$x$。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="ss">&#39;m</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么这个函数可以这样通过递归定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">subst-new</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="o">&#39;</span><span class="p">())</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">)))</span>
</span><span class="line">      <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">))</span>
</span><span class="line">               <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>刚好我们在这里可以看到如何在cond表达式中得到一个子句。第一个元素是t的子句，总会成功。注意’t和t等价。因此</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>等价于我们可能在其它语言中看到的语法：
if $x$ then $y$ else $z$</p>

<h3 id="section-1">一些函数</h3>

<p>既然我们有了一个表达函数的方式，我们将用原语操作符的术语来定义一些新的函数。首先，将方便地介绍一系模式的缩写。我们使用c$x$r, 其中$x$是a或d的序列，作为对应car和cdr序列的缩写。因此，例如(cadr $e$)是 (car (cdr $e$))的缩写，它返回$e$的第二个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cadr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">caddr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="nv">E</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdar</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>而且，我们使用(list $e_1$ … $e_n$)代表(cons $e_1$ … (cons $e_n$ ‘()) …)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;d</span> <span class="o">&#39;</span><span class="p">()))))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们现在来定义一些新函数。我们在函数名的尾部加一个句号，这便于和现存的原语函数区分开，也不会和Common Lisp现有的函数冲突。</p>

<ol>
  <li>(null. $x$)测试其参数是否为空列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">null.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">()))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(and. $x$ $y$) 返回真t，如果其两个参数都为真，否则返回空列表’()。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">and.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="no">t</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(not. x) 返回真t, 如果它的参数是空列表，否则返回</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">not.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="no">t</span><span class="p">)))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(concat. x y)收到两个列表，将它们联接起来。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">concat.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>*注：原文此函数命名为append，觉得concat 更适合一些 *</p>

<p>*注：这里用到了前面定义的函数null. *</p>

<ol>
  <li>(pair. $x$ $y$) 收到两个等长的列表，然后返回一个列表，每个元素是由$x$、$y$对应元素构成的列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">pair.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span>
</span><span class="line">          <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="nv">pair.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">e</span> <span class="nv">g</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span> <span class="nv">f</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">E</span> <span class="nv">F</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(assoc. x y) 收到一个原子$x$和一个由pair.生成的列表形式，然后返回列表$y$中其第一个元素是$x$的列表的第二个元素。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">assoc.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">           <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">           <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line"> <span class="nb">&gt;</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">g</span><span class="p">)))</span>
</span><span class="line"><span class="nv">F</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">惊喜</h3>

<p>我们能够定义函数，完成级联列表、用一个表达式替换另一个等等。一个优雅的记号，但这又能怎么样呢？现在惊喜来了。我们也能证明，可以写一个函数作为语言自己的解释器：一个将任意Lisp表达式作为参数，并返回其值，见下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">eval.</span> <span class="p">(</span><span class="nv">e</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">e</span> <span class="no">t</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">                      <span class="p">((</span><span class="nb">eq</span> <span class="nv">e</span> <span class="o">&#39;</span><span class="p">())</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">e</span> <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">       <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;atom</span><span class="p">)</span> <span class="p">(</span><span class="nb">atom</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;eq</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                               <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;car</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cdr</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cons</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                                   <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cond</span><span class="p">)</span> <span class="p">(</span><span class="nv">evcon.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                          <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">                    <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;label</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">))</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;lambda</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nv">pair.</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nv">evlis.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">                       <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="nv">e</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">evcon.</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">evcon.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">evlis.</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">m</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                <span class="p">(</span><span class="nv">evlis.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>注：原文的代码存在小bug，这里修正了。一是对布尔常量的求值，要返回布尔量，不再从环境a中查找；二是, label 表达式的解析。</li>
</ul>

<p>这个函数eval.比我们之前看到的任何函数都要长。让我们看看它是如何工作的。</p>

<p>这个函数有两个参数：e, 将要求值的表达式，以及a, 原子所给定值的列表，在函数调用中以参数表现出来。这个列表被称之为<em>“环境”</em>(environment)，是由pair.创建的形式。eval.的骨架是由带有4个子句的cond表达式。我们如何对表达式求值取决于它的类别。第一个子句处理原子。如果e是一个原子，我们在环境中查找它的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line"><span class="nv">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>eval.的第二个子句是一个cond, 处理格式为($a$ …)的表达式，而$a$是原子。这些包含所有对原语操作符的使用，每个子句处理其中一个：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>所有这些（除过 quote)调用eval. 去查找参数的值。</p>

<p>最后两个子句更为复杂，为了给cond表达式求值，我们调用一个附属函数evcon., 它递归式地遍历子句，寻找其第一个元素返回t的子句。当它找到时，就返回其第二个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;atom</span><span class="p">)</span>
</span><span class="line">                <span class="p">(</span><span class="ss">&#39;t</span> <span class="ss">&#39;list</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
</span><span class="line"><span class="nv">LIST</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>eval.第二个子句的最后一部分，处理作为函数的调用。它通过将原子替换为它的值，并对得到的表达式求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>定价于</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后返回(A B C)。</p>

<p>eval.的最后两个子句处理函数调用，其第一个元素是实际的 lambda或label表达式。对label表达式的求值是，将函数名和函数自身的列表压入环境中，然后对一个表达式调用eval.求值，其中用内部的lambda表达式替换label表达式。即：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">label</span> <span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                                    <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>变成</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                             <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>原文的代码是将label表达式，替换为如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                             <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">firstatom</span>
</span><span class="line">            <span class="p">(</span><span class="nv">label</span> <span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                               <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                                     <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样当函数递归调用时，每次都要解析label，导致不断有label定义添加到环境中。这是小bug，本文代码做了修正。</p>

<p>对形式为 ((lambda ($p_1$ … $p_n$) $e$) $a_1$ … $a_n$)的表达式取值，首先调用evlis., 来获得参数($a_1$ … $a_n$)的一组值($v_1$ … $v_n$), 然后将($p_1$ $v_1$) … ($p_n$ $v_n$)添加到前面的环境中，然后对$e$求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">           <span class="ss">&#39;a</span>
</span><span class="line">           <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>变成</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后返回(A C D)。</p>

<h3 id="section-3">尾声</h3>

<p>现在我们已经理解了eval怎么工作的，让我们回退一下考虑这意味着什么。我们现在所拥有的是非同寻常的优雅的计算模型。仅仅使用quote, atom, eq, car, cdr, cons 和 cond, 我们定义了一个函数eval., 它事实上实现了我们的语言，然后使用这些，我们可以定义任何想添加的函数。</p>

<p>当然已经有非常著名的计算模型，图灵机。但是图灵机读起来缺少启迪性。如果你想要一个描述算法的语言，你可能需要更为抽象一点的语言。这就是McCarthy定义Lisp的目的之一。</p>

<p>他在1960年定义的语言少了很多东西。没有副作用、没有顺序执行（不管怎样，它只有和副作用一起才有用）、没有使用的数字、没有动态范围。但是，这些局限可以用令人吃惊的少量代码来改进。Steele和Sussman在著名的论文“解释器的艺术”(The Art of the Interpreter)中，展示如何做这些。</p>

<p>如果你理解McCarthy的eval, 你理解到的不仅仅是编程语言历史上的一个阶梯。这些创意仍然是今天Lisp的语义核心。因此学习McCarthy的原文，在某种程度上，向我们展示了Lisp是什么。它不是McCarthy如此设计为他所发现的东西。它本质上，不是为了人工智能(AI)，快速搭建原型，任何其它这个层面的任务。它是当你试图公理化计算时，你得到的东西。</p>

<p>伴随着时间，中等程度的语言，即由中等程度程序员使用的语言，已经一贯地向Lisp方向去成长。因此，通过理解eval, 你正在理解未来可能的主要计算模型是什么。</p>

<h3 id="section-4">注释</h3>

<p>在将McCarthy的记号转化为可执行代码时，尽可能少做改动。我尝试让代码更加可读，但我试图保持原文的味道。</p>

<p>在McCarthy的论文中，“假”用f表示，而非空列表。我使用()来表示假，这样示例在Common Lisp上能很好运行。没有代码依赖“假”，也碰巧依赖空列表。空(nothing)一贯被cons到predict返回的结果。</p>

<p>我跳过了从带点的对(pair)中构造列表，因为你并不需要靠它们去理解eval。我也没提到apply，但apply(非常早期的形式，其目的是引用参数)正是McCarthy在1960年称之的普遍函数(universal function)；而eval只是个apply调用的子例程，去完成所有工作。</p>

<p>我定义了list和c$x$rs, 作为缩写，因为McCarthy也这么做。事实上，c$x$rs可以作为通常函数来定义。如果我们修改eval，list也可以这么做（定义为通常函数）。正如我们可以容易地让函数接受任意数目的函数。</p>

<p>McCarthy只用了5个原语操作符。他使用了cond和quote，但可能把它们作为元语言的一部分。他同样也没定义逻辑运算符and和not，但这不是个问题，因为有足够的版本将其定义为函数。</p>

<p>在eval的定义中，我们调用了象pair.和assoc这样的函数，但是调用用原语操作符定义的任何函数，都可以替代为对eval.的调用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">assoc.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">label</span> <span class="nv">assoc.</span>
</span><span class="line">                  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">                    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">                          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span>
</span><span class="line">           <span class="nv">a</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;e</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在McCarthy的代码中有个小bug。第16行是(等价于) (evlis. (cdr e) a)， 而非(cdr e)，这将使得对一个命名函数的调用中参数被求值两遍。这暗示，当论文提交时，eval的这一描述还未曾在IBM 704机器语言中实现过。这也说明，对于任何长度的代码，如果没有运行过，确定其正确性是很困难的。</p>

<p>我在McCarthy的代码中还遇到另一个问题。在给出eval的定义后，他继续给出了高阶函数的例子，即把其它函数作为参数的函数。他定义maplist:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">label</span> <span class="nb">maplist</span>
</span><span class="line">         <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">f</span><span class="p">)</span>
</span><span class="line">           <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                 <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">f</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">maplist</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">f</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后用它来写一个简单的函数diff，做符号微分。但是diff向maplist传递了一个以x作为参数的函数，然后对它的引用被maplist中的参数x捕获。</p>

<ul>
  <li>作者注：目前Lisp程序员使用mapcar而非maplist。这个例子也澄清了一个神话：为什么maplist会在Common Lisp中。它是期初的映射函数，而mapcar是后来添加的。*</li>
</ul>

<p>这是动态范围之危险的一个极富说服力的证据，因为它，恰恰Lisp高阶函数的第一个例子就被搞坏了。有可能McCarthy在1960年并未完全意识到动态范围的含义。动态范围在Lisp的实现中保留了令人惊讶的很长的时间，直到Sussman和Steele在1975年开发了Scheme。语法范围没有将eval的实现搞得太复杂，但是更难以写出编译器。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/a-conversation-with-alan-kay/">译文：与艾伦·凯的对话</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-30T12:14:50+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="smalltalk">和Smalltalk创造者一起畅谈</h3>

<p>原标题： A Conversation with Alan Kay，Big talk with the creator of Smalltalk—and much more.</p>

<p>原文：<a href="http://queue.acm.org/detail.cfm?id=1039523">http://queue.acm.org/detail.cfm?id=1039523</a>, <a href="http://dl.acm.org/ft_gateway.cfm?id=1039523&amp;ftid=297449&amp;dwn=1"><img src="http://hack.the-lifematrix.net/images/common/icon_pdf.png" alt="" /></a></p>

<p>ACM相关链接：<a href="http://queue.acm.org/listing.cfm? qc_type=interviews&amp;page_title=Interviews">访谈</a>,  <a href="http://queue.acm.org/listing.cfm?item_topic=Programming%20Languages&amp;qc_type=theme_list&amp;filter=Programming%20Languages&amp;page_title=Programming%20Languages&amp;order=desc">编程语言</a></p>

<hr />

<p>When you want to gain a historical perspective on personal computing and programming languages, why not turn to one of the industry’s preeminent pioneers? That would be Alan Kay, winner of last year’s Turing Award for leading the team that invented Smalltalk, as well as for his fundamental contributions to personal computing.</p>

<p>如你想获得有关个人计算和编程语言的历史性观点，为什么不问问业界的某位先驱呢？这可能就是[Alan Kay], 他因为领导团队发明Smalltalk, 以及他对个人计算的根本性贡献，荣获去年的图灵奖。</p>

<p>Kay was one of the founders of the Xerox Palo Alto Research Center (PARC), where he led one of several groups that together developed modern workstations (and the forerunners of the Macintosh), Smalltalk, the overlapping window interface, desktop publishing, the Ethernet, laser printing, and network client-servers.</p>

<p>Kay是施乐帕洛阿尔托研究中心(Xerox Palo Alto Research Center, PARC)的创始人之一，他在那里领导了几个小组中的一个，这些组共同开发了现代工作站(Machintosh的前身)，Smalltalk，重叠式窗口界面，桌面出版，以太网，激光打印，以及网络的客户-服务器。</p>

<p>Prior to his work at PARC, Kay earned a Ph.D. in 1969 from the University of Utah, where he designed a graphical object-oriented personal computer and was a member of the research team that developed pioneering 3-D graphics work for the Advanced Research Projects Agency (ARPA). Kay was also a “slight participant” in the original design of the ARPANet, which later became the Internet. He holds undergraduate degrees in mathematics and molecular biology from the University of Colorado. After leaving Xerox PARC, Kay went on to become chief scientist of Atari, a Fellow of Apple Computer, and vice president of research and development at The Walt Disney Company.</p>

<p>在他工作于PARC之前，Kay于1969年从犹他州立大学获得博士学位。在那里，他设计了一个图形化的面向对象的个人电脑，同时他也是一个研究小组的成员。这个组为高级研究项目管理局(ARPA)开发开创性的3-D图形装置。Kay也是ARPANet原始设计的“少量参与者“”，其后来演变成了互联网。他在科罗拉多州立大学获得数学和分子生物学的研究生学位。离开施乐PARC之后，Kay继续成为Atari的首席科学家，这是苹果电脑的同类，他也是沃特迪斯尼公司的研发副总裁。</p>

<p>Today he is Senior Fellow at Hewlett-Packard Labs and president of Viewpoints Research Institute, a nonprofit organization whose goal is to change how children are educated by creating a sample curriculum with supporting media for teaching math and science. This curriculum will use Squeak as its media, and will be highly interactive and constructive. Kay’s deep interests in children and education have been the catalysts for many of his ideas over the years.</p>

<p>今天，他是惠普公司的高等院士以及Viewpoint研究所的总裁，这是一个非盈利组织，其目标是通过创造带有支持媒体的样本课程来教授数学和科学，从而改变儿童接受教育的方式。这个课程将使用Squeak语言作为媒介，将具有高度交互性和建设性。Kay对儿童和教育的深度兴趣，是他多年来很多创意的催化剂。</p>

<p>In addition to winning the Turing Award, Kay recently received the Draper Prize from the National Academy of Engineering and the Kyoto Prize in Advanced Technology, awarded every four years by the Inamori Foundation.</p>

<p>除了图灵奖，Kay最近从美国国家工程院获得了Draper奖，以及高等技术的Kyoto奖(京都赏)，此奖由Inamori基金会每4年颁发一次。</p>

<p>Guiding our tour through personal computing history with Kay is Stuart Feldman of IBM Research, where he is vice president and on-demand business transformation area strategist. Since joining IBM in 1995, Feldman has also served as vice president for Internet technology and was head of computer science in the research division.</p>

<p>带领我们和Kay一起游览个人计算历史的是IBM研究院的Stuart Feldman，他是研究院的副总裁以及随需应变(on-demand)业务转化领域的战略家。Feldman也曾经作为Internet技术的副总裁，是研究事业部中计算机科学的领导人。</p>

<p>Feldman also spent 11 years at Bellcore, where he held several research management positions in software engineering and computing systems, and 10 years at Bell Labs, where he was a computer science researcher. Feldman was a member of the original Unix team and is best known as the creator of the Make configuration management system and as the author of the first Fortran-77 compiler. He has a Ph.D. in applied mathematics from the Massachusetts Institute of Technology. He is a member of the Queue Advisory Board.</p>

<p>Feldman也在Bellcore(Bell Communications Research)待了11年，在那里他做过多个软件工程和计算系统的研究管理职位，并在Bell实验室待了10年，那里他作为计算机科学研究员。Feldman是原始Unix团队的成员，以Make配置管理系统的创建者和第一个Fortran-77编译器的作者而著称。他从麻省理工学院取得应用数学的博士学位。他是Queue顾问委员会的成员。</p>

<hr />

<p><strong>STUART FELDMAN</strong> One of the topics that some of the younger people on our Queue editorial board keep asking about is the history of programming languages. The Queue board has a bimodal generation distribution, and those members who are in their 20s or 30s seem genuinely confused about where programming languages might actually come from. It’s my observation that we have one big language and one smaller language every decade—that appears to be all the field can afford. Smalltalk is one of those five- or 10-year events.</p>

<p><strong>STUART FELDMAN</strong> 一些更年轻的人在我们Queue编委会上不断问到的一个主题是编程语言的历史。Queue委员会的年龄分布是双峰模式，那些20或30岁的成员普遍对编程语言到底从何而来感到困惑。我的观察是，每十年就有一个主流语言(one big language)和一个较小众的语言，这看起来所有的领域（对编程语言的需要）都能对付。Smalltalk是那些5年或10年的事件之一。</p>

<p><strong>ALAN KAY</strong> In the late 1960s, Jean Sammet was able to track down and chronicle about 3,000 programming languages that were extant then. When things were simpler in a sense—but theoretically harder because the machines were slower, smaller, didn’t have hard drives most of the time, and had bad tools—people nonetheless rolled their own operating systems and programming languages whenever they felt like it. So there are zillions of them around.</p>

<p><strong>ALAN KAY</strong> 在1960年代晚期，Jean Sammet能追溯和记录当时存在大约3000种编程语言。当事情在某种意义上变简单了，但在理论上却更困难了。因为机器更慢更小，多数时没有硬盘驱动器，工具很糟糕。尽管如此，人们运行着他们自己的操作系统和编程语言，只要他们喜欢。因此，到处都有繁多的编程语言和操作系统。</p>

<p>For a <em>Scientific American</em> article 20 years ago, I came up with a facetious sunspot theory, just noting that there’s a major language or two every 101⁄2 years, and in between those periods are what you might call hybrid languages. These could be looked at as either an improvement on the old thing or almost a new thing. I chronicled Fortran as an improvement on an old thing or almost a new thing, and Algol and Lisp were the new thing.</p>

<p>对《科学美国人》20年前的一篇文章，我想出一个俏皮的支持理论，每隔10年半，将有一到两个主要的语言，而在这个期间的语言，你可称为混合语言。这些可看做对旧事物的改进，或者几乎是全新的事物。我将Fortran编目为旧事物的改进或者几乎一个新事物，而Algol和Lisp是新事物。</p>

<p>Then there was Simula, which the designers thought of as an extension of Algol. It was basically a preprocessor to Algol the way C++ was a preprocessor for C. It was a great concept and I was lucky enough to see it as almost a new thing. Smalltalk and Prolog happened in the early 1970s. The predecessor of Prolog was a wonderful thing that Carl Hewitt did in the late 1960s called Planner.</p>

<p>然后是Simula, 设计者们把它看做Algol的扩展。它根本上是Algol的一个预处理器，如同C++对于C是预处理器的方式。这是个伟大的概念，我足够幸运将它看做几乎全新的事物。Smalltalk和Prolog出现在1970年代早期。Prolog的预处理器非常棒，由Carl Hewitt在1960年代晚期完成，叫做Planner。</p>

<p>Perhaps it was commercialization in the 1980s that killed off the next expected new thing. Our plan and our hope was that the next generation of kids would come along and do something better than Smalltalk around 1984 or so. We all thought that the next level of programming language would be much more strategic and even policy-oriented and would have much more knowledge about what it was trying to do. But a variety of different things conspired together, and that next generation actually didn’t show up. One could actually argue—as I sometimes do—that the success of commercial personal computing and operating systems has actually led to a considerable retrogression in many, many respects.</p>

<p>大概是1980年代的商业化扼杀了期待的下一个新事物。我们的计划和希望是下一代的年轻人能一起来干，做一些比1984年前后Smalltalk更好的东西，等等。我们都认为，编程语言的下一层次本应更具战略性，甚至是面向策略的，本应包含更多所尝试去做之事的知识。但是，很多不同的事情凑在一起，让下一代编程语言事实上没有显现出来。事实上有人会认为 - 亦如我偶尔做的 - 商业化个人计算和操作系统的成功实际上导致了在很多很多方面的显著退步。</p>

<p>You could think of it as putting a low-pass filter on some of the good ideas from the ’60s and ’70s, as computing spread out much, much faster than educating unsophisticated people can happen. In the last 25 years or so, we actually got something like a pop culture, similar to what happened when television came on the scene and some of its inventors thought it would be a way of getting Shakespeare to the masses. But they forgot that you have to be more sophisticated and have more perspective to understand Shakespeare. What television was able to do was to capture people as they were.</p>

<p>你可以把它想成，随着计算向外传播远快于教育未开化之人的速度，而对一些来自60或70年代的良好想法放置了低通过滤器。在过去大约25年，我们事实上得到一些好像流行文化的东西，类似于当电视机出现时所发生的。一些发明者的初衷是，电视机是让莎士比亚戏剧走向大众的一个途径，但他们忽略了，为了理解莎士比亚，你必须更加精于世情并有多个视角。电视能够做的是捕捉人们本然的样子。</p>

<p>So I think the lack of a real computer science today, and the lack of real software engineering today, is partly due to this pop culture.</p>

<p>因此我想今天缺少真正的计算机科学，缺少真正的软件工程，部分归因于这一流行文化。</p>

<p><strong>SF</strong> So Smalltalk is to Shakespeare as Excel is to car crashes in the TV culture?</p>

<p><strong>SF</strong> 那么，Smalltalk对于莎士比亚，是否就如同Excel对于电视文化中的车祸？</p>

<p><strong>AK</strong> No, if you look at it really historically, Smalltalk counts as a minor Greek play that was miles ahead of what most other cultures were doing, but nowhere near what Shakespeare was able to do.</p>

<p><strong>AK</strong> 不，如果你真从历史角度去看它，Smalltalk可当做小型的希腊戏剧，比大部分其它文明要领先几英里，但还没有接近莎士比亚所能做的。</p>

<p>If you look at software today, through the lens of the history of engineering, it’s certainly engineering of a sort—but it’s the kind of engineering that people without the concept of the arch did. Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.</p>

<p>如果你从工程的历史透镜去看今天的软件，它的确是某类工程 - 但它是那些对拱形结构都没有概念的人所做的工程。绝大多数今天的软件，非常象用数百万砖块堆积的埃及金字塔，没有结构的一致性，但仅靠蛮力和成千上万的奴隶。</p>

<p><strong>SF</strong> The analogy is even better because there are the hidden chambers that nobody can understand.</p>

<p><strong>SF</strong> 这个类比甚至更绝妙，因为这样里面有，无人能知的暗室。</p>

<p><strong>AK</strong> I would compare the Smalltalk stuff that we did in the ’70s with something like a Gothic cathedral. We had two ideas, really. One of them we got from Lisp: late binding. The other one was the idea of objects. Those gave us something a little bit like the arch, so we were able to make complex, seemingly large structures out of very little material, but I wouldn’t put us much past the engineering of 1,000 years ago.</p>

<p><strong>AK</strong> 我将我们在70年代做的Smalltalk玩意儿，比作哥德式教堂。事实上，我们有两个想法。其一来自Lisp: 延迟绑定。另一个是对象的想法。这些给了我们一些有点象拱形结构的东西，因此我们能够从小的材料中，做出复杂的、看起来大型的结构，但是我不会将我们放到1000年前的工程。</p>

<p>If you look at [Doug] Engelbart’s demo [a live online hypermedia demonstration of the pioneering work that Engelbart’s group had been doing at Stanford Research Institute, presented at the 1968 Fall Joint Computer Conference], then you see many more ideas about how to boost the collective IQ of groups and help them to work together than you see in the commercial systems today. I think there’s this very long lag between what you might call the best practice in computing research over the years and what is able to leak out and be adapted in the much more expedient and deadline-conscious outside world.</p>

<p>如果你看看Englebart的演示，那么你会看见比今天商业系统中更多的创意，关于如何提升团体的共同智商并帮助他们一起工作。我想，在计算研究多年来你可能称之的最佳实践，与能够渗入并被更为应急和注重最终期限的外部世界所采纳的之间，有相当大的延滞。</p>

<p>It’s not that people are completely stupid, but if there’s a big idea and you have deadlines and you have expedience and you have competitors, very likely what you’ll do is take a low-pass filter on that idea and implement one part of it and miss what has to be done next. This happens over and over again. If you’re using early-binding languages as most people do, rather than late-binding languages, then you really start getting locked in to stuff that you’ve already done. You can’t reformulate things that easily.</p>

<p>这并不是说人们都彻头彻尾地愚蠢，但是如果有个大点子而你有最终期限，你有应急手段，还有竞争者，那么很有可能你将做的，就是对那个点子放置低通过滤器，然后实施其中一部分，漏掉下次必须做的。这一而再地发生。如果你使用绝大多数人使用的早期绑定语言(early-binding languages)，而非延迟绑定语言，那么事实上你刚开始就被你已经做的锁定住了。你难以重新规划它。</p>

<p>Let’s say the adoption of programming languages has very often been somewhat accidental, and the emphasis has very often been on how easy it is to implement the programming language rather than on its actual merits and features. For instance, Basic would never have surfaced because there was always a language better than Basic for that purpose. That language was Joss, which predated Basic and was beautiful. But Basic happened to be on a GE timesharing system that was done by Dartmouth, and when GE decided to franchise that, it started spreading Basic around just because it was there, not because it had any intrinsic merits whatsoever.</p>

<p>让我们来说说，编程语言的采纳经常有些偶然性，过去经常是强调实现一个编程语言多么容易，而非它实际的优点和特性。例如，Basic本不该浮出水面，因为对于那个目的已经有一个语言优于它。这个语言是Joss，早于Basic，非常漂亮。但是Basic碰巧在由Dartmouth完成的GE分时系统上，当GE决定经销这系统时，Basic就开始四处被传播，仅仅因为它就在那里，而非有任何内在优点。</p>

<p>This happens over and over again. The languages of Niklaus Wirth have spread wildly and widely because he has been one of the most conscientious documenters of languages and one of the earlier ones to do algorithmic languages using p-codes (pseudocodes)—the same kinds of things that we use. The idea of using those things has a common origin in the hardware of a machine called the Burroughs B5000 from the early 1960s, which the establishment hated.</p>

<p>这又一而再地发生。<a href="https://zh.wikipedia.org/wiki/尼克劳斯·维尔特">Niklaus Wirth</a>的语言野蛮而广泛地传播<em>(注：他发明了Algol W、Pascal、Modula等语言)</em>，是因为他是最勤勤恳恳的语言文档撰写者之一，最早使用p代码(伪代码)作为算法语言的人之一 – 和我们使用的是同一类。使用那些东西的想法有个共同的根源，是在来自1960年代早期称为Burroughs B5000的硬件机器，这是保守派所憎恶的。</p>

<p><strong>SF</strong> Partly because there wasn’t any public information on most of it.</p>

<p><strong>SF</strong> 部分原因是对绝大多数这样的事情，没有任何公开的信息。</p>

<p><strong>AK</strong> Let me beg to differ. I was there, and Burroughs actually hired college graduates to explain that machine to data-processing managers. There was an immense amount of information available. The problem was that the DP managers didn’t want to learn new ways of computing, or even how to compute. IBM realized that and Burroughs didn’t.</p>

<p><strong>AK</strong> 让我说点不同的。我在那里，Burroughs的确雇佣了大学毕业生去向数据处理经理解释那个机器。有大量的信息可用。问题是那个经理不想学习计算的新方式，或甚至如何计算。IBM认识到那点了，但Burroughs没有。</p>

<p><strong>SF</strong> If memory serves, I was fascinated by that machine at the time, but I was unable to get the detail that made me understand it.</p>

<p>如果资金许可，那时我会被这机器迷住的，但是我无法获得让我理解它的细节。</p>

<p><strong>AK</strong> In fact, the original machine had two CPUs, and it was described quite adequately in a 1961 paper by Bob Barton, who was the main designer. One of the great documents was called “The Descriptor” and laid it out in detail. The problem was that almost everything in this machine was quite different and what it was trying to achieve was quite different.</p>

<p><strong>AK</strong> 事实上，原始的机器有两个CPU，这已经在主要设计者Bob Barton于1961年写的一篇文章中非常充分地讨论了。其中一篇伟大的文献被称为“描述子”(Descriptor)，并详细设计了它。问题是这个机器几乎所有的东西都是不同的，而且它试图达到的目标也完全不同。</p>

<p>The reason that line lived on—even though the establishment didn’t like it—was precisely because it was almost impossible to crash it, and so the banking industry kept on buying this line of machines, starting with the B5000. Barton was one of my professors in college, and I had adapted some of the ideas on the first desktop machine that I did. Then we did a much better job of adapting the ideas at Xerox PARC (Palo Alto Research Center).</p>

<p>那条线存活的原因，即使保守派不喜欢它，恰恰是它几乎不可能崩溃，所以从B5000开始，银行业不断地购买这条线的机器。Barton是我大学时的教授之一，我在做第一个桌面机器时采用其中一些想法。然后我们在施乐PARC采纳这些想法做出了更加出色的工作。</p>

<p>Neither Intel nor Motorola nor any other chip company understands the first thing about why that architecture was a good idea.</p>

<p>无论是英特尔还是摩托罗那，或其它任何芯片公司，都不理解这个首要的事情，为什么那个架构是个好点子。</p>

<p>Just as an aside, to give you an interesting benchmark—on roughly the same system, roughly optimized the same way, a benchmark from 1979 at Xerox PARC runs only 50 times faster today. Moore’s law has given us somewhere between 40,000 and 60,000 times improvement in that time. So there’s approximately a factor of 1,000 in efficiency that has been lost by bad CPU architectures.</p>

<p>仅仅插一句，给你一个有趣的指标 - 对大致相同的机器，大致用相同的方式优化，根据施乐Xerox在1979的基准，今天的机器只快了50倍。在这个期间，摩尔定律给了我们大概40000到60000倍的提升。因此，由于糟糕的CPU架构设计，大约有因子为1000倍的效率损失。</p>

<p>The myth that it doesn’t matter what your processor architecture is—that Moore’s law will take care of you—is totally false.</p>

<p>不用在意处理器的架构，摩尔定律将照顾你。这个神话，是完全错误的。</p>

<p><strong>SF</strong> It also has something to do with why some languages succeed at certain times.</p>

<p><strong>SF</strong> 也看看为什么一些语言在特定时间会成功。</p>

<p><strong>AK</strong> Yes, actually both Lisp and Smalltalk were done in by the eight-bit microprocessor—it’s not because they’re eight-bit micros, it’s because the processor architectures were bad, and they just killed the dynamic languages. Today these languages run reasonably because even though the architectures are still bad, the level 2 caches are so large that some fraction of the things that need to work, work reasonably well inside the caches; so both Lisp and Smalltalk can do their things and are viable today. But both of them are quite obsolete, of course.</p>

<p>是的，事实上Lisp和Smalltalk都在8位微处理器上完成 - 这不是因为他们是8位的微指令，而是因为糟糕的处理器架构，它们刚好扼杀了动态语言。今天，这些语言合情合理地运行着，因为即使架构仍然糟糕，但是L2缓冲如此大，有些需要做的事情，在缓冲中能合情合理地良好运行；因此Lisp和Smalltalk可以做他们的事情，它们在今天是可行的语言。但是，当然，它们两个快要过时了。</p>

<p>The stuff that is in vogue today is only about “one-half” of those languages. Sun Microsystems had the right people to make Java into a first-class language, and I believe it was the Sun marketing people who rushed the thing out before it should have gotten out. They made it impossible for the Sun software people to do what needed to be done.</p>

<p>今天在流行的东西，只是那些语言的“一半”。Sun公司有正确的人将Java变成第一流的语言。我相信这是Sun的营销人员在其本该出现之前，赶制出来的。他们使得Sun的软件人员不可能去做需要做的事。</p>

<p><strong>SF</strong> What should Java have had in it to be a first-quality language, not just a commercial success?</p>

<p>为了成为第一流的语言，而非商业的成功，Java本身还需具备什么？</p>

<p><strong>AK</strong> Like I said, it’s a pop culture. A commercial hit record for teenagers doesn’t have to have any particular musical merits. I think a lot of the success of various programming languages is expeditious gap-filling. Perl is another example of filling a tiny, short-term need, and then being a real problem in the longer term. Basically, a lot of the problems that computing has had in the last 25 years comes from systems where the designers were trying to fix some short-term thing and didn’t think about whether the idea would scale if it were adopted. There should be a half-life on software so old software just melts away over 10 or 15 years.</p>

<p>如同我前面说的，这是个流行文化。给十多岁青少年听的流行唱片，不必要有特别的音乐价值。我认为各种编程语言的很大成功是应急式的填坑。Perl是另外一个例子，为了满足细微而短期的需求，却成为更长期内的一个实际麻烦。根本上讲，过去25年中计算方面的很多问题，都来自于这样的系统，设计者试图修复一些事情，并没有思考如果采纳的话，这个点子应具扩展性。软件本该只有一半的寿命<em>(注：过去25年产生的软件)</em>，因此旧软件刚好在10到15年间消逝掉。</p>

<p>It was a different culture in the ’60s and ’70s; the ARPA (Advanced Research Projects Agency) and PARC culture was basically a mathematical/scientific kind of culture and was interested in scaling, and of course, the Internet was an exercise in scaling. There are just two different worlds, and I don’t think it’s even that helpful for people from one world to complain about the other world — like people from a literary culture complaining about the majority of the world that doesn’t read for ideas. It’s futile.</p>

<p>在1960和70年代，有着不同的文化；高级研究项目管理局(ARPA)和帕洛阿尔托研究中心(PARC)的文化，根本上讲，是一种数学/科学性的文化，对扩展性感兴趣。当然，Inernet就是规模化的一个练习。恰恰有两个不同的世界。我不认为，一个世界的人抱怨另一个世界的人甚至有什么帮助，就好像来自一个文学文化的人们抱怨世界上大多数的人不能读懂意思。这是无用的。</p>

<p>I don’t spend time complaining about this stuff, because what happened in the last 20 years is quite normal, even though it was unfortunate. Once you have something that grows faster than education grows, you’re always going to get a pop culture. It’s well known that I tried to kill Smalltalk in the later ’70s. There were a few years when it was the most wonderful thing in the world. It answered needs in a more compact and beautiful way than anything that had been done before. But time moves on. As we learned more and got more ambitious about what we wanted to do, we realized that there are all kinds of things in Smalltalk that don’t scale the way they should—for instance, the reflection stuff that we had in there. It was one of the first languages to really be able to see itself, but now it is known how to do all levels of reflection much better—so we should implement that.</p>

<p>我不想花时间抱怨这个事，因为在过去20年发生的非常正常，即使这是不幸的。一旦你有些东西，它比教育增长得更快，你总会得到一个流行文化。众所周知，我试图在70年代晚期终结Smalltalk。它在一些年头是世界上最漂亮的东西。它用比之前做过的任何东西更为紧致和漂亮的方式去回应需要，但时间在往前走。随着我们学会更多，对我们想做的事更有抱负的时候，我们认识到在Smalltalk中所有种类的事物，不能以它们本该的方式去扩展–例如，发射。它是真正看到它自身的最早的语言之一，但是现在知道了如何更好地做所有层次的反射。因此，我们必须实现之。</p>

<p>We saw after a couple of years that this could be done much better. The object model we saw after a couple of years could be done much better, etc. So the problem is—I’ve said this about both Smalltalk and Lisp—they tend to eat their young. What I mean is that both Lisp and Smalltalk are really fabulous vehicles, because they have a meta-system. They have so many ways of dealing with problems that the early-binding languages don’t have, that it’s very, very difficult for people who like Lisp or Smalltalk to imagine anything else.</p>

<p>几年之后我们看到，这可以做得更好。我们几年之后看到的对象模型可以做得更好，等等。因此，问题是–我曾经说过关于Smalltalk和Lisp，它们常常吃掉它们的幼崽。我的意思是，Lisp和Smalltalk是真正绝妙的载具，因为它们有一个元系统。它们有那些早期绑定语言不具备的如此多的方式去处理问题，以至于对于喜欢Lisp或Smalltalk的人非常难以想象还有其它什么。</p>

<p>Now just to mention a couple of things about Java: it really doesn’t have a full meta-system. It has always had the problem—for a variety of reasons—of having two regimes, not one regime. It has things that aren’t objects, and it has things that it calls objects. It has real difficulty in being dynamic. It has a garbage collector. So what? Those have been around for a long time. But it’s not that great at adding to itself.</p>

<p>现在谈到Java的一些事情：它确实没有一个全面的元系统。它总是因为不同的原因，有一个问题：它存在两个体制，而非一个体制。它有一些不是对象的东西，它有一些称为对象的东西。它成为动态的有实际的困难。它有一个垃圾收集器。那又怎么样？这些已经四处都是很久了。只将垃圾收集器加到它里面，不算高明。</p>

<p>For many years, the development kits for Java were done in C++. That is a telling thing.</p>

<p>在很多年，Java的开发工具用C++完成。这是个有说服力的事情。</p>

<p>We looked at Java very closely in 1995 when we were starting on a major set of implementations, just because it’s a lot of work to do a viable language kernel. The thing we liked least about Java was the way it was implemented. It had this old idea, which has never worked, of having a set of paper specs, having to implement the VM (virtual machine) to the paper specs, and then having benchmarks that try to validate what you’ve just implemented — and that has never resulted in a completely compatible system.</p>

<p>我们在1995年仔细观察Java，当时我们正着手一个主要的实现集，仅仅因为做一个可行的核有很多事情要干。我们最不喜欢的事情，是Java实现的方式。它有这样的陈旧想法，从来没有奏效过，即：定义一组纸面上的规范，要求按照纸面规范去实现VM(虚拟机)，然后用标杆去试图验证你刚刚实现的。这个想法从来没有产生一个完全兼容的系统。</p>

<p>The technique that we had for Smalltalk was to write the VM in itself, so there’s a Smalltalk simulator of the VM that was essentially the only specification of the VM. You could debug and you could answer any question about what the VM would do by submitting stuff to it, and you made every change that you were going to make to the VM by changing the simulator. After you had gotten everything debugged the way you wanted, you pushed the button and it would generate, without human hands touching it, a mathematically correct version of C that would go on whatever platform you were trying to get onto.</p>

<p>我们用在Smalltalk上的技术是用它自己来写虚拟机，因此有一个VM的Smalltalk仿真器，它本质上就是VM的唯一规范。通过将材料提交给它，你可以调试，你可以回答任何问题，关于VM可以做什么。一旦你将所有事情都以你想的方式调试通过，你按一下按钮，不需要人去插手，它将生成一个数学上正确的C版本，可以在你想尝试的任何平台上去运行。</p>

<p>The result is that this system today, called Squeak, runs identically on more than two dozen platforms. Java does not do that. If you think about what the Internet means, it means you have to run identically on everything that is hooked to the Internet. So Java, to me, has always violated one of the prime things about software engineering in the world of the Internet.</p>

<p>这一成果就是，今天称为Squeak的这个系统，在超过20个平台上无差别地运行。Java做不到这点。如果你想想Internet意味着什么，它意味着你必须无差别地运行任何挂在Internet上的东西。因此，Java，对我来说，常常违反关于软件工程在Internet世界的一个初衷。</p>

<p>Once we realized that Java was likely not to be compatible from platform to platform, we basically said we’ll generate our own system that is absolutely compatible from platform to platform, and that’s what we did.</p>

<p>一旦我们认识到，Java可能从平台到平台不兼容，我们从根本上决定，我们将生成我们自己的系统，它在平台到平台之间是绝对兼容的。这就是我们做的。</p>

<p>Anybody can do that. If the pros at Sun had had a chance to fix Java, the world would be a much more pleasant place. This is not secret knowledge. It’s just secret to this pop culture.</p>

<p>任何人都能做到。假使Sun的正方有机会修正Java，世界将会是更为愉悦的地方。这里没有机密的知识。仅仅对这一流行文化是个秘密。</p>

<p><strong>SF</strong> If nothing else, Lisp was carefully defined in terms of Lisp.</p>

<p>如果没有其它的，Lisp是仔细以Lisp的方式定义的。</p>

<p><strong>AK</strong> Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>

<p>是的，当我在研究生院时，这对我是个巨大的启示–当我最终理解Lisp 1.5版手册第13页下部的半页代码，是Lisp自己的时候。这就是“软件中的麦克斯韦方程”。整个的编程世界可以放在聊聊几代码中–可以写在我的掌心。</p>

<p>I realized that anytime I want to know what I’m doing, I can just write down the kernel of this thing in a half page and it’s not going to lose any power. In fact, it’s going to gain power by being able to reenter itself much more readily than most systems done the other way can possibly do.</p>

<p>我认识到，任何时候当我想知道我正在做的，我就将这件事的核心写在半页纸上，这没有丧失任何力量。事实上，通过能够更容易地重新进入事情，比大多数系统尽可能用其它方式所能做的，将会获得力量。</p>

<p>All of these ideas could be part of both software engineering and computer science, but I fear—as far as I can tell—that most undergraduate degrees in computer science these days are basically Java vocational training.</p>

<p>所有这些想法，可以是软件工程和计算机科学的一部分。但是我担心–就我的判断–计算机科学里的大多数本科学位，根本上讲，是Java的职业培训。</p>

<p>I’ve heard complaints from even mighty Stanford University with its illustrious faculty that basically the undergraduate computer science program is little more than Java certification.</p>

<p>我从甚至强大的、拥有杰出教师队伍的斯坦福大学那里听到的抱怨是，根本上讲，本科计算机科学课程，没有比Java认证多出什么。</p>

<p><strong>SF</strong> Well, I must admit I was surprised recently when I discovered in a group of very good developers I managed, almost none of them knew C well enough to write expert low-level stuff. All of them were really good Java jocks.</p>

<p><strong>SF</strong> 好的，我必须承认，最近我有些惊讶，当我发现我管理的一个优秀开发人员组成的团队，几乎没有人足够懂C，能写出专家级的底层工作。他们确实都是Java的好手。</p>

<p><strong>AK</strong> In the 1960s Ted Steele spent several years promoting an idea called UNCOL (universal computer-oriented language), and, to me, by a weird and interesting process—mainly because it’s easy to implement—C turned out to be UNCOL. I don’t think any human being should write in it, but it’s a great target for anybody who wants to do multiplatform things—especially if you pick the right subset.</p>

<p><strong>AK</strong> 在1960年代，Ted Steele花了好几年向我推广一个称为UNCOL(universal computer-oriented language，通用面向计算机语言)的想法，通过一个怪诞和有趣的过程，主要是因为它容易实施 - C原来是UNCOL。我不认为任何人必须用它写程序，但是对于任何想做多平台事情的人，它是一个伟大的目标，特别是如果你选择了正确的子集。</p>

<p>The problem with the Cs, as you probably know if you’ve fooled around in detail with them, is that they’re not quite kosher as far as their arithmetic is concerned. They are supposed to be, but they’re not quite up to the IEEE standards. You have to pick a subset of C and you have to have some side information to get to a mathematically perfect transform of your VM.</p>

<p>各种C的问题，正如你可能知道的，如果你已经在细节上虚度时，只要算法被关注，他们就不那么合适。他们假定是，但他们没有完全遵守IEEE标准。你不得不选取C的子集，你必须有一些侧面的信息来得到对你虚拟机(VM)在数学上的完美转化。</p>

<p><strong>SF</strong> To what do you attribute the long-term love of Smalltalk? There is a certain set of languages that I would assert people seem to love, not just use. I know many people who love C. I know very few who love C++, even though they may make their living on it.</p>

<p>你把对Smalltalk长期的热爱归因于什么？有确定的一组语言，我断言人们看起来热爱，而不仅仅是使用。我知道，很多人爱C。我知道很少有人爱C++，尽管他们靠其谋生。</p>

<p><strong>AK</strong> You have to be a different kind of person to love C++. It is a really interesting example of how a well-meant idea went wrong, because [C++ creator] Bjarne Stroustrup was not trying to do what he has been criticized for. His idea was that first, it might be useful if you did to C what Simula did to Algol, which is basically act as a preprocessor for a different kind of architectural template for programming. It was basically for super-good programmers who are supposed to subclass everything, including the storage allocator, before they did anything serious. The result, of course, was that most programmers did not subclass much. So the people I know who like C++ and have done good things in C++ have been serious iron-men who have basically taken it for what it is, which is a kind of macroprocessor. I grew up with macro systems in the early ’60s, and you have to do a lot of work to make them work for you—otherwise, they kill you.</p>

<p><strong>AK</strong> 为了爱C++，你必须成为不同的人。这的确是个有趣的例子，良好用意的想法被搞砸了，因为C++的创造者Bjarne Stroustrup没有试图做那些他被批评的事。他的想法是，首先，如果对C做那些Simula对Algol做的事<em>(注：预处理器</em>，那是可能有用的。其根本上是作为一个预处理器，针对一个不同类的编程架构模板。对于超级程序员，在他们做任何正儿八经的事之前，假定可以子类化任何事物，是最基本的，包括对存储分配器。因此，我所知道的那些喜欢C++，并用它做出漂亮工作的人，是严肃的钢铁侠。他们只使用C++原本做的事，作为一种预处理器。在60年代早期，伴随宏系统而成长，你必须做很多事情来让它们为你工作–否则，它们会杀了你。</p>

<p><strong>SF</strong> Well, C++, after all, was programmed as a macro processor, in essence.</p>

<p>好的，C++，毕竟，本质上，作为一个宏处理器来编写的。</p>

<p><strong>AK</strong> Yes, exactly. But so was Simula.</p>

<p>是的，确实是。但Simula也是这样。</p>

<p><strong>SF</strong> I put Smalltalk in this category of languages that have true devotees—people who genuinely like it or love it, not simply appreciate and use it.</p>

<p>我把Smalltalk放在有真正热爱者的一类语言，人们真正地喜欢或爱它，而非仅仅欣赏或使用它。</p>

<p><strong>AK</strong> In a history of Smalltalk I wrote for ACM, I characterized one way of looking at languages in this way: a lot of them are either the agglutination of features or they’re a crystallization of style. Languages such as APL, Lisp, and Smalltalk are what you might call style languages, where there’s a real center and imputed style to how you’re supposed to do everything. Other languages such as PL/I and, indeed, languages that try to be additive without consolidation have often been more successful. I think the style languages appeal to people who have a certain mathematical laziness to them. Laziness actually pays off later on, because if you wind up spending a little extra time seeing that “oh, yes, this language is going to allow me to do this really, really nicely, and in a more general way than I could do it over here,” usually that comes back to help you when you’ve had a new idea a year down the road. The agglutinative languages, on the other hand, tend to produce agglutinations and they are very, very difficult to untangle when you’ve had that new idea.</p>

<p>在我为ACM写的一个Smalltalk的历史中，我描述一种看待语言的方式：很多语言要么是特性的凝聚，要么是风格的具体化(结晶)。象APL，Lisp和Smalltalk是你所称的风格性语言，它有真正的中心，然后把风格灌输到你假设要做的任何事情上。其它的语言，比如PL/I，那些试图加和特性而不做整合的语言，的确经常更成功。我认为，风格性语言吸引那些有特定数学惰性的人。懒惰实际上在日后有回报的，因为如果你停下来花一点点额外的时间看看“哦，对的，这个语言将允许我的的确确漂亮地做这个事，并以更普遍的方式让我在这儿来做”。而且如果你已经有了一年之后的新想法，这通常会回来帮到你。凝聚性语言，相反，常常产生凝聚性，当你有新想法时，它们非常非常难以解开。</p>

<p>Also, I think the style languages tend to be late-binding languages. The agglutinative languages are usually early-binding. That makes a huge difference in the whole approach. The kinds of bugs you have to deal with, and when you have to deal with them, is completely different.</p>

<p>而且，我认为风格性语言常常是延迟绑定的语言。凝聚性语言通常是早期绑定的。这在整个实现途径上，产生了极大的不同。你必须面对的bug类型，你必须在何时处理它们，都完全不同。</p>

<p>Some people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope. If you combine Simula and Lisp—Lisp didn’t have data structures, it had instances of objects—you would have a dynamic type system that would give you the range of expression you need.</p>

<p>一些人对类型系统有完全宗教式的虔诚。作为数学家，我喜爱类型系统的想法，但是没有人曾经拿出过有足够范围的类型系统。如果你将Simula和Lisp综合起来，Lisp没有数据结构，它有对象实例–你将有一个动态类型系统，这会给你你所需的表达式的范围。</p>

<p>It would allow you to think the kinds of thoughts you need to think without worrying about what type something is, because you have a much, much wider range of things. What you’re paying for is some of the checks that can be done at runtime, and, especially in the old days, you paid for it in some efficiencies. Now we get around the efficiency stuff the same way Barton did on the B5000: by just saying, “Screw it, we’re going to execute this important stuff as directly as we possibly can.” We’re not going to worry about whether we can compile it into a von Neumann computer or not, and we will make the microcode do whatever we need to get around these inefficiencies because a lot of the inefficiencies are just putting stuff on obsolete hardware architectures.</p>

<p>这会允许你思考，那些你需要思考的想法，而不需担心类型是什么，因为你有一个非常非常更为宽泛的事物。你要付出的代价是，要做些检查，这可在运行时完成，特别是在旧的时期，你能用有效的方式支付这些代价。现在，我们绕开了Barton在B5000上以相同方式做的有效性东西，仅仅通过说，“上紧螺丝，我们将尽可能直接地执行这个重要的事情”。我们将没去担心我们是否能将其编译到一个冯诺依曼计算机里，以及我们将让微代码执行任何我们需要去绕过这些无效的地方，因为很多无效性仅仅是将事情放在过时的硬件架构上。</p>

<p>I just think that’s a two-culture divide. I’ve seen many meetings where people are unable to communicate just because of the stylistic differences in approaches.</p>

<p>我只是想这是两种文化的分割。我已经看过很多会议中，人们不能沟通，仅仅因为处理风格的不同。</p>

<p><strong>SF</strong> I would characterize style languages as those with a very rigorous kernel that describes them intellectually. As Smalltalk went through a number of revolutions, to what extent did those change the core kernel, as opposed to improving the range of usefulness?</p>

<p>我认为风格性语言的特征是，具有非常严谨的内核，它智能地描述了语言。Smalltalk经历过一些革新，相对于改进实用性的范围，它们在多大程度是对中心核的改变？</p>

<p><strong>AK</strong> We’ll never know the exact answer to your question because during the development of the system, from when Xerox put it out to this day, all the changes happened in a single thread of development at Xerox PARC. To the outside world, Smalltalk has changed almost not at all. Basically, it’s just built on bigger and bigger libraries of different kinds.</p>

<p>对你的问题，很难有确切的答案，因为在开发系统的过程中，从施乐将它创造出来到今天，所有的改变发生在施乐PARC开发的单一线程上。对于外在的世界，Smalltalk几乎没有一点改变。根本上讲，它仅仅是构建在越来越庞大的不同种类的库上。</p>

<p>But the good thing about the changes in Smalltalk was that it never got diluted, and the scope of the practical things you could think about doing in Smalltalk expanded dramatically during the period at Xerox PARC.</p>

<p>但是，关于Smalltalk的改变，好事是它从来没有被稀释过。你能想到用Smalltalk的实际工作的范围，在施乐PARC的期间，急剧地扩展了。</p>

<p>Basically what happened is this vehicle became more and more a programmer’s vehicle and less and less a children’s vehicle—the version that got put out, Smalltalk ’80, I don’t think it was ever programmed by a child. I don’t think it could have been programmed by a child because it had lost some of its amenities, even as it gained pragmatic power.</p>

<p>根本上讲，所发生的是，这个载具越来越变成一个程序员的载具，越来越少地作为儿童的工具–它得以出生的版本， Smalltalk ‘80，我不认为它曾由儿童来编程。我不认为他本应该已由小孩来编程，因为它已经失去了一些便利性，即使它获得了实用的力量。</p>

<p>So the death of Smalltalk in a way came as soon as it got recognized by real programmers as being something useful; they made it into more of their own image, and it started losing its nice end-user features.</p>

<p>因此，Smalltalk的死亡会以这种方式来临，一旦它被实际的程序员认为是有些用；他们按自己的想象去改变它，结果它开始失去了它漂亮的最终用户接口。</p>

<p>But that’s OK. This project that we started in 1995 was to make Squeak as an implementation vehicle for another end-user system for children. That was done quite well and is being used by many, many thousands of children around the world. The other way of looking at this is to realize that <strong><em>computers are made to be programmed by human beings</em></strong>. Let’s just roll our own. Let’s not complain about Java, or even about Smalltalk.</p>

<p>但这挺好的。我们开始于1995年的项目是把Squeak作为一个实现载具，它针对另一个面向孩子的最终用户系统。这件事做得很棒，已经被很多很多世界各地成千上万的孩子使用。看待这事的另一个方式是，认识到<strong><em>计算机做出来，就是为了让人类编程的</em></strong>。就让我们孤军奋战吧。让我们不要抱怨Java，乃至Smalltalk。</p>

<p>In fact, let’s not even worry about Java. Let’s not complain about Microsoft. Let’s not worry about them because we know how to program computers, too, and in fact we know how to do it in a meta-way. We can set up an alternative point of view, and we’re not the only ones who do this, as you’re well aware.</p>

<p>事实上，让我们甚至不要抱怨Java。让我们不要抱怨微软。让我们不要抱怨他们，因为我们知道如何对计算机编程，事实上我们知道如何对之采用元的方式(in a meta-way)。我们可以建立一个替代的视角，我们不是唯一这样做的人，你对此也很清楚。</p>

<p>There are numerous examples on the Internet of people who have gone to one level or another by making their own point of view. Squeak is the most comprehensive because it spans the whole field. It doesn’t require any particular operating system to run because it’s self-sufficient and has a full set of tools and applications and so forth, but there are many interesting functional languages, particularly in Europe, that are of interest.</p>

<p>在互联网上有大量的例子，通过有他们自己的观点，他们达到这个或那个层次。Squeak是最丰富的，因为它扩展到整个领域。它不需要特定的操作系统去运行，因为它是自给自足的，并有完整的工具集和应用等。不过，在欧洲，有很多有趣的函数式语言，很有趣。</p>

<p>One of my favorite old languages is one called Lucid by Ed Ashcroft. It was a beautiful idea. He said, “Hey, look, we can regard a variable as a stream, as some sort of ordered thing of its values and time, and use Christopher Strachey’s idea that everything is wonderful about tail recursion and Lisp, except what it looks like.” When he looked at Lisp, he had a great insight: which was that tail-recursive loops and Lisp are so clean because you’re generating the right-hand side of all the assignment statements before you do any rebinding. So you’re automatically forced to use only old values. You cannot rebind, so there are no race conditions on anything.</p>

<p>我喜欢的一个老的语言，Ed Ashcroft称之为Lucid。这是一个很漂亮的点子。他说，“嘿，看，我们能把变量看做一个流，以它的值和时间为排序，然后用Christopher Strachey的想法，即每件事情都是关于尾部递归和Lisp，除过它看起来的样子”。当他看到Lisp，他有了伟大的洞见：那就是，尾部递归循环和Lisp是如此清晰，因此你在做任何重新绑定之前，你正在生成所有赋值语句的右侧。因此，<strong><em>你自动地被强制只使用旧的值。你不能重新绑定，因此这里没有对任何东西的竞争。</em></strong></p>

<p>You just write down all of those things, and then when you do the tail recursion, you rebind all of those variables with these new values. Strachey said, “I can write that down like a sequential program, as a bunch of simultaneous assignment statements, and a loop that makes it easier to think of.” That’s basically what Lucid did—there is no reason that you have to think recursively for things that are basically iteration, and you can make these iterations as clean as a functional language if you have a better theory about what values are.</p>

<p>你恰恰正在写下所有那些事情，然后当你做尾部递归时，你用这些新值重新绑定所有的那些变量。Strachey说“我能象一个顺序程序一样写下他们，就像一捆同时赋值的语句，以及一个让它容易思考的循环“。这根本上讲，就是Lucid做的，<strong>没有理由你必须用递归方式思考那些本质上是迭代的事物</strong>。如果你有一个更好地关于值是什么的理论，你就能让这些迭代象函数式语言一样干净。</p>

<p>This idea, by the way, was used in [Squeak contributor] Dave Reed’s fantastic thesis for coordinating object siblings where you have one logical object but many physical manifestations of the same object on different machines, and you have to make them track each other by transactions.</p>

<p>顺便说一下，这个想法，在Dave Reed为了协调对象兄弟的美妙命题中也用到，在那里你有一个逻辑的对象，但是在不同机器上有很多相同对象的物理显化，你必须用事务来让他们可跟踪彼此。</p>

<p>The way to get rid of these things (like Smalltalk) is to make something that is much, much more powerful as a computation model and much more expressive for the core programmer who is trying to write programs. In these late programming languages, you can disappear the old guy and just leave the new guy behind. So we are doing that at this moment.</p>

<p>去掉这些事情的方式是做出一些更加更加强大的东西，来作为一个计算模型，并为了那些尝试写程序的核心程序员，要更具表现力。在这些后期的编程语言，你能让旧的家伙消失，而只让新的家伙在幕后。因此，我们现在就在做这些。</p>

<p><strong>SF</strong> What do you think a programming language should achieve and for whom, and then what is the model that goes with that idea?</p>

<p>你认为一个编程语言必须达到什么，并为谁？然后什么是与这个想法相配的模型？</p>

<p><strong>AK</strong> Even if you’re designing for professional programmers, in the end your programming language is basically a user-interface design. You will get much better results regardless of what you’re trying to do if you think of it as a user-interface design. PARC is incorrectly credited with having invented the GUI. Of course, there were GUIs in the ’60s. But I think we did do one good thing that hadn’t been done before, and that was to realize the idea of change being eternal.</p>

<p>即使你正在为专业的程序员设计语言，最终，你的编程语言根本上讲是用户界面设计。如果你将它看做一个用户界面设计，无论你正在尝试做什么，你都会得到更好一些的结果。GUI的发明被错误地归功于PARC。当然，在60年代有很多GUI。但是，我想我们的确做了之前从未做的一件好事，</p>

<p><strong>SF</strong> You never walk in the same river, otherwise known as Strachey streams.</p>

<p><strong>SF</strong> 你不会踏入同一条河流，就如同Strachey流。</p>

<p><strong>AK</strong> The user interface, which is still the predominant approach today, is a user interface as the access to function. If the area is interesting, you eventually wind up with something that looks like the control panel of a nuclear reactor. So this is the agglutination of features.</p>

<p><strong>AK</strong> 用户界面，在今天仍然是主导性的途径，是访问功能的用户界面。如果这个领域有趣，你最终会完成某些东西，看起来像核反应堆的控制面板。因此，这是特性的凝聚。</p>

<p><strong>SF</strong> Yes, a button on every pixel.</p>

<p><strong>SF</strong> 是的，每个像素有个按钮。</p>

<p><strong>AK</strong> Corporate buyers often buy in terms of feature sets. But at PARC our idea was, since you never step in the same river twice, the number-one thing you want to make the user interface be is a learning environment—something that’s explorable in various ways, something that is going to change over the lifetime of the user using this environment. New things are going to come on, and what does it mean for those new things to happen?</p>

<p><strong>AK</strong> 公司采购者经常按照特性集去采购。但是在PARC，我们的想法是，<strong><em>既然你不可能再次踏入同一条河流，你对用户界面想做的第一件事，是让它成为一个学习的环境</em></strong>–可以用不同方式去探索的东西，能够在用户使用这个环境的生命周期中不断改变。新事物总会到来，对于这些会发生的新事物，它(用户界面)意味着什么。</p>

<p>This means improvements not only in the applications but also in the user interface itself. Some of those ideas were quite manifest in the original Macintosh, but are much less manifest in the Macs of today—and of course never really made it to Microsoft. That just wasn’t their way of thinking about things, and I think a programming language is the same way. Even if the user is an absolute expert, able to remember almost everything, I’m always interested in the difference between what you might call stark meaning and adjustable meaning.</p>

<p>这意味着改进不但在应用层面，也在用户界面自身。在早期的Macintosh中，如此的一些想法十分明显，但是在今天的Mac电脑中却非常少见了 - 当然对微软事实上从未有过。这不仅指他们思考事情的方式，我想编程语言也一样。即使用户是绝对的专家，能记住几乎所有事情，我也对简易含义与可调整含义之间的差别，总保持兴趣。</p>

<p>I did quite a bit of study on that over the years to understand the influence of having something that you can read. It’s known that our basic language mechanism for both reading and hearing has a fast and a slow process. The fast process has basically a surface phrasal-size nature, and then there’s a slower one. This is why jokes require pauses; the joke is actually a jump from one context to another, and the slower guy, who is dealing with the real meanings, has to catch up to it.</p>

<p>在过去的一些年头，我做了些研究去理解，你有可阅读之物的影响。众所周知，我们的基础语言机制，对于读或听，有一个快速和一个慢速过程。快速过程根本上讲，具有表面的、短语尺度的特性。然后有一个更慢的过程。这就是为什么笑话需要停顿；笑话事实上是从一个语境跳到另一个语境。反应慢的人，他是在理解实际的意思，不得不跟上这个跳跃。</p>

<p>There have been many, many studies of this. This argues that the surface form of a language, whatever it is, has to be adjustable in some form.</p>

<p>有很多很多这样的研究。这表明，语言的表面形式，无论它是什么，必须以某种形式可调整。</p>

<p><strong>SF</strong> As you probably know, recent research has looked at how different parts of the brain recognize and react to jokes. Physically, they are quite distinct.</p>

<p><strong>SF</strong> 你大概知道，近期的研究已经在关注，大脑的不同部位，如何认出笑话并对之反映。物理上看，它们非常独特。</p>

<p><strong>AK</strong> Yes. All creativity is an extended form of a joke. Most creativity is a transition from one context into another where things are more surprising. There’s an element of surprise, and especially in science, there is often laughter that goes along with the “Aha.” Art also has this element. Our job is to remind us that there are more contexts than the one that we’re in—the one that we think is reality.</p>

<p><strong>AK</strong> 是的。所有创造性是笑话的一种延伸形式。绝大多数的创造性是从一个环境到另一个的跃迁，在后者中事情更为出乎意料。有个惊讶的要素，特别是科学中，经常是大笑之后跟着一个”啊哈”。艺术也有这个要素。我们的工作是让我们忆起，在我们所处的–我们认为是现实的环境之外，还有更多的环境。</p>

<p>In the ’60s, one of the primary goals of the computer science community was to arrive at an extensible language. As far as I know, only three ever actually worked, and the first Smalltalk was one of those three. Another very interesting one was done by Ned Irons, who invented the term syntax-directed compiler and did one of the first ones in the ’60s. He did a wonderful extensible language called Imp.</p>

<p>在60年代，计算机科学社群的一个主要目标是发明一个可延展的语言。就我所知，只有三个实际上做到了，第一代的Smalltalk是三者之一。另一个有趣的语言是由Ned Irons做出，他发明了“术语语法导向”的编译器，然后在60年代做出了首批的其中之一。他做出了一个漂亮的可延展语言，称之为Imp。</p>

<p>One of the things that people realized from these extensible languages is that there is the unfortunate difficulty of making the meta-system easy to use. Smalltalk-72 was actually used by children. You’re always extending the language without realizing it when you are making ordinary classes. The result of this was that you didn’t have to go into a more esoteric place like a compiler compiler—Yacc or something like that—to add some extension to the language.</p>

<p>人们从这些可延展的语言中认识到，做出易于使用的元系统，很不幸，是困难的。Smalltalk-72的确由孩子使用。当你在做普通类时(ordinary classes)，你总是在扩展语言而没认识到。结果是，你不必进入到一个更为神秘的地方，比如编译器的编译器–Yacc或其它类似的–为了给语言添加扩展。</p>

<p>But the flip side of the coin was that even good programmers and language designers tended to do terrible extensions when they were in the heat of programming, because design is something that is best done slowly and carefully.</p>

<p>但是硬币的另一面是，甚至优秀的程序员和语言设计者，也常常做出可怕的扩展，因为最好慢慢地、仔细地做设计。</p>

<p><strong>SF</strong> And late-night extensible programming is unsupportable.</p>

<p><strong>SF</strong> 不支持宵夜式的可延展语言。</p>

<p><strong>AK</strong> Exactly. So Smalltalk actually went from something that was completely extensible to one where we picked a syntax that allowed for a variety of forms of what was fixed, and concentrated on the extensibility of meaning in it.</p>

<p><strong>AK</strong> 的确。因此，Smalltalk事实上来自那些可完全延展到的东西，而达到一个语言，在其中我们选择一个语法，允许各种固定下来的形式，然后我们专心于其中含义的可延展性。</p>

<p>This is not completely satisfactory. One of the things that I think should be done today is to have a fence that you have to hop to forcibly remind you that you’re now in a meta-area—that you are now tinkering with the currency system itself, you are not just speculating. But it should allow you to do it without any other overhead once you’ve crossed this fence, because when you want to do it, you want to do it.</p>

<p>这还没有完全满意。我考虑今天必须做的事情之一是，设置一个围栏，强制你必须跳过去，从而提醒你，你现在处于一个元领域–你现在正在摆弄货币系统本身，你不仅仅是在投机。但是，一旦你跨过了这道围栏，它将允许你这么做，没有任何其它的开销。因为，当你想做的时候，你就是想做它。</p>

<p>I could go on and on. I feel like my answers are quite trivial since nobody really knows how to design a good language, including me.</p>

<p>我会继续往前、往前走。我感觉，我的回答是非常微不足道的，既然没有人真的知道如何设计一个好的语言，包括我。</p>

<p><strong>SF</strong> What do you wish you had done differently in the Smalltalk era?</p>

<p>你希望，在Smalltalk时代，你有什么会做的不同？</p>

<p><strong>AK</strong> I had the world’s greatest group, and I should have made the world’s two greatest groups. I didn’t realize there are benefits to having real implementers and real users, and there are benefits to starting from scratch every few months. I hired finishers because I’m a good starter and a poor finisher, but it took me a long time to realize that I was interfering with them by trying to improve things.</p>

<p>我有世界上最伟大的团队，我本应该建立两个最伟大的团队。我没有认识到，同时拥有真实的实现者和真实的用户，其中的好处，以及每几个月从头开始的好处。我聘用了润饰者(完工者)，因为我是个好的启动者却是个糟糕的润饰者。但是，我花了很长时间才认识到，我为了试图改进事情，正在打扰他们。</p>

<p>I believe that the only kind of science computing can be is like the science of bridge building. Somebody has to build the bridges and other people have to tear them down and make better theories, and you have to keep on building bridges.</p>

<p>我相信，计算科学唯一的类别好似桥梁构建的科学。有些人必须造桥，而其他的人必须拆卸它们并作出更好的理论，而你不得不继续造桥。</p>

<p><strong>SF</strong> And every so often, you have to watch one fall into the drink.</p>

<p><strong>SF</strong> 时不时，你不得不看到有人沉迷于酒中。</p>

<p>© 2004 ACM 1542-7730/04/1200</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/concepts-in-lisp/">Concepts in LISP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-01T12:07:42+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="functional-programming">Functional Programming</h3>

<p>The only thing a function can do is calculate something and return it as a result. </p>

<p>函数能做的唯一事情，是算出点东西，然后将它作为结果返回。</p>

<h3 id="forms">Forms</h3>

<p>The things which you type to the LISP interpreter are called forms; the LISP interpreter repeatedly reads a form, evaluates it, and prints the result. This procedure is called the read-eval-print loop.</p>

<p>你键入到Lisp中的东西，称为form。Lisp 反复地读取一个form，对它求值，然后打印结果。这个过程称为，“读取-求值-打印”循环，缩写为REPL。</p>

<p>In general, a form is either an atom (for example, a symbol, an integer, or a string) or a list. If the form is an atom, LISP evaluates it immediately. Symbols evaluate to their value; integers and strings evaluate to themselves. If the form is a list, LISP treats its first element as the name of a function; it evaluates the remaining elements recursively, and then calls the function with the values of the remaining elements as arguments.</p>

<p>通常，一个form要么是原子(例如，符号、整数或字符串)，或者是列表。原子，也称为正常form或自求值form(normal form or self-evaluating form)。符号求值为它们的值；整数和字符串求值为他们自己。如果form是列表，也称为复合form(compound form)。LISP将其第一个元素视为函数名；它迭代地对剩下的元素求值，然后将剩下元素的值作为参数来调用函数。</p>

<h4 id="special-form">Special Form</h4>

<p>A special form is a form with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both. A special operator has access to the current lexical environment and the current dynamic environment. Each special operator defines the manner in which its subexpressions are treated—which are forms, which are special syntax, etc. </p>

<p>The set of special operator names is fixed in Common Lisp; no way is provided for the user to define a special operator. The next figure lists all of the Common Lisp symbols that have definitions as special operators.</p>

<p>(来源：<a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm">http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm</a>)</p>

<p>特殊form是一个form, 带有特殊语法或特殊求值规则，或兼有。它可能操纵求值环境、控制流，或兼有。一个特殊的运算符访问当前的词法环境和当前的动态环境。每个特殊的运算符定义了，如何处理其子表达式的方式，哪些是form，哪些是特殊语法，等等。</p>

<p>在Common Lisp中，特殊运算名的集合是固定的。没有给用户提供定义特殊运算符的方式。如下列出了所有作为特殊运算符定义的Common Lisp符号。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>block</td>
      <td>let*</td>
      <td>return-from</td>
    </tr>
    <tr>
      <td>catch</td>
      <td>load-time-value</td>
      <td>setq</td>
    </tr>
    <tr>
      <td>eval-when</td>
      <td>locally</td>
      <td>symbol-macrolet</td>
    </tr>
    <tr>
      <td>flet</td>
      <td>macrolet</td>
      <td>tagbody</td>
    </tr>
    <tr>
      <td>function</td>
      <td>multiple-value-call</td>
      <td>the</td>
    </tr>
    <tr>
      <td>go</td>
      <td>multiple-value-prog1</td>
      <td>throw</td>
    </tr>
    <tr>
      <td>if</td>
      <td>progn</td>
      <td>unwind-protect</td>
    </tr>
    <tr>
      <td>labels</td>
      <td>progv</td>
      <td> </td>
    </tr>
    <tr>
      <td>let</td>
      <td>quote</td>
      <td> </td>
    </tr>
  </tbody>
</table>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/big-data-system-2/">Lambda Architechture</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-20T17:03:39+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>5:03 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="what-is-data-system">What is Data System</h2>

<p>query = function(all data)</p>

<h2 id="section">大数据系统的要求</h2>

<p>一个数据系统，就是要向应用提供数据的存储、加工、修改和查询的系统。<a href="http://manning.com/marz/">Big Data</a>一书中，总结大数据系统必须满足如下要求：</p>

<ul>
  <li>容错性
包含两方面，物理容错性和人为容错性
    <ul>
      <li>物理容错性
由于允许数据分区，也就是分布式存储。那不可避免有些机器会宕机或者系统软件等出现故障，导致其不可访问。局部的错误，不会导致整体系统不可访问。</li>
      <li>人为容错性
程序可能有bug, 对数据进行错误的修改。那么应该有办法恢复，然后用修正后的程序重新计算。</li>
    </ul>
  </li>
  <li>
    <p>可扩展性
这是一个广泛使用，但容易引起混淆的概念。这里指的是，通过增加资源，系统在更大负载下，保持性能的能力。尽管系统有扩展性，但<strong>线性扩展性</strong>，才是有意义的。如果是与负载呈平方或者四次方的扩展性，是不实用的。</p>
  </li>
  <li>
    <p>低延迟的读或修改
绝大多数应用对于读，需要很小的延迟，在几毫米到几百毫秒。而对于修改的延迟，不同的应用要求不同，从几毫秒到几小时不等。</p>
  </li>
  <li>
    <p>普遍性(Generalization)
一个普遍的系统应能支持很大范围的应用，比如财务管理系统、社交媒体分析、科学应用、社交网络等等。</p>
  </li>
  <li>
    <p>延展性(Extensibility)
可延展的系统，允许以较小的开发成本增加新的特性或功能。</p>
  </li>
  <li>
    <p>维护最小化(Minimal maintenance)</p>

    <p>维护是对开发者收的税。维护是为了确保系统平滑运行而需要做的工作。最小化维护量的一个重要举措，是选择部署复杂度尽可能小的部件。</p>
  </li>
  <li>
    <p>可调试性(Debuggability)</p>

    <p>一个大数据系统必须在出错时，提供必要的信息来调试系统。其关键是能够追踪，对于系统中的每个值，恰恰是什么导致了这个值。</p>
  </li>
</ul>

<h2 id="lambda-">Lambda 架构</h2>

<p>本书主要是介绍Lambda架构，作为大数据的新范式，见下图：</p>

<p><img src="../images/bigdata/LambdaArchitecture.png" alt="" /></p>

<p>Lambda架构认为，</p>

<ul>
  <li>batch view = function(all data)</li>
  <li>realtime view = function(realtime view, new data)</li>
  <li>query = function(batch view. realtime view)</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/05/big-data-system-1/">Why Big Data System?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-05-08T10:38:19+08:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:38 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><a href="http://nathanmarz.com">Nathan Marz</a> 的新书 <a href="http://manning.com/marz/">Big Data</a> 对大数据系统及Lambda架构有深入和详尽的讨论。加上自己对数据库使用的多年经验和思考，准备写一组博文，作为读书笔记和思考总结。</p>

<h2 id="section">为何大数据</h2>

<p>大数据是与互联网相伴而生的。传统的应用系统和数据库，都是针对企业层面的应用，而且主要用于事务处理。企业也只是占据整个市场的一定份额，因此数据量有限。而由于网络的规模效应，在互联网上更容易产生“赢者通吃”的结果，所以互联网企业往往面对的是社会化的普遍需求，用户数、数据量和访问量都巨大。大数据表现在：</p>

<ul>
  <li>
    <p>数据量大</p>

    <p>用户数少则几百万，上千万，过亿很普遍。随着商业的繁荣、市场细分和个性化需求的挖掘，商品数SKU，经常达到几十万。日均交易上千万笔。
 搜索引擎的网页数据库，也达到几千TB。</p>
  </li>
  <li>
    <p>访问量
 无论是读取(浏览、查询)还是写入(修改、增加)</p>
  </li>
  <li>数据多样化
 除过通常的交易类数据，还有：
    <ul>
      <li>文档</li>
      <li>网页
搜索引擎的网页缓存</li>
      <li>图片
Facebook, 微信, Flickr的图片分享</li>
      <li>视频</li>
      <li>搜索引擎的索引数据库
 这些都不是RDBMS擅长管理的。</li>
    </ul>
  </li>
  <li>数据处理方式
除过事务型处理外，还有批量处理，如机器学习、在线学习、流式处理等。</li>
</ul>

<h2 id="section-1">为什么需要大数据系统</h2>

<p>大家对关系型数据库(RDBMS)并不陌生。早期的商业系统主要为了处理交易，比如银行存取款、证券交易、销售、采购、订票等。这也称为OLTP(在线事务处理)系统。其对数据操作的特点是，基于索引定位的单记录(少数记录)操作较多，读写随机，而且高并发性，数据记录的改变反映了资源的变化、状态的迁移或相关活动的触发。OLTP属于业务关键性应用，所以数据的一致性、并发控制和容错，至关重要。而RDBMS比较完美地解决了OLTP对持久化存储的需要，因而占据了主导地位。RDBMS有很多共性：</p>

<ul>
  <li>逻辑结构
    <ul>
      <li>基于关系代数的逻辑结构和建模方法</li>
      <li>SQL结构化查询语言</li>
    </ul>
  </li>
  <li>数据一致性保证
    <ul>
      <li>事务处理</li>
      <li>锁机制</li>
      <li>日志</li>
    </ul>
  </li>
  <li>容错
    <ul>
      <li>数据文件镜像</li>
      <li>备份与恢复</li>
      <li>高可用性复制</li>
    </ul>
  </li>
</ul>

<p>那么为什么会有大数据和NoSQL数据库的出现呢？这就要说到RDBMS的局限，因为它是基于关系代数设计的：</p>

<ol>
  <li>
    <p>由于关系代数强调的是遵循范式和数据一致性，所以在性能上不是最优的。数据文件存放在磁盘上，而磁盘IO速度远低于内存速度，很多数据库的优化都不得不绕过范式，实现更快的性能。</p>
  </li>
  <li>
    <p>关系性建模要求一开始就把数据模型确定下来，随后的调整很费力。但随着迭代式开发模式的普及，数据结构需具灵活性、易于调整。而且有些数据不适合以关系模型去描述，比如key-value、文档数据库等。</p>
  </li>
  <li>
    <p>对于批量处理的应用，如数据仓库、数据挖掘和机器学习等，数据库事务控制会增加很大的开销，但又不是必须的。</p>
  </li>
</ol>

<p>而且，传统的RDMBS实际上是单机系统。虽然RDMBS也有集群版本，但所有的集群必须共享一个存储源(通常是磁盘阵列)。无论有再多的服务器，RMDBS只有一个日志系统、一个统一的事务控制。就好比一个人不能有两个脑袋。从CAP定理来看，RDBMS保证了一致性(Consistency)和可用性(Availability)，但因此必须牺牲分区容受性(Patition Tolerance)。)这致使RDMBS面对大数据时，就会捉襟见肘。</p>

<ol>
  <li>
    <p>数据量的局限
互联网应用的数据达到TB、PB级，不是单机可以存储的。即便通过数据分片，将数据物理地分散在多个存储设备上，也有存储设备本身的限制。而传统的磁盘阵列价格高昂。</p>
  </li>
  <li>
    <p>吞吐量的限制
无论数据如何分散到多个存储设备，整个数据库还是有中心控制机制。这必然造成锁、消息队列等关键资源的瓶颈，限制了并发性。换言之，传统的RDBMS是中心化的设计，和去中心化设计的思路是相反的。只有去中心化后，才能实现分区化。</p>
  </li>
  <li>
    <p>应用特点不同
互联网的应用不同于OLTP的特点。一次写入，多次读出；写后一般不会修改；数据以添加的方式写入。</p>
  </li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/04/color-space/">Color Space</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-04-28T11:07:51+08:00'><span class='date'><span class='date-month'>Apr</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:07 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Primary Color
	Color, Blue, and Yellow</p>

<p>Secondary Color
	Orange, Green and Violet </p>

<p>Tertiary Color
	Red-Orange, Yellow-Orange, Yellow-Green, Blue-Green, Blue-Violet and Red-Violet</p>

<p>Neutral Color: 不带色彩的颜色。白、黑、灰</p>

<p>Achromatic color 没有色彩。它们包含：白、黑和灰。中性色改变所有色彩的密度和值。</p>

<h3 id="scheme">Scheme</h3>

<h4 id="monochromatic-color-scheme">Monochromatic Color Scheme(单色主题)</h4>
<p>由任何颜色或中性色的色泽(tint), 色调(tone)和阴影的复合。</p>

<h4 id="analogous-color-scheme">Analogous Color Scheme(相似色主题)</h4>
<p>在色轮中，相互毗邻的3组颜色组成。</p>

<h4 id="extended-analogous-color-scheme">Extended Analogous Color Scheme(扩展的相似色主题)</h4>
<p>在色轮中，相互毗邻的4组颜色组成。</p>

<h4 id="complementary-color-scheme">Complementary Color Scheme(互补色主题)</h4>
<p>在色轮中，相对的两组颜色组成。</p>

<h4 id="split-complementary-color-scheme">Split Complementary Color Scheme(分离互补色主题)</h4>
<p>由一组颜色与它相对处毗邻的两组颜色组成。</p>

<h4 id="triadic-color-scheme">Triadic Color Scheme(三色系主题)</h4>
<p>由色轮中等距相隔的三组颜色组成。</p>

<h4 id="section">对比色</h4>

<h3 id="hsv">HSV</h3>

<ul>
  <li>Value(颜色值)：指一个颜色的相对亮度(brightness)或暗度。</li>
  <li>Saturation(or purity, 饱和度或纯度)：描述一个颜色有多纯。一个纯粹的颜色是干净而明亮的(clear and bright)，增加黑让它变模糊和暗(muddy and dark)，给它一个阴影。加白让颜色被冲洗(washed out)或着色(tinted)。</li>
</ul>

<h3 id="section-1">色温</h3>
<p>颜色可以分为两类：</p>

<ul>
  <li>暖色(aggressive, 前进色)：红、黄、棕</li>
  <li>冷色(receding, 后退色)：绿、蓝、紫</li>
</ul>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/the-art-of-interpreter-ii/">The Art of Interpreter II</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/the-art-of-interpreter-i/">The Art of Interpreter I</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/haskell-resources/">Haskell Resources</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/implementing-arithmetic-in-lisp/">在Lisp中实现算术</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/the-roots-of-lisp/">LISP的根本</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Steven Liu <stevenliucx@gmail.com> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
