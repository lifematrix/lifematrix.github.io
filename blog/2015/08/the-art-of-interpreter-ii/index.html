
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>The Art of Interpreter II - Life Matrix</title>
  <meta name="author" content="Steven Liu <stevenliucx@gmail.com>&#8221;>

  
  <meta name="description" content="第零部分： LISP和解释器
Part Zero LISP and Interpreters 递归方程
Recursion Equations Contrary to popular belief, LISP was not originally derived from
Church’s λ— &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-ii">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Life Matrix" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       jax: ["input/TeX", "output/HTML-CSS"],
       tex2jax: {
          inlineMath: [ ['$', '$'] ],
          displayMath: [ ['$$', '$$']],
          procehssEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       },
       messageStyle: "none",
       "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
     });
   </script>
   <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Life Matrix</a></h1>
  
    <h2>Hacking, Machine learning</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hack.the-lifematrix.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/resources">Resources</a></li>
  <li><a href="/lisp-resource">Lisp Resource</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">The Art of Interpreter II</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-18T16:52:51+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:52 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3 id="lisp">第零部分： LISP和解释器</h3>
<p>Part Zero 
LISP and Interpreters</p>

<h4 id="section">递归方程</h4>
<p>Recursion Equations</p>

<p>Contrary to popular belief, LISP was not originally derived from
Church’s λ—calculus [Church] [LISP History]. The earliest LISP did not
have a well—defined notion of free variables or procedural objects. Early
LISP programs were similar to recursion equations, defining functions on
symbolic expressions (“S—expressions”). They differed from the equations
of pure recursive function theory [Kleene] by introducing the conditional
expression construction (often called the “McCarthy conditional”), to avoid
“pattern-directed invocation”. That is, in recursive function theory one
would define the factorial function by the following two equations:</p>

<p>与流行的说法相反，LISP最初不是从邱奇的λ演算中派生出来的。最早的LISP没有一个对自由变量和过程对象的良好定义的记号。早期的LISP程序与递归方程类似，在符号表达式(“S-expressions”)上定义函数。他们不同于纯粹递归函数理论公式，是在于引入了条件表达式构造(经常称为”McCarthy条件”)，从而避免“模式导向的调用”。也就是，在递归函数理论中，可以通过如下两个方程定义阶乘函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factorial(0) = 1
</span><span class="line">factoria1(successor(x)) = successor(x) * factorial(x)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In early LISP, however, one would have written:</p>

<p>但是在早期的LISP中，需要写成这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factoria1[x] = [x=0 -&gt; 1; T -&gt; x*factorial[x-1]]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where “[a -&gt; b; T —&gt; c]” essentially means “if a then b else c”. The
recursive function theory version depends on selecting which of two
equations to use by matching the argument to the left-hand sides (such a
discipline is actually used in the PROLOG language [Warren]); the early
LISP version represents this decision as a conditional expression.</p>

<p>这里 [a -&gt; b; T —&gt; c] 根本上意指 “如果a就b，或者c”。这个递归函数理论的版本在于，通过将参数匹配到左侧(这样的规则的确在PROLOG语言中用到)，来选择要使用哪个公式；早期的LISP版本将这个决策表示为一个条件表达式。</p>

<p>The theory of recursion equations deals with functions over the
natural numbers. In LISP, however, one is interested in being able to manipulate algebraic expressions, programs, and other symbolic expressions
as data structures. While such expressions can be encoded as numbers
(using the technique of “arithmetization” developed by Kurt Godel), such an
encoding is not very convenient. Instead, a new kind of data called “S-
expressions” .(for “symbolic expressions”) is introduced specifically to
provide convenient encodings. S-expressions can be defined by a set of
formal inductive axioms analogous to the Peano Postulates used to define
natural numbers. Here we will give only an informal and incomplete definition of S—expressions; for a more complete description, see {Note S-
expression Postulates and Notation}.</p>

<p>递归公式处理自然数的函数。然而，在LISP里，人们的兴趣在于能够操作代数表达式、程序和如数据结构一样的符号表达式。虽然这样的表达式能用数字编码(使用Kurt Godel开发的”算术化“技术)，但这样的编码不是很方便。相反，一种称为”S表达式“(即：符号化表达式, symbolic expression)的新的类型的数据被特别引入进来，为了提供方便的编码。S-表达式能通过一组正规的归纳公理来定义，它与Peano假定用以定义自然数的类似。这里，我们仅给出一个非正规和不完备的S表达式定义；对于一个更为完备的描述，请看注释{Note S-
expression Postulates and Notation}。</p>

<p>For our purposes we will need only the special cases of S-expressions called atoms and lists. An atom is an “indivisible” data object, which we denote by writing a string of letters and digits; if only digits are used, then the atom is considered to be a number. Many special characters such as “-“ and “+” are considered to be letters; we will see below that it is not necessary to specially reserve them for use as operator symbols. A list is a (possibly empty) sequence of S—expressions, notated by writing the S—expressions in order, between a set of parentheses and separated by spaces. A list of the atoms “F00”, “43”, and “BAR” would be written “(F00 43 BAR)”. Notice that the definition of a list is
recursive. For example,</p>

<p>对于我们的目的，我们只需要S表达式特殊的情形，称为atom和list。一个“原子”是不可分割的数字对象，我们表示为字母和数字的串；如果只用到数字，那么原子就被认为是数字。许多特殊的字符，比如”-“和”+“，被认为是字母；我们将在后面看到，没有必要特别地将它们保留下来作为操作符号。一个列表是S表达式的序列(可能是空的)，表示为按顺序写S表达式，用空格分开，在一组括号中间。原子”F00”, “43”和”BAR”的列表写为”(FOO 43 BA)”。注意列表的定义是递归的。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (SECOND X) (CAR (CUR X)))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>is a list of three things: the atomic symbol DEFINE, a list of the two
atomic symbols SECOND and X, and another list of two other things.</p>

<p>是有3个事物的列表：原子符号 DEFINE，一个有两个原子符号SECOND和X的列表，和另一个列表，它包含两个其它事物。</p>

<p>We can use S-expressions to represent algebraic expressions by
using “Cambridge Polish” notation, essentially a parenthesized version of
prefix Polish notation. Numeric constants are encoded as numeric atoms;
variables are encoded as non—numeric atoms (which henceforth we will call
atomic symbols); and procedure invocations are encoded as lists, where the
first element of the list represents the procedure and the rest represent
the arguments. For example, the algebraic expression “a<em>b+c</em>d” can be
represented as “(+ (* a b) (* c d))”. Notice that LISP does not need the
usual precedence rules concerning whether multiplication or addition is
performed first; the parentheses explicitly define the order. Also, all
procedure invocations have a uniform syntax, no matter how many arguments
are involved. Infix, superscript, and subscript notations are not used;
thus the expression “$J_p (x^2+1)$” would be written “(J p (+ (^ x 2) 1))”.</p>

<p>我们通过使用”剑桥波兰“记号来表示代数表达式，它本质上是加括号的前缀波兰版本。数字常数被编码为数字原子；变量被编码为非数字的原子(今后我们将称其为原子符号)；一个过程的调用被编码为列表，其中列表的第一个元素代表过程，剩余的部分代表参数。例如，代数表达式”a<em>b+c</em>d”可以表示为”(+ (* a b) (* c d))”。注意LISP不需要通常的优先级规则，比如先执行乘法还是加法；括号已经显式地定义了次序。而且，所有的过程调用有一致的语法，无论有多少个参数。没有用到，中缀、上标或下标：因此表达式”$J_p (x_2+1)$”，将被写成”(J p (+ (^ x 2)1))”。</p>

<p>To encode a conditional expression：</p>

<p>为了编码一个条件表达式：</p>

<script type="math/tex; mode=display">[p_1 -> e_1; p_2 -> e_2; ... ; p_n -> e_n]</script>

<p>(which means to evaluate the predicates p_i in order until a true one is found, at which point the value of $e_j$ is taken to be the value of the
conditional) we write the S-expression</p>

<p>其含义是对判定式p_i按顺序求值，直到发现一个为真，此时$e_j$会被取出作为条件的值。我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(COND (p_1 e_1) (p_2 e_2) ... (p_n e_n))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we can now encode sets of LISP recursion equations as S-expressions. For the equation</p>

<p>我们能将一组LISP递归等式编码为S表达式的形式。对于等式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">factoria1[x] = [x=0 -&gt; 1; T -&gt; x*factoria1[x-1]]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we write the S-expression</p>

<p>我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (FACTORIAL x)
</span><span class="line">	(COND ((= X 0) 1)
</span><span class="line">		  (T (* x (FACTORIAL (- x 1))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(we could also have written</p>

<p>(我们也能写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (FACTORIAL X) (cond ((=
</span><span class="line">x 0) 1) (T (* x (FACTORIAL (- x
</span><span class="line">1))))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>but we conventionally lay out S-expressions so that they are easy to read.)</p>

<p>但是我们习惯上会排版S表达式以便易于阅读。</p>

<p>We now have a complete encoding for algebraic expressions and LISP
recursion equations in the form of S-expressions. Suppose that we now want
to write a LISP program which will take such an S-expression and perform
some useful operation on it, such as determining the value of an algebraic
expression. We need some procedures for distinguishing, decomposing, and
constructing S-expressions.</p>

<p>我们现在已经有了对代数表达式的完整编码，以及S表达式的形式下的递归等式。假设我们现在想写一个LISP程序，它能拿起这样的S表达式并对其执行一些有用的操作，比如确定代数表达式的值。我们需要一些过程来区分、分解、构造S表达式。</p>

<p>The predicate ATOM, when applied to an S-expression, produces true
when given an atom and false otherwise. The empty list is considered to be
an atom. The predicate NULL is true of only the empty list; its argument
need not be a list, but may be any S-expression. The predicate NUMBERP is
true of numbers and false of atomic symbols and lists. The predicate EQ,
when applied to two atomic symbols, is true if the two atomic symbols are
identical. It is false when applied to an atomic symbol and any other S-
expression. (We have not defined EQ on two lists yet; this will not
become important, or even meaningful, until we discuss side effects.)</p>

<p>断言ATOM，当应用到S表达式上，如果给的是原子，则产生真，否则为假。空列表被认为是一个原子。断言NULL只有对空列表是为真；它的参数不必要是列表，可以是任何表达式。当一个原则符号和列表是数字时，断言NUMBERP是真，否则为假。断言EQ，当应用到两个原子符号时，如果两个原子符号相等，则为真。如果应用到一个原子符号，和任何其他S表达式上，则为假。(我们还没有定义两个列表的EQ；这将不那么重要，或甚至有意义，直到我们讨论副作用。)</p>

<p>The decomposition operators for lists are traditionally called CAR
and CDR for historical reasons. [LISP History] CAR extracts the first
element of a list, while CDR produces a list containing all elements but
the first. Because compositions of CAR and CDR are commonly used in LISP,
an abbreviation is provided: all the C’s and R’s in the middle can be
squeezed out. For example, ‘(CDR (CDR (CAR (CDR X))))’ can be written as
“(CDDADR X)”.</p>

<p>由于历史的原因，列表的分解操作符传统上被称为car和cdr。[LISP History] CAR提取列表的第一个元素，而CDR生成一个除过第一个元素之外的所有剩余元素的列表。因为car和cdr的组合在LISP中经常用到，就提供了一个缩写：所有中间的C和R可以积压出去。例如’(CDR (CDR (CAR (CDR X))))’，可以写为”(CDDADR X)”。</p>

<p>The construction operator CONS, given an S-expression and a list,
produces a new list whose CAR is the S-expression and whose CDR is the
list. The operator LIST can take any number of arguments (a special
feature), and produces a list of its arguments.</p>

<p>构造操作符CONS，给定S表达式和一个列表，生成一个新的列表，其CAR是S表达式，而CDR是列表。操作符LIST能接收任意数目的参数(一个特殊特性)，然后产生这些参数的列表。</p>

<p>We can now write some interesting programs in LISP to deal with S-expressions. For example, we can write a predicate EQUAL, which determines whether two S-expressions have the same CAR-CDR structure:</p>

<p>我们现在可用LISP写一些有趣的程序，来处理S表达式。例如，我们写一个断言EQUAL, 它确定两个S表达式有相同的CAR-CDR结构。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (EQUAL X Y)
</span><span class="line">          (COND ((NUMBERP X)
</span><span class="line">                 (COND ((NUMBERP Y) (= X Y))
</span><span class="line">                       (T NIL)))
</span><span class="line">                ((ATOM X) (EQ X Y))
</span><span class="line">                ((ATOM Y) NIL)
</span><span class="line">                ((EQUAL (CAR X) (CAR Y)) 
</span><span class="line">                 (EQUAL (CDR X) (CDR Y)))))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we have used the standard names T and NIL to represent ture and false.
(Traditionally NIL is also considered to be the empty list, but we will
avoid this here, writing “()” for the empty list.)</p>

<p>这里我们使用标准的名字T和NIL来表示和false。(传统上，NIL也被认为是空列表，但是我们将在这里避免这些，写”()”代表空列表)。</p>

<p>Because LISP programs are represented as LISP data structures (S-expressions), there is a difficulty with representing constants. For
example, suppose we want to determine whether or not the value of the
variable X is the atomic symbol “FOO”. we might try writing:</p>

<p>因为LISP程序表示为LISP数据结构(S表达式)，在表达常量时有些困难。比如，假设我们想确定变量X的值是否为原子符号”F00”，我们可能试图写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQ X FOO)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This doesn’t work. The occurrence of “FOO” does not refer to the atomic
symbol FOO as a constant; it is treated as a variable, just as “X” is.</p>

<p>这不能奏效。FOO的出现没有将FOO引用为一个常量；它被看做一个变量，如同X一样。</p>

<p>The essential problem is that we want to be able to write any 5-
expression as a constant in a program, but some S—expressions must be used
to represent other things, such as variables and procedure invocations. To
solve this problem we invent a new notation: (QUOTE X) in a program
represents the constant S-expression x. {Note QUOTE Mapping} Thus we can
write our test as “(EQ X (QUOTE FOO)”. Similarly,</p>

<p>本质的问题是，我们想能够在程序中将任何S表达式按照常量的方式书写，但是一些S表达式必须被用来表示其它一些，比如变量和过程调用。为了解决这个问题，我们发明了一个新记号：(QUOTE X)在程序中表示常数S表达式X。{注释： QUOTE Mapping} 因此我们能将我们的测试写为：(EQ X (QUOTE FOO)。类似的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQUAL X (LIST Y Z))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>constructs a list from the values of Y and z, and compares the result to
the value of X, while</p>

<p>从X和Y的值中构造一个列表，然后将结果与X的值比较，而：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(EQUAL X (QUOTE (LIST Y Z)))</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>compares the value of X to the constant S-expression “(LIST Y Z)”. Because
the QUOTE construction is used so frequently in LISP, we use an abbreviated
notation: “‘FOO” is equivalent to “(QUOTE FOO)”. This is only a notational
convenience; the two notations denote the same S-expression. (S-
expressions are not character strings, but data objects with a certain
structure. We use character strings to notate S-expressions on paper, but
we can use other notations as well, such as little boxes and arrows. We 
can and do allow several different character strings to denote the same S-
expression.) </p>

<p>将X的值与常数表达式(LIST Y Z)去比较。因为在LISP中QUOTE构造经常被用到，我们使用一个缩写记号：”’FOO”等价于”(QUOTE FOO)”。这只是一个记号的惯例。两个记号表示相同的S表达式。(S表达式不是字符串，而是带有特定结构的数据对象。我们使用字符串去表示文章中的S表达式。我们能够且也允许几种不同的字符串去表示相同的S表达式)。</p>

<h4 id="lisp-">LISP 递归等式的解释器</h4>
<p>An Interpreter for LISP Recursion Equations</p>

<p>We now have enough machinery to begin our examination of the
genetic history of LISP. We first present a complete interpreter for LISP
recursion equations. The language interpreted is a dialect of LISP which
allows no free variables except for names of primitive or defined
procedures, and no definitions of procedures within other procedures.</p>

<p>我们现在有足够的机制去开始对LISP起源历史的检视。我们首先展现一个LISP递归等式的完全解释器。被解释的语言是LISP的一个方案，它不允许自由变量，除过原语或已定义过程的名字，在别的过程中没有过程的定义。</p>

<p>The driver loop reads in definitions of procedures of the form:</p>

<p>驱动循环的读取 form的过程定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">(DEFINE (F A B C ...) &lt;expression in A B C ... and F G H ...&gt;)</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and saves them. It can also read in requests to apply some defined
procedure to some arguments (or, more generally, to evaluate any
expression), in which case it prints the resulting value. An expression
may consist of variable references, constants (numbers and quoted s-
expressions), procedure calls, and conditional expressions (COND). The
defined procedures may refer to each other and to initially supplied
primitive procedures (such as CAR, CONS, etc.). Definitions may contain
“forward references”, as long as all necessary definitions are present at
the time of a request for a computation. The interpreter itself is
presented here as a set of such definitions, and so is meta—circular.</p>

<p>并保存它们。它也能读入请求去将一些定义的过程应用到一些参数(或者，更通常，去求值任意表达式)，在这种情况下它打印结果值。一个表达式可以包含变量引用，常数(数字和引号的S-表达式)，过程调用和条件表达式。被定义的过程可能相互引用，并引用到初始提供的原语过程(比如CAR, CONS，等等)。定义可能包括“向前引用”，只要所有必须的定义在请求计算的那一刻是存在的。这呈现的解释器自身是一组如此的定义，也就是元循环。</p>

<p>The language is intended to be evaluated in applicative order; that is, all arguments to a procedure are fully evaluated before an attempt
is made to apply the procedure to the arguments. (It is necessary to state
this explicitly here, as it is not inherent in the form of the meta-circular definition. See [Reynolds] for an explication of this problem.)</p>

<p>The driver loop (see Figure 1) is conceptually started by a request
to invoke DRIVER with no arguments. Its task is to first print the message
“LITHP ITH LITHTENING” (a tradition of sorts) and then invoke DRIVER—LOOP.
The expression &lt;THE-PRIMITIVE-PROCEDURES) is intended to represent a constant
list structure, containing definitions of primitive procedures, to be
supplied to DRIVER—LO0P.</p>

<p>(DEFINE (DRIVER)
(DRIVER-LOOP (THE-PRIMITIVE—PROCEDURES) (PRINT ‘|LITHP ITH LITHTENlNG|)))</p>

<p>(DEFINE (DRIVER—LO0P PROCEDURES HUNOZ)
(DRIVER—LOOP—l PROCEDURES (READ)))</p>

<p>(DEFINE (DRIVER-LOOP-1 PROCEDURES FORM)
(COND ((ATOM FORM)
(DRIVER-LOOP PROCEDURES (PRINT (EVAL FORM ‘() PROCEDURES))))
((EO (CAR FORM) ‘DEFINE)
(DRIVER-LOOP (BIND (LIST (CAADR FORM))
(LIST (LIST (CDADR FORM) (CADDR FORM)))
PROCEDURES)
(PRINT (CAADR FORM))))
(T (DRIVER-LOOP PROCEDURES (PRINT (EVAL FORM ‘() PROCEDURES))))))</p>

<p>Figure 1
Top Level Driver Loop for a Recursion Equations Interpreter</p>

<p>DRIVER-LOOP reads an S—expression from the input stream and passes
it, along with the current procedure definitions, to DRIVER-LOOP-1. This
procedure in turn determines whether the input S-expression is a</p>

<p>definition. If it is, then it uses amp (described below) to produce an_</p>

<p>augmented set of procedure definitions, prints the name of the defined
procedure, and calls DRIVER-LOOP to repeat the process. The augmented set of
procedures is passed to DRIVER-LOOP, and so the variable PROCEDURES always
contains all the accumulated definitions ever read. If the input S-
expression is not a definition, then it is given to the evaluator EVAL,
whose purpose is) to determine the values of expressions. {Note Value
Quibble) The set of currently defined procedures is also passed to EVAL.</p>

<p>The process carried on by the driver loop is often called the “top
level”;— all user programs and requests are run‘ “under” it. The growing</p>

<p>set of procedure definitions is called the “top—level environment”; this _</p>

<p>environment changes in the course of the user interaction, and contains the
state of the machine as perceived by the user._ It is within this
environment that user programs are executed. ‘
Steele and Sussman 9 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__E</strong>__</p>

<p>(DEFINE (EVAL EXP ENV PROCEDURES)
(coND ((ATOM EXP)
(COND ((Eo EXP ‘NlL) ‘NIL)</p>

<p>((Eo EXP ‘7) ‘1)
((NUMBERP EXP) EXP)
(T (vALDE EXP ENV))))</p>

<p>((Eo (cAR ExP) ‘QUOTE)</p>

<p>(CADR ExP))</p>

<p>((EQ (cAR EXP) ‘COND)</p>

<p>(EVCOND (cDR EXP) ENV PRocEDuREs))
(T (APPLY (VALUE (CAR EXP) PROCEDURES)
(EVLIS (cDR EXP) ENV PROCEDURES)
PRocEDuREs))))</p>

<p>(DEFINE (APPLY FUN ARGS PRocEDuREs)
(COND ((PRlMOP FUN) (PRIMOP-APPLY FUN ARes))
(T (EVAL (CADR FUN)
(BIND (cAR FUN) ARGS ‘())
PRocEDuREs))))</p>

<p>(DEFINE (EVCOND CLAUSES ENV PROCEDURED)
(COND ((NULL CLAUSES) (ERROR))
((EVAL (CAAR CLAUSES) ENV PROCEDURES)
(EVAL (CADAR CLAUSES) ENV PROCEDURES))
(T (EVCOND (COR CLAUSES) ENV PROCEDURES))))</p>

<p>(DEFINE (EVLIS ARGLIST ENV PROCEDURES)
(COND ((NULL ARGLIST) ‘())
(T (CONS (EVAL (CAR ARGLIST) ENV PROCEDURES)
(EVLIS (CDR ARGLIST) ENV PROCEDURES)))))</p>

<p>Figure 2
Evaluator for a Recursion Equations Interpreter</p>

<p>The evaluator proper (see Figure 2) is divided into two conceptual
components: EvAL and APHX. EVAL classifies expressions and directs their
evaluation. Simple expressions (such as constants and variables) can be
evaluated directly. For the complex case of procedure invocations
(technically called “combinations”), EVAL looks up the procedure
definition, recursively evaluates the arguments (using EVLIS), and then
calls APPLY. APPLY classifies procedures and directs their application.
Simple procedures (primitive operators) are applied directly. For the
Complex case of user-defined procedures, ANY uses DIND to build an
environment, a kind of symbol table, associating the formal parameters from
the procedure definition with the actual argument values provided by EVAL.
The body of the procedure definition is then passed to EVAL, along with the
environment just constructed, which is used to determine the values of
Steele and Sussman ‘ ‘ 10 The Art of the Inter reter</p>

<p>variables occurring in the body.</p>

<p>In more detail, EvAL is a case analysis on the structure of the S-
expression EXP. If it is an atom, there are several subcases. The special
atoms T and NIL are defined to evaluate to T and NIL (this is strictly for
convenience, because they are used as truth values). Similarly, for
convenience numeric atoms evaluate to themselves. (These cases could be
eliminated by requiring the user to write lots of QUOTE forms: ‘T, ‘N1L,
‘43, etc. This would have been quite inconvenient in early LISP, before
the “”” notation had been introduced; one would have had to write (QUOTE
43), etc.) Atomic symbols, however, encode variables; the value
associated with that symbol is extracted from the environment Euy using the
function VALUE (see below). - .</p>

<p>If the expression to be evaluated is not atomic, then it may be a
QUOTE form, a coup form, or a combination. For a Quote: form, EVAL extracts
the S-expression constant using CADR. Conditionals are handled by -EVCOND,
which calls EVAL on a predicate expression; if the predicate is true,
EVCOND evaluates the corresponding result expression (by calling EVAL, of</p>

<p>course); if the predicate is false, EVCOND calls itself to test the”</p>

<p>predicate of the next clause of the COND body. For combinations, the
procedure is obtained, the arguments evaluated (using EvL1s), and APPLY
called as described earlier. Notice that VALUE is used to get the
procedure definition from the set PROCEDURES; we can do this because, as an</p>

<p>engineering trick, we arrange for ENV and PROCEDURES to have the same
structure, because they are both symbol tables.</p>

<p>EVLIS is a simple recursive function which calls EVAL on successive
arguments in ARGLIST and produces a list of the values in order.</p>

<p>APPLY distinguishes two kinds of procedures: primitive and user-
defined. For now we avoid describing the precise implementation of
primitive procedures by assuming the existence of a predicate PRIMOP which
is true only of primitive procedures, and a function PRmoP-APPLY which deals
with the application of such primitive procedures. (See’{Note Primitive
Operators} for the details of a possible implementation of PRIMOP and PRmoP-
APPLY.) we consider primitive procedures to be a kind of atomic S-
expression other-than numbers and atomic symbols; we define no particular
written notation for them here. However, primitive procedures are not to
be confused with the atomic symbols used as their names. The result of
(VALUE ‘CAR PROCEDURES) is not the atomic symbol CAR, but rather some bizarre
object which is meaningful only to PRIMOP-APPLY.</p>

<p>User-defined procedures are represented here as lists. These lists</p>

<p>are constructed by DRIVER-LOOP-1. The car of the list is the list of formal
parameters, and the cadr is the body of the definition.
Steele and Sussman 11 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong><em>~</em></strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__E</strong>___</p>

<p>(DEFINE (BIND VARS ARGS ENV)
(COND ((= (LENGTH VARS) (LENGTH ARGS))
(CONS (CONS VARS ARGS) ENV))
(T (ERROR))))</p>

<p>(DEFINE (VALUE NAME ENV)
‘ (VALUEI NAME (LOOKUP NAME ENv)))</p>

<p>(DEFINE (VALUEI NAME SLOT)
(CQND ((E0 SLOT ‘&amp;UNBOUND) (ERROR))
(T (CAR SLOT))))</p>

<p>(DEFINE (LOOKUP NAME ENv)
(coND ((NULL ENv) ‘&amp;UNBOUND)
(T (LOOKUPI NAME (CAAR ENv) (CDAR ENv) ENV))))</p>

<p>(DEFINE (LOOKUPI NAME VARS vALs ENv)
(COND ((NULL VARS) (LOOKUP NAME (con ENV)))
((EQ NAME (CAR VARS)) vALs)
(T (LOOKUPI NAME (con VARS) (con VALS) ENV))))</p>

<p>Figure 3
Utility Routines for Maintaining Environments</p>

<p>The interpreter uses several utility procedures for maintaining
symbol tables (see Figure 3). A symbol table is represented as a list of
buckets; each bucket is a list whose car is a list of names and whose cdr
is a list of corresponding values. {Note This ain’t A—lists} If a variable
name occurs in more than one bucket. the leftmost such bucket has priority;
in this way new symbol defnntions added to the front of the list can
supersede old ones.</p>

<p>BIND takes a list of names, a list of values, and a symbol table,
and produces a new symbol table which is the old one augmented by an extra
bucket containing the new set of associations. (It‘also performs a useful
error check —-LENGTH returns the length of a list.)</p>

<p>VMDE is essentially an interface to Loomw. we define it because
later. in Part Three, we will want to use different versions of- vALuE1</p>

<p>without changing the underlying algorithm in Loomw. The check for &amp;UNBOUND
catches incorrect references to undefined variables.</p>

<p>Loomw takes a name and a symbol table, and returns that portion off</p>

<p>a bucket whose car is the associated value. (This definition will be more
useful later than one in which the value itself is returned.)</p>

<p>Note carefully the use of the variable PmmEmmEs in the
interpreter. when omvERlomL1 calls EVM_ it passes the current list of
defined procedures (both primitive and user-defined). DRIvEm¢ooP-1 is the
only routine which augments the value of PmmEmmEs, and this value is only
Steele and Sussman 12 The Art of the Inter reter</p>

<p>used in EVAL, when it is passed to VALUE. However, a_l_l of the routines
APPLY, evconp, and evus have to know about PROCEDURES, and dutifully pass it
along so that it may be eventually used by EVAL. The set of definitions
must be passed along because there is no provision for free variables or
side effects; there is no way to have “memory” or “state” other than in
passed variables. The absence of free variables effectively causes our
language to be referentially transparent. However, we sense a disturbing
lack of modularity in the use of PROCEDURES (and, to a lesser extent, in the
use of ENV — look at cvcorm and EVLI‘S). we will return to this point later.</p>

<p>Our recursion equations language has no special iteration or
looping constructs, such as the Algol for statement or the FORTRAN D0 loop.
All loops are constructed by arranging for recursive procedures to call
themselves or each other. For example, EVCOND (see Figure 2) iterates over
the clauses of a couo by calling itself on successive “tails” of the list
of clauses. Now such recursive calls may strike the reader familiar with
other languages (such as Algol, FORTRAN, PL/I, etc.) on an intuitive level
as being rather inefficient for implementing real programs. Even granted
that calls might be made fast, they would seem to consume space in the form
of return addresses and other control information. Examination of the
recursion equations evaluator will show, however, that this phenomenon does
not have to occur. This is because no extra information is saved if there
is nothing left to do on return from a recursive call. See [SCHEME] and
[Debunking] for a more thorough discussion of this.
Steele and Sussman 13 I The Art of the Inter reter
<strong><em>.</em></strong><strong>__</strong>~<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><em>£</em>___</p>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Steven Liu <stevenliucx@gmail.com></span></span>

      




<time class='entry-date' datetime='2015-08-18T16:52:51+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:52 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-ii/" data-via="" data-counturl="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-ii/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/08/the-art-of-interpreter-i/" title="Previous Post: The Art of Interpreter I">&laquo; The Art of Interpreter I</a>
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/08/the-art-of-interpreter-ii/">The Art of Interpreter II</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/the-art-of-interpreter-i/">The Art of Interpreter I</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/08/haskell-resources/">Haskell Resources</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/implementing-arithmetic-in-lisp/">在Lisp中实现算术</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/the-roots-of-lisp/">LISP的根本</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Steven Liu <stevenliucx@gmail.com> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
