
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>LISP的基础 - Life Matrix</title>
  <meta name="author" content="Steven Liu <stevenliucx@gmail.com>&#8221;>

  
  <meta name="description" content="前言
《黑客与画家》的作者Paul Graham极力推崇Lisp，并使用Lisp获得了巨大的商业成功。他也写了一篇《The roots of Lisp》(postscript文件)来介绍Lisp。本文是其文章内容的学习和理解，再加上Lisp Manual 1.5的内容。 Lisp的伟大之处， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hack.the-lifematrix.net/blog/2015/07/the-roots-of-lisp">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Life Matrix" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       jax: ["input/TeX", "output/HTML-CSS"],
       tex2jax: {
          inlineMath: [ ['$', '$'] ],
          displayMath: [ ['$$', '$$']],
          procehssEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       },
       messageStyle: "none",
       "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
     });
   </script>
   <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Life Matrix</a></h1>
  
    <h2>Hacking, Machine learning</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hack.the-lifematrix.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/resources">Resources</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">LISP的基础</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-14T14:30:54+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:30 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><h3 id="section">前言</h3>
<p>《黑客与画家》的作者Paul Graham极力推崇Lisp，并使用Lisp获得了巨大的商业成功。他也写了一篇<a href="http://ep.yimg.com/ty/cdn/paulgraham/jmc.ps">《The roots of Lisp》</a>(postscript文件)来介绍Lisp。本文是其文章内容的学习和理解，再加上Lisp Manual 1.5的内容。</p>

<hr />

<p>Lisp的伟大之处，在于John McCarthy采用了类似于欧氏几何的公理化体系。欧氏几何通过几个简单的公理，借助逻辑推演，构建了整个几何体系。其结构之整洁、推理之严密，有一种深深的数学之美和逻辑的力量。MaCarthy在1960年的文章中展示了，如何通过少数几个简单的运算符和函数定义的记号，就可以构建整个编程语言。这个语言被称为Lisp，即列表处理(List Processing的意思)。而列表是表达数据和代码的一种简单数据结构。</p>

<p>值得去理解，McCarthy所发现的，不仅仅是计算机历史上的地标，而且是在今天我们的时代里，编程发展所趋向成为的一个模型。迄今为止，存在两个真正干净、一致的编程模型：C模型和Lisp模型。这两个是平地上的高点，在其之间是沼泽地带。随着计算机变得更为强大，正在开发的新语言正稳定地向Lisp模型靠拢。在过去20年中新编程语言的流行配方是采用C计算模型，然后从Lisp模型中抓取一点诸如运行时类型、垃圾回收等零碎的东西，加到里面。</p>

<p>本文将解释McCarthy发现的最简单的术语。要点不是仅仅学会一个40年前就有人弄明白的有趣的理论结果，而是去看看语言朝哪方面去发展。事实上，关于Lisp不寻常的事 - Lisp决定性的品质，是它是用自身写成的。为了理解McCarthy想说明的意思，我们将追溯他的脚步，将他的数学符号转译为可运行的Common Lisp代码。</p>

<h3 id="symbolic-expressions">符号性表达式(Symbolic Expressions)</h3>

<p><em>注：本节是由译者添附，内容来自<a href="http://en.wikipedia.org/wiki/S-expression">http://en.wikipedia.org/wiki/S-expression</a>，先交代基本概念，便于理解</em></p>

<p>符号表达式，即S表达式中最基本的类型，是原子。</p>

<p><strong>原子</strong>符号，是由字母和数字组成的字符串。其首字符必须字母。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">a</span>
</span><span class="line"><span class="nv">abc</span>
</span><span class="line"><span class="nv">a123</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一个S表达式，可以递归地定义为：</p>

<ol>
  <li>一个原子</li>
  <li>形式为(X . Y)的表达式，其中X和Y都是S表达式</li>
</ol>

<p>例如： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">foo</span> <span class="o">.</span> <span class="p">(</span><span class="nv">bar</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更方便的是将列表写成不带点记号的任意长度的列表：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它等价于 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">e</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有过编程经验的朋友，会觉得List貌似和数组类似。其实不然。List的长度不固定，它是一种递归结构。在计算机内部的List结构是：</p>

<p><img src="http://hack.the-lifematrix.net/images/lisp/list_structure.png" alt="" /></p>

<p><em>注：此图来自Lisp Manual 1.5</em></p>

<h3 id="seven-primitive-operators">7个原语操作符(Seven Primitive Operators)</h3>

<p>在算术中，表达式1+1的值是2。合法的Lisp表达式也有值。如果一个表达式$e$有个值$v$，我们说$e$返回$v$。</p>

<p>如果一个表达式是一个列表，我们称其第一个元素为操作符，剩下的为参数。我们将定义7个原语操作符：quote, atom, eq, car, cdr, cons 和 cond。</p>

<p>*注：如下代码均在GNU CLISP 2.49下调试通过，CLISP内部会将符号转换为大写，所以输出时会是大写的符号。这和The roots of Lisp原文的代码输出，略有不同 *</p>

<p>1.(quote A)返回$A$, 为了可读性，我们将(quote A)缩写为’A</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="ss">&#39;a</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2.(atom x)返回原子t，如果x是原子，否则返回空列表。在Lisp中我们用atom t代表布尔值的真值，用NIL或空列表代表假值。二者是一回事。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="err">􏰛</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">()</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们有了一个运算符，它的参数会被求值。我们可以看看quote针对什么。一个未被引用的列表，作为参数传给atom这样的运算符，其代码是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>通过引用一个列表，我们可以避免它被求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这对应我们在英语中使用引用的方式。Cambridge是麻省的一个镇，有9万人。而“Cambridge”是有9个字母的单词。</p>

<p>引用是可能看似陌生的概念，因为很少有其它语言具有任何类似的东西。它与Lisp最引人注目的特性联系在一起：<strong>代码和数据都由相同的数据结构产生出来，而引用操作符是我们区分它们的方式</strong>。</p>

<p>3.(eq x y)返回t，如果x, y的值是相同的原子，或者二者是空列表。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.(car x)期待x的值是一个列表，并返回它的第一个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="nv">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.(cdr x)期待x的值是一个列表，并返回它除过第一个元素之外的所有部分。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6.(cons x y) 期待y的值是一个列表，返回一个列表，其第一个元素是x的值，而后是y的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>7.(cond ($p_1$ $e_1$) … ($p_n$ $e_n$))的求值如下：表达式$p$会按顺序求值，直到遇到一个为真。当这个表达式找到后，对应的表达式$e$的值，就会被返回作为整个cond表达式的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="ss">&#39;first</span><span class="p">)</span>
</span><span class="line">            <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;second</span><span class="p">))</span>
</span><span class="line"><span class="nv">SECOND</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这七个操作符原语的后5个，当对这个操作符开始的表达式求值时，参数总是会被求值。我们称这样的操作符，为<strong>函数</strong>。</p>

<h3 id="denoting-function">2. 函数的表示(denoting function)</h3>

<p>接着我们来定义一个记号来描述函数。一个函数被表达为 (lambda ($p_1$ … $p_n$) $e$), 这里$p_1$ … $p_n$ 是原子(被称为参数），而$e$是一个表达式。一个这样的表达式，</p>

<p>((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>被称为函数调用。对其求值的方法如下：先对每个表达式$a_i$求值，然后再对$e$求值。在对$e$求值时，任何出现$p_i$的值，都是最近一次函数调用中对应$a_i$的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">)))</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">Z</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果一个表达式：
($f$ $a_1$ … $a_n$)
其第一个元素$f$不是一个操作原语，而$f$的值是一个函数(lambda ($p_1$ … $p_2$) $e$)，那么表达式的值就是：((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>换言之，在表达式中参数可与当操作符用，如同函数参数一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span>  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class="line"><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有另外一种标记函数的方式，使得函数可以引用它自己，这给我们很方便的途径去定义递归函数。
记号：
(label $f$ (lambda ($p_1$ … $p_2$) $e$))
标记了行为如同(lambda ($p_1$ … $p_2$) $e)的函数。 </p>

<p>我们进一步将 f = (label $f$ (lambda ($p_1$ … $p_2$) $e$))缩写为：
(defun f ($p_1$ … $p_2$) $e$)</p>

<p>假设我们想定义一个函数(subst $x$ $y$ $z$)，它接收一个表达式$x$, 一个原子$y$, 一个列表$z$，然后返回类似于$z$的列表，但是$z$中每个$y$的实例都会被替换成$x$。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="ss">&#39;m</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么这个函数可以这样通过递归定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">subst-new</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="o">&#39;</span><span class="p">())</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">)))</span>
</span><span class="line">      <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">))</span>
</span><span class="line">               <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>刚好我们在这里可以看到如何在cond表达式中得到一个子句。第一个元素是t的子句，总会成功。注意’t和t等价。因此</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>等价于我们可能在其它语言中看到的语法：
if $x$ then $y$ else $z$</p>

<h3 id="section-1">一些函数</h3>

<p>既然我们有了一个表达函数的方式，我们将用原语操作符的术语来定义一些新的函数。首先，将方便地介绍一系模式的缩写。我们使用c$x$r, 其中$x$是a或d的序列，作为对应car和cdr序列的缩写。因此，例如(cadr $e$)是 (car (cdr $e$))的缩写，它返回$e$的第二个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cadr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">caddr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="nv">E</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdar</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>而且，我们使用(list $e_1$ … $e_n$)代表(cons $e_1$ … (cons $e_n$ ‘()) …)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;d</span> <span class="o">&#39;</span><span class="p">()))))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们现在来定义一些新函数。我们在函数名的尾部加一个句号，这便于和现存的原语函数区分开，也不会和Common Lisp现有的函数冲突。</p>

<ol>
  <li>(null. $x$)测试其参数是否为空列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">null.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">()))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(and. $x$ $y$) 返回真t，如果其两个参数都为真，否则返回空列表’()。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">and.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="no">t</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(not. x) 返回真t, 如果它的参数是空列表，否则返回</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">not.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="no">t</span><span class="p">)))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(concat. x y)收到两个列表，将它们联接起来。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">concat.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>*注：原文此函数命名为append，觉得concat 更适合一些 *</p>

<p>*注：这里用到了前面定义的函数null. *</p>

<ol>
  <li>(pair. $x$ $y$) 收到两个等长的列表，然后返回一个列表，每个元素是由$x$、$y$对应元素构成的列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">pair.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span>
</span><span class="line">          <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="nv">pair.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">e</span> <span class="nv">g</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span> <span class="nv">f</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">E</span> <span class="nv">F</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(assoc. x y) 收到一个原子$x$和一个由pair.生成的列表形式，然后返回列表$y$中其第一个元素是$x$的列表的第二个元素。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">assoc.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">           <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">           <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line"> <span class="nb">&gt;</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">g</span><span class="p">)))</span>
</span><span class="line"><span class="nv">F</span>
</span><span class="line"> <span class="o">```</span>
</span><span class="line">
</span><span class="line">
</span><span class="line"><span class="err">###</span> <span class="err">惊喜</span>
</span><span class="line">
</span><span class="line"><span class="err">我们能够定义函数，完成级联列表、用一个表达式替换另一个等等。一个优雅的记号，但这又能怎么样呢？现在惊喜来了。我们也能证明，可以写一个函数作为语言自己的解释器：一个将任意</span><span class="nv">Lisp</span><span class="err">表达式作为参数，并返回其值，见下：</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<blockquote>
  <p>(defun eval. (e a)
    (cond 
      ((atom e) (assoc. e a))
      ((atom (car e))
       (cond
         ((eq (car e) ‘quote) (cadr e))
         ((eq (car e) ‘atom) (atom (eval. (cadr e) a)))
         ((eq (car e) ‘eq) (eq (eval. (cadr e) a)
                               (eval. (caddr e) a)))
         ((eq (car e) ‘car) (car (eval. (cadr e) a)))
         ((eq (car e) ‘cdr) (cdr (eval. (cadr e) a)))
         ((eq (car e) ‘cons) (cons (eval. (cadr e) a) 
                                   (eval. (caddr e) a)))
         ((eq (car e) ‘cond) (evcon. (cdr e) a))
         (‘t (eval. (cons (assoc. (car e) a)
                          (cdr e))
                    a))))
      ((eq (caar e) ‘label)
       (eval. (cons (caddar e) (cdr e))
              (cons (list (cadar e) (car e)) a)))
      ((eq (caar e) ‘lambda)
       (eval. (caddar e)
              (concat. (pair. (cadar e) (evlis. (cdr e) a))
                       a)))))</p>
</blockquote>

<blockquote>
  <p>(defun evcon. (c a)
    (cond
      ((eval. (caar c) a) (eval. (cadar c) a))
      (‘t (evcon. (cdr c) a)))) </p>
</blockquote>

<blockquote>
  <p>(defun evlis. (m a)
    (cond 
      ((null. m) ‘())
      (‘t (cons (eval. (car m) a)
                (evlis. (cdr m) a)))))</p>
</blockquote>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="err">这个函数</span><span class="nv">eval.</span><span class="err">比我们之前看到的任何函数都要长。让我们看看它是如何工作的。</span>
</span><span class="line">
</span><span class="line"><span class="err">这个函数有两个参数：</span><span class="nv">e,</span> <span class="err">将要求值的表达式，以及</span><span class="nv">a,</span> <span class="err">原子所给定值的列表，在函数调用中以参数表现出来。这个列表被称之为</span><span class="nb">*</span><span class="err">“环境”</span><span class="nb">*</span><span class="p">(</span><span class="nv">environment</span><span class="p">)</span><span class="err">，是由</span><span class="nv">pair.</span><span class="err">创建的形式。</span><span class="nv">eval.</span><span class="err">的骨架是由带有</span><span class="nv">4</span><span class="err">个子句的</span><span class="nb">cond</span><span class="err">表达式。我们如何对表达式求值取决于它的类别。第一个子句处理原子。如果</span><span class="nv">e</span><span class="err">是一个原子，我们在环境中查找它的值。</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<blockquote>
  <p>(eval. ‘x ‘((y b) (x a)))
A
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span></figure></notextile></p>
</blockquote>
<p>&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="nv">eval.</span><span class="err">的第二个子句是一个</span><span class="nv">cond,</span> <span class="err">处理格式为</span><span class="p">(</span><span class="nv">$a$</span> <span class="o">...</span><span class="p">)</span><span class="err">的表达式，而</span><span class="nv">$a$</span><span class="err">是原子。这些包含所有对原语操作符的使用，每个子句处理其中一个：</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;&lt;/figure&gt;&lt;/notextile&gt;&lt;/div&gt;
&gt; (eval. ‘(eq ‘a ‘a) ‘())
T
&gt; (eval. ‘(cons x ‘(b c)) 
         ‘((x a) (y b)))
(A B C)
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">所有这些（除过</span> <span class="k">quote</span><span class="p">)</span><span class="err">调用</span><span class="nv">eval.</span> <span class="err">去查找参数的值。</span>
</span><span class="line">
</span><span class="line"><span class="err">最后两个子句更为复杂，为了给</span><span class="nb">cond</span><span class="err">表达式求值，我们调用一个附属函数</span><span class="nv">evcon.,</span> <span class="err">它递归式地遍历子句，寻找其第一个元素返回</span><span class="nc">t</span><span class="err">的子句。当它找到时，就返回其第二个元素。</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘(cond ((atom x) ‘atom)
                (‘t ‘list))
         ‘((x ‘(a b))))
LIST
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="nv">eval.</span><span class="err">第二个子句的最后一部分，处理作为函数的调用。它通过将原子替换为它的值，并对得到的表达式求值。</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘(f ‘(b c))
         ‘((f (lambda (x) (cons ‘a x)))))
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">定价于</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘((lambda (x) (cons ‘a x) ‘(b c))
         ‘((f (lambda (x) (cons ‘a x)))))
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">最后返回</span><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span><span class="err">。</span>
</span><span class="line">
</span><span class="line"><span class="nv">eval.</span><span class="err">的最后两个子句处理函数调用，其第一个元素是实际的</span> <span class="k">lambda</span><span class="err">或</span><span class="nv">label</span><span class="err">表达式。对</span><span class="nv">label</span><span class="err">表达式的求值是，将函数名和函数自身的列表压入环境中，然后对一个表达式调用</span><span class="nv">eval.</span><span class="err">求值，其中用内部的</span><span class="k">lambda</span><span class="err">表达式替换</span><span class="nv">label</span><span class="err">表达式。即：</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt;  (eval. ‘((label firstatom (lambda (x)
                              (cond ((atom x) x)
                                    (‘t (firstatom (car x))))))
           y)
         ‘((y ((a b) (c d)))))
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">变成</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘((lambda (x) (cond ((atom x) x)
                             (‘t (firstatom (cdr x)))))
           y)
         ‘((firstatom 
            (label firstatom (lambda (x) 
                               (cond ((atom x) x)
                                     (‘t (firstatom (cdr x)))))))
           (y ((a b) (c d)))))
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">对形式为</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">$p_1$</span> <span class="o">...</span> <span class="nv">$p_n$</span><span class="p">)</span> <span class="nv">$e$</span><span class="p">)</span> <span class="nv">$a_1$</span> <span class="o">...</span> <span class="nv">$a_n$</span><span class="p">)</span><span class="err">的表达式取值，首先调用</span><span class="nv">evlis.,</span> <span class="err">来获得参数</span><span class="p">(</span><span class="nv">$a_1$</span> <span class="o">...</span> <span class="nv">$a_n$</span><span class="p">)</span><span class="err">的一组值</span><span class="p">(</span><span class="nv">$v_1$</span> <span class="o">...</span> <span class="nv">$v_n$</span><span class="p">)</span><span class="o">,</span> <span class="err">然后将</span><span class="p">(</span><span class="nv">$p_1$</span> <span class="nv">$v_1$</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nv">$p_n$</span> <span class="nv">$v_n$</span><span class="p">)</span><span class="err">添加到前面的环境中，然后对</span><span class="nv">$e$</span><span class="err">求值。</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘((lambda (x y) (cons x (cdr y)))
           ‘a
           ‘(b c d))
         ‘())
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;figcaption&gt;<span></span>&lt;/figcaption&gt;&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class="lisp"><span class="line"><span class="err">变成</span>
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
&gt; (eval. ‘(cons x (cdr y))
         ‘((x a) (y (b c d))))
&#8220;`</p>

<p>最后返回(A C D)。</p>

<h3 id="section-2">尾声</h3>

<p>现在我们已经理解了eval怎么工作的，让我们回退一下考虑这意味着什么。我们现在所拥有的是非同寻常的优雅的计算模型。仅仅使用quote, atom, eq, car, cdr, cons 和 cond, 我们定义了一个函数eval., 它事实上实现了我们的语言，然后使用这些，我们可以定义任何想添加的函数。</p>

<p>当然已经有非常著名的计算模型，图灵机。但是图灵机读起来缺少启迪性。如果你想要一个描述算法的语言，你可能需要更为抽象一点的语言。这就是McCarthy定义Lisp的目的之一。</p>

<p>他在1960年定义的语言少了很多东西。没有副作用、没有顺序执行（不管怎样，它只有和副作用一起才有用）、没有使用的数字、没有动态范围。但是，这些局限可以用令人吃惊的少量代码来改进。Steele和Sussman在著名的论文“解释器的艺术”(The Art of the Interpreter)中，展示如何做这些。</p>

<p>如果你理解McCarthy的eval, 你理解到的不仅仅是编程语言历史上的一个阶梯。这些创意仍然是今天Lisp的语义核心。因此学习McCarthy的原文，在某种程度上，向我们展示了Lisp是什么。它不是McCarthy如此设计为他所发现的东西。它本质上，不是为了人工智能(AI)，快速搭建原型，任何其它这个层面的任务。它是当你试图公理化计算时，你得到的东西。</p>

<p>伴随着时间，中等程度的语言，即由中等程度程序员使用的语言，已经一贯地向Lisp方向去成长。因此，通过理解eval, 你正在理解未来可能的主要计算模型是什么。</p>

<h3 id="section-3">注释</h3>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Steven Liu <stevenliucx@gmail.com></span></span>

      




<time class='entry-date' datetime='2015-07-14T14:30:54+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:30 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://hack.the-lifematrix.net/blog/2015/07/the-roots-of-lisp/" data-via="" data-counturl="http://hack.the-lifematrix.net/blog/2015/07/the-roots-of-lisp/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/06/a-conversation-with-alan-kay/" title="Previous Post: 译文：与艾伦·凯的对话">&laquo; 译文：与艾伦·凯的对话</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/07/implementing-arithmetic-in-lisp/" title="Next Post: 在Lisp中实现算术">在Lisp中实现算术 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2015/07/implementing-arithmetic-in-lisp/">在Lisp中实现算术</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/07/the-roots-of-lisp/">LISP的基础</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/a-conversation-with-alan-kay/">译文：与艾伦·凯的对话</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/06/concepts-in-lisp/">Concepts in LISP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/05/big-data-system-2/">Lambda Architechture</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - Steven Liu <stevenliucx@gmail.com> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
