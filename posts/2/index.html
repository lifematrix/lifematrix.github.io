
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Life Matrix</title>
  <meta name="author" content="Steven Liu <stevenliucx@gmail.com>&#8221;>

  
  <meta name="description" content="IT技术的飞速发展、不断升级换代，一方面的确给这个行业带来极大的活力和机会，但也给业者带来知识老化和智力投资过时的困惑。 但是，我们的确看到有很多成功的软件产品，它们跨越了技术快速发展的短周期，而在相当长的时间跨度下，保持产品的稳定和不断演进，并与新技术共舞，不断完善自己，变得更为完美。例如TEX &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://hack.the-lifematrix.net/posts/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Life Matrix" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  


  <!-- mathjax config similar to math.stackexchange -->
  <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       jax: ["input/TeX", "output/HTML-CSS"],
       tex2jax: {
          inlineMath: [ ['$', '$'] ],
          displayMath: [ ['$$', '$$']],
          procehssEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
       },
       messageStyle: "none",
       "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
     });
   </script>
   <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Life Matrix</a></h1>
  
    <h2>Hacking, Machine learning, Lisp</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:hack.the-lifematrix.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/resources">Resources</a></li>
  <li><a href="/lisp-resource">Lisp Resource</a></li>
  <li><a href="/resources-on-deep-learning">Deep Learning</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/talk-about-tex/">由TEX想到的</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-15T11:02:49+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:02 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>IT技术的飞速发展、不断升级换代，一方面的确给这个行业带来极大的活力和机会，但也给业者带来知识老化和智力投资过时的困惑。</p>

<p>但是，我们的确看到有很多成功的软件产品，它们跨越了技术快速发展的短周期，而在相当长的时间跨度下，保持产品的稳定和不断演进，并与新技术共舞，不断完善自己，变得更为完美。例如TEX，计算机科学家Donald Knuth于1970年代研发出的数学排版软件。他的初衷是发现自己撰写的论文在数学期刊印刷出来后，不够美观，而且当时没有很好的计算机排版软件，于是就自己着手研究开发。TEX及其扩展LaTex，至今仍被广泛地应用在专业期刊和书籍的出版，并作为插件被几乎被所有包含数学公式的网页和文档所采用。</p>

<p>作者自己十多年数学研究生时，使用LaTex撰写学位论文。当时积累有关LaTex的知识和经验，现在仍然可以用到。所以倍感亲切，知识没有老化和浪费。</p>

<p>《黑客与画家》的作者Paul Graham，在介绍为什么学习Lisp时，讲到通过定义针对应用域的语言，来达到高复用性，并将TEX作为典范。TEX提供了易学、清晰、可读性高的排版语言，让作者在撰写的过程中，就完成了排版，避免了反复沟通和校对的过程。</p>

<p>Knuth 在文章<a href="http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.bams/1183544082">Mathematical Typography</a>中讲到了他的思路。</p>

<pre><code>数学书籍和期刊没有它们以往看起来那样好看。这不是因为它们的内容不
够好，而是因为过去且良好排版的传统过于昂贵。幸运地是，现在看来数
学本身可以用来解决这个问题。

方案的第一步是设计方法来清晰地表达数学手稿，让它们能容易地被机器
操作。这样的语言，如果恰当设计，作者及其打字员能很快学习，而且这
个手稿能为印刷机直接产生高质量的印版，几乎不需要人工介入。

方案的第二步是利用经典数学来设计字体和符号的形状。例如，它能够给出
字母“a"准确形状的严格定义，使得通过改变单一定义中的少数几个参数，
能够得到无限多的风格(黑体、扩展、衬线、斜体等等)。当类似的方法用到
其它字母和符号时，我们得到了字体的数学定义，一个可以在今天和未来的
计算机里使用的定义。这个策略的显著特征就是，新的符号能轻而易举地添
加进来，并能自动地和原有的保持一致。
</code></pre>

<p>Knuth的系统，在开发中得到了斯坦福的同事和学生的帮助，包含三个组成部分：</p>

<ol>
  <li>TEX 排版引擎</li>
  <li>METAFONT 字体设计系统</li>
  <li>计算机的现代书体(Computer Modern Typefaces)</li>
</ol>

<p>Knuth后来将TEX的代码公开，如今<a href="https://latex-project.org/lppl/">LaTex项目</a>是最成功的自由软件之一。</p>

<h3 id="section">系统组成</h3>
<p>#### TEX 排版引擎</p>

<p>排版语言的关键，是如何将二维的公式用一维的操作序列来表示，从而可以传输给计算机去处理。Knuth在文中列出了三种可能的方案，而最终选择了Type T，这就是我们熟知的TeX排版语言。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/three-approaches.png" alt="" /></p>

<p>此语言有几个优点：</p>

<ul>
  <li>采用自由体的语法，对空白字符没有特殊要求。这样会避免很多人为的语法错误，在传输和跨系统兼容上也比较好。目前的HTML，XML也采用这种方式。</li>
  <li>能够处理普通文本，以及嵌入其中的数学公式。这样适用性广。</li>
  <li>助记符含义清晰、符合英文习惯，易于学习，比如\sqrt, \theta, \over</li>
  <li>保留字很少，主要是特殊的符号\,{},^,_</li>
</ul>

<p>TEX排版的主要想法是读入排版语言写成的手稿文本，构造出盒子(boxes)。一种字体的一个字符，或者一个黑色的长方形块，是最小的盒子，就象原子一样，而水平或垂直方向的一系列盒子(一行或一列)，就象是“分子”。这样的一行，组成的盒子，进而构成一本书中典型的一页。</p>

<p>水平或垂直方向的一组盒子，用称作“胶水”的“弹性灰浆”分隔开。两个盒子之间的胶水，用三个分量来表达$(x,y,z)$，都是指长度：</p>

<ul>
  <li>$x$, 空白分量，是这些盒子之间理想或正常的空白</li>
  <li>$y$, 延展分量，允许的额外空白的量</li>
  <li>$z$, 收缩分量，如果需要可以安全移去的空白</li>
</ul>

<p>在一个单词内的字母$x=y=z=0$，表示前后字母紧挨着。单词之间的间距，可以令$x$等于字母e的宽度，$y=x$, $z=x/2$，代表间距可以延展或收缩。</p>

<p>排版的一个重要任务，是确定一段文字要分成几行，称为断行(line division)。通常的断行，是一行接着一行处理。断完一行后，前行的结果与段落后面的部分没有关系。一个更好的方式是，将整个段落作为整体来考虑。Knuth的文章，设定了badness，相当于优化算法中的损失函数。断行的问题就转化为：</p>

<pre><code>给定一段文字以及允许断行的所有位置，寻找一组断点，
让badness的平方和最小化。
</code></pre>

<p>如果一个段落有$n$个可以断行的点，就会有$2^n$个可能的方式去断行。这个计算复杂度很好。所幸的是，有一个技术能将$2^n$复杂度降低到$n^2$，这就是动态规划(dynamic programming)的数学方法。</p>

<h4 id="metafont-">METAFONT 字体设计系统</h4>

<p>在设计字体时，一种策略是将现有的字体拍照下来，再数字化。但Knuth觉得，他当时没有合适的照相机等设备来做这些。不过，更关键的是，他觉得“拷贝”的方法没有切中问题核心。他说到一个轶事，最早传到东方的计算尺在侧面有个小污点，结果日本早期造的计算尺在相同的位置都有一个无用的黑点。所以要”拷贝实质而非形式”(We should copy the substanc rather than the form)。他认为正确的问题，不是去问“如何拷贝那些已经设计好的字体”，而是问“<strong><em>过去伟大的字体设计家如果现在还活着，他们会如何为新设备(注：指计算机)设计字体？</em></strong>”。</p>

<p>Knuth研究了字体设计的历史。发现在15世纪开始，即文艺复兴时期，出现了用尺规作图的几何方式来设计字体。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/ruler-compass-construction.png" alt="" /></p>

<p>但后来的历史表明，这种几何方法设计的字体比较丑陋，而且主要用于大写字母。不过，在往后的几百年，出现了一些新的进展，也给数学化字体设计提供了基础。</p>

<p>Knuth采用3次样条函数的方式描述曲线，以及模拟书法家写字的过程，对笔和墨水的宽度加以描述。所以，META有别于轮廓字体，更不同于点阵字体。它描述了笔的中心经过的曲线，以及伴随笔的移动，所允许的笔的形状。这个方法的主要优势是，可以产生无限多内在一致的相关字体族。如下图，通过调整参数就可以产生各种字体(罗马、粗体、无衬线、无衬线粗体、打印体…)。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/fonts-family.png" alt="" /></p>

<p>METAFONTS 还要解决从连续到离散的问题，字体需要在屏幕上显示，或者要以离散格栅的形式显示，以便照排印刷。一个直接的方法是，先按照无限的精度画出字母，再按实际的分辨率，将每个足够黑的正方形取整为一个黑色的像素。但是，以字母m为例，这会造成，本来同宽的三竖，数字化后粗细不一、间距不等。所以，实际的做法是，先将”笔“数字化，并设计更为平滑的”取整“方法。</p>

<p>下图是字体参数相同但分辨率不同，在格栅上的显示。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/different-resolution.png" alt="" /></p>

<h2 id="section-1">思考</h2>

<p>一个技术如果一直没有被取代，有两种可能。一是技术过于老化，但是人们没能找到革新的方法，只好忍受它。二是它已经很好地解决了所在领域的问题，在长期内很好地服务领域用户，这被称为“杀手级”的产品。显然，TEX属于后者。</p>

<p>Knuth从自己实际工作的痛点出发，对相关问题进行研究，并创造性地运用数学的工具来对问题进行描述，得到非常完美的解决方案。这不得不让人敬佩。这才是真正的计算机科学家。最后，小结一下TEX给我们的启发。</p>

<ul>
  <li>从实际的痛点出发，痛点代表真实的需求</li>
  <li>系统化、完整化地解决问题</li>
  <li>数学是建模、信息处理以及算法设计的强大宝库</li>
  <li>好的系统：核心的稳定和外围的扩展</li>
  <li>通过设计域特定语言(DSL)来达到极大的复用度和灵活性</li>
  <li>必须考虑跨平台</li>
  <li>建立用户群，不断接收用户反馈，完善和升级产品</li>
  <li>必要时，将软件开源或发布为自由软件，以获得更多的社区参与力量，保持项目的生命力</li>
</ul>

<p>关于最后一点，LaTex现在已经成为自由软件，由社区去维护，保持了巨大的活力。某种程度上，它已经成为全世界的智慧资产。如果开发的系统达到这个程度，也是很欣慰的。好的自由软件，比如Linux，都会达到这一步。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/10/why-learn-lisp/">为什么学习Lisp?</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-10-08T10:38:18+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>8</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:38 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><em>本文的主要内容来自Paul Graham的<a href="http://www.paulgraham.com/acl.html">《ANSI Common Lisp》</a>，以及作者自己的思考。</em></p>

<h2 id="section">计算和编程语言</h2>

<p>人类的进化，总是试图将智能带进物质，让物质按照人的期望去做事。其一是实用性目的，能替代人的重复性工作或难以做到的工作，让人的生活水准提高，或步入更高的创造层次。其二是人性固有的好奇心，求知的渴求和成就感的满足。将智能带入物质，是个不断进化的过程。从最初的机械式自动化设备，比如钟表、抽水马桶、纺织机械等，到现在的计算机。进化的越高端，智能越能直接通过物质去表达。</p>

<p>智能也包括很多层次，最基础和最低端，是逻辑。计算机的出现，得以让逻辑直接物质上去表达。计算机提供指令，完成基本的逻辑和数字运算。编程语言，是人与计算机沟通的方式。编程语言抽象层次越高，越接近人的思维。抽象层次越低，越接近机器指令。利用编程语言，编写较高层次的逻辑，就是软件。计算机，让人类可以在逻辑层次而非物理层面去创造，这就是所谓的软件–逻辑产品。</p>

<p>人类思维的本质，喜欢内在的秩序，如果事物过于纷乱，无法找到规律或秩序，人就会难以驾驭它。当然某些混乱，并不意味着失控，而是更大更高秩序的展现。如果有太多复杂和详细的逻辑要表达，人就会难以理解，以至于出现思维的失误，具体到软件上，就是BUG。</p>

<p>例如，如果汇编语言来编写WORD这样的软件，其工作量将增加几十倍。如果我们将软件团队的所有成员，看成一个更大的大脑。那么，这个大脑在处理复杂逻辑上，有其极限。达到临界点时，增加人手，会让沟通成本增加，反而降低效率。为了处理复杂的逻辑，或编写更为庞大精巧的软件，就必须在较高的层次去思考、设计和编码。这就是编程语言的重要性。<strong>编程语言决定了对问题的思考方式</strong>。</p>

<p>一旦人不需要直接去创造物理产品，而着力创造逻辑产品的时候，人的思维就会从物理的束缚中解脱出来，达到更大的自由度。所以软件的开发、升级、创新，会呈现出越来越大的活力。每个生活领域、每个商业分支等，都会有很多逻辑可以用软件来表达，由此人类生活的各个方面都会有软件渗透进去，编程语言会起到更大的作用。</p>

<p>所以，编程语言自身的进化和发展，代表了人类对逻辑的表达能力的提升。从汇编、到C、到java，抽象度在提高，软件可以编写地更为复杂、巨大。</p>

<p>一个好的语言，要具备这几点：</p>

<ul>
  <li>表达力</li>
  <li>核的精炼</li>
  <li>扩展的丰富</li>
  <li>性能</li>
  <li>开发效率</li>
</ul>

<p>表达力指语言的抽象能力，对事物的概括能力。精炼的核，保证了语言本质的简洁，容易理解和掌握。扩展的丰富，代表了语言的适应力和不断进化的能力。性能，指语言的实现在物理机器上运行的效率。开发效率，包括写代码的速度、错误率等。</p>

<p>通过Graham的介绍，Lisp就是这样优秀的语言。</p>

<h2 id="lisp-">Lisp 的特点</h2>

<p>John McCarthy在1960年代左右发明了Lisp语言。继Fortran之后，Lisp是仍在使用的最古老的语言。更值得注意的是，Lisp仍然处于编程语言技术的前沿。懂Lisp的程序员会告诉你，Lisp的有些东西把它和别的语言区分开。</p>

<p>Lisp语言的独特性，部分源于它被设计为<strong>可进化</strong>的语言。你可以利用Lisp来定义新的操作符。当新的抽象变得流行时(例如，面向对象编程)，它总是能在Lisp轻易实现。就像DNA，这样的语言不会过时。</p>

<h3 id="section-1">新的工具</h3>

<h4 id="section-2">语法闭包</h4>

<p>学习Lisp是因为它能让你做在其它语言中做不了的事情。如果你只想让语言做一些简单的事，比如写一个函数，返回小于$n$的所有数之和，那么Lisp和C差别不大。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="Lisp"><span class="line"><span class="c1">; Lisp</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
</span><span class="line">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="mi">0</span><span class="p">))</span>
</span><span class="line">    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">n</span> <span class="nv">s</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nb">incf</span> <span class="nv">s</span> <span class="nv">i</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="C"><span class="line"><span class="cm">/* C */</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">		<span class="n">s</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你想写一个函数，它接收参数$n$，返回一个将任何数加$n$的函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="Lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">addn</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
</span><span class="line">  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>那么C就做不到了。</p>

<p>你可能会想，为什么没有人曾经这么想呢？<em>编程语言叫你不要去想那么语言提供不了的东西</em>。为了在语言之中写程序，你必须在语言之中思考。比如，很多人开始用Basic写程序，就不会去想递归，因为在Basic中就没有递归这回事。他只能考虑迭代算法。</p>

<p>上面的例子，叫词法闭包(lexical closures)，Lisp程序员一直在使用，但是在其它语言中却看不到。</p>

<h4 id="section-3">同象性</h4>

<p>Lisp另一个更有价值的特点是，其代码和数据具有相同的结构，亦或代码用数据结构的形式表达。这意味着，程序员通过操作数据，就可以形成新的代码。也就是，可以能编写程序的程序。这在Lisp中，通过宏来实现。</p>

<p>通过宏、闭包和运行时类型，Lisp超越了面向对象编程。</p>

<h3 id="section-4">新的技术</h3>

<p>Lisp所带有的新事物 – 自动内存管理，明显的类型化，闭包等等，都会让编程更容易。这些组合在一起，就形成临界质量，让新的编程方式成为可能。</p>

<p>Lisp设计为可以扩展的：它允许你自己定义新的运算符。扩展Lisp并不比用它写程序更困难。事实上，这很容易(而且如此有用)，以至于成为Lisp编程的标准实践。正如你可以写程序向下通向语言，你也可以构建语言向上通向你的程序。你自底向上工作，正如自顶向下。</p>

<p>几乎任何程序都能从裁剪语言适应它的需要中获益，但是程序越复杂，自底向上的编程就越有价值。一个自底向上的程序，可以写成一系列的层，每一个作为上一层的一种编程语言。TEX是最早以这种方式写出的程序。你可以在任何语言中以自底向上的方式写程序，但Lisp是这种方式最为自然的工具。</p>

<p>自底向上编程自然地产生了可扩展的软件。如果你采用了自底向上的编程原理一直到你程序的最顶层，那么这一层就会成为给用户的编程语言<em>(注：如果最上层是自然语言，那就意味着软件可以和用户对话了，哈哈)</em>。因为扩展性的想法如此根植于Lisp之中，使得它成为编写可扩展软件的理想语言。1980年代最成功的软件中有三个，都提供Lisp作为扩展语言：Gnu Emacs, Autocad 和 Interleaf。</p>

<p>自底向上工作，也是获得可复用软件的最佳途径。编写可复用软件的核心是，将普遍和特殊分开。自底向上编程本质上就创造了这样一种分离。不是将你的精力全部放在单一的、庞大的应用上，你将你的部分精力用于构造语言，部分（成比例的相应小一些）用于在其上编写应用。对这个应用特殊的地方，将集中在最顶层。其下的层将形成一个语言，来写这样的应用。什么能够比编程语言更具复用性的？</p>

<p>Lisp 不但允许你编写更为精巧的程序，也能让你更快地编写。Lisp程序常常短小 – 语言给你了更大的概念，所以不必用那么多。正如Frederick Brooks指出的，写程序花的时间绝大多数取决于它的长度。但就这个事实，写Lisp程序需要的时间更少。这个效果被Lisp的动态特征放大了：在Lisp中，编辑-编译-测试的循环是如此简短，以至于编程是实时的。</p>

<p>更高的抽象和交互式环境能改变组织开发软件的方式。<strong>快速原型</strong>术语描述了开始于Lisp的一种编程方式：在Lisp中，你能花比写规约更少的时间来写原型。而且，这个原型是如此抽象，相比用英语写下来的规约，它是更好的规约。Lisp允许你从原型到生产性软件的平滑过渡。当Common Lisp程序在编写时留意速度，并用现代编译器编译，它们能运行地像用任何其他高层次编写的程序一样快。</p>

<h3 id="section-5">新的策略</h3>

<p>Lisp使得一种新的编程策略成为可能。这一策略将在未来更常看到。随着编程环境更加强大，语言变得更为抽象，Lisp风格的编程将逐渐取代旧有的计划-实施模式(plan-implement model)。</p>

<p>在旧的模式中，Bug从不假设会发生。详尽的规约，提前煞费苦心地做出来，被假定能保证程序可以完美地运行。这在理论上听起来很好。不幸地是，规约也是由人书写且实施的。实际上，计划-实施模式的效果并不那么好。</p>

<p><em>(注：规约也是人写的，也会出错，而且因为是文字性的，其错误更不易排查，只能通过同行不断评审来保证。换句话说，自然语言本就不适合描述逻辑。需求可能需要用文字来描述。规约，或者软件功能特征的定义，可以用原型的方式来表达。当然，有些特性的逻辑层次较深，不是操作原型一下子就能看到。这是辅以文字说明是必要的。也就是增加原型说明的文档。)</em></p>

<p>作为OS/360项目的经理，Fredericks Brooks 对传统策略很熟悉，对其结果也很了如指掌：</p>

<pre><code>任何OS/360的用户都知道，它本应该更好些...而且，交付延迟了，
它使用了比计划更多的内存，成本比预计高了几倍，直到多个发行版之后才运行良好
</code></pre>

<p>这就是对那个时代最成功之一的软件系统的描述。</p>

<p>旧模式的问题是忽略了人性的弱点。在旧模式中，你打赌规约中没有包含任何严重的缺陷，实现它们只是简单地翻译成代码。经验显示这是个糟糕的赌注。更安全的打赌是，规约会被误导，代码中满是bug。</p>

<p>这恰就是新的编程模型所假定的。与其希望人们不犯错，不如努力让出错的成本降低。错误的成本是修正它需要的时间。如果有强大的语言和良好的编程环境，成本就会极大降低。由此，编程风格就较少地取决于计划，更多依赖于探索(exploration)。</p>

<p>计划是必要的恶：它是对风险的反应。一件事危险越大，事先计划就越重要。强大的工具降低了风险，因此也降低了对计划的需要。然后，你程序的设计就能从可能是最有价值的可用信息源中获益 – 实施它的经验。</p>

<p>自从1960年代，Lisp风格就在这个方向上进化。你能在Lisp中如此之快地写出原型，以至于你能经历几次设计和实现的迭代，而在旧的模型中，你才刚刚写完规约。你不用过于担心设计缺陷，因为你能马上发现它们。而且你不用担心有太多的bug。<strong>当你用函数风格编程时，bug只会有局部影响(When you program in functional style, bugs can only have local effects)</strong>。当你使用非常抽象的语言，有些bug(例如悬空指针，dangling pointers)将不再可能。剩下的也会很容易发现，因为你的程序更为简短。当你有个交互环境，你能立即修正bug，而不用忍受编辑、编译和测试的漫长周期。</p>

<p>Lisp风格进化了这种方式，因为它奏效。听起来很奇怪，较少的计划意味着更好的设计。技术的历史充满了类似的案例。绘画中一个相似的改变，发生在15世纪。在油画流行之前，画家们使用一种介质，称为蛋清颜料(tempera)，它不能被掺杂或涂掉重画。出错的成本很高，这常常让画家变得保守。然后出现了油画，这在风格上是极大的变化。油彩允许二次思考(Oil “allows for second thoughts”)。这提供了决定性优势去处理诸如人物肖像这样有难度的题材。</p>

<p>新的介质并没有让画家的日子轻松一些。它让崭新的、更有进取心的绘画方式变为可能。Janson写到：</p>

<pre><code>没有油彩，佛兰芒画师们对视觉现实的征服将受到很大限制。因此，也从技术角度看，
他们值得被成为“现代绘画之父”。因为，从那时起，油彩就成为画家的基本颜料。
</code></pre>

<p>就材料而言，蛋清颜料并不比油彩差。但是油彩的灵活性给了想象力更大的空间 – 这是决定性因素。</p>

<p>编程如今也在经历类似的变化。新的媒介被成为“面向对象的动态语言”，简言之，Lisp。这并不是说我们所有的软件在几年里都会用Lisp去编写。从蛋清颜料到油彩的变迁，没有在一夜之间完成。开始，油彩只是在领先的艺术中心流行，经常会与蛋清颜料组合使用。我们现在就处于这个阶段。Lisp用在大学、研究实验室和少数前沿的公司。同时，从Lisp中借用的想法越来越多地出现在主流：交互式编程环境、垃圾回收、运行时类型等，不一而足。</p>

<p>更强大的工具正在将风险从探索中拿掉。对于程序员来说，这是好消息，这意味着我们能着手更为进取心的目标。油画的使用已经说明了这一效果。紧随它的采用，绘画史上的黄金时代来临了。已经有信号出来，类似的事情将发生在编程中。</p>

<h2 id="lisp">Lisp于当下</h2>

<p>Paul Graham 的书写于1996年，20年过去了，Lisp并没有成为编程语言的主流。不过, 他所阐述的Lisp的优点的确都大量被其它编程语言采用。</p>

<p>1990年代Web的出现将编程带入新的时代。之前更多的是单机运行的系统。在Web环境下，代码更新到服务器端就意味着发布，所以不经编译的解释性语言会加快测试-修正-发布的循环。而且，Web的前端要求内容与逻辑的集成，PHP这种将代码嵌入HTML中的解释性语言就大为流行(也包括Asp.net, JSP等)。其它的解释性语言如Perl, Python, Ruby也在不同社区蓬勃发展。</p>

<p>垃圾回收或自动内存管理，已经被Java和.Net等广泛采用。</p>

<p>那么Lisp为什么没有成为主流，为大多数程序员所接受呢？作者的分析是：</p>

<ul>
  <li>
    <p>Lisp的学习曲线比较陡，不是快速上手的语言。Lisp的编程思维，与通常的过程化编程有很大的不同。过程化编程，更多地表达的是一种平铺式的线性逻辑。用过程化思维编程，代码量大且代码复用率低，但是当开发者素质不高时，这种方法反而便于任务的分解和沟通，达到快速开发。而Lisp则需要极高的抽象能力，对开发者水平要求很高，相互间要在高层次上沟通。所以Lisp适合于比较有生命力的、复用度高、逻辑复杂的产品类开发，一次开发，长期使用。而传统的过程化语言，适合于短平快的项目型开发。</p>
  </li>
  <li>
    <p>Lisp的优势，不在于直接用它去编写某个应用领域的程序。而是通过宏、闭包等工具，构建新的语言，这种语言有较高的抽象度，能更直接地描述应用领域中的问题。这样之后的编程量和错误率，都会大为减少(换言之，抽象度越高、代码量越小的程序，编写地越快而且错误率越低)。虽然这个思路是正确而有效的，但缺乏有经验的开发者这样去做。</p>
  </li>
  <li>
    <p>Lisp在国内的计算机科学教育中缺少足够的重视。很多技术人员只追踪流行的技术，而缺少技术本质的了解。就象<a href="http://hack.the-lifematrix.net/blog/2015/06/a-conversation-with-alan-kay/">Alan Kay所说</a>，很多计算机的本科教育成了Java培训。</p>
  </li>
  <li>
    <p>采用Lisp编程，由于需要人的素质高，不适于短平快的项目。所以在注重速度的互联网时代，很难被商业公司选择。</p>
  </li>
</ul>

<p>技术总在发展。Lisp虽然没有成为主流，但它的基因和生命力还在。在未来，Lisp能否扩大它的影响力？笔者认为是可能的。</p>

<ul>
  <li>
    <p>Web快速发展，产生了很多快速开发的方法，但都属于过渡性技术。比如HTML，javascript，PHP。如何让Web页面更具交互性，如何将内容和逻辑合理地分离，如何适应移动端的Web应用开发，以及Web应用与本地应用的结合，都会对技术提出更高的要求。我们已经到了需要清晰、规范、合理的Web开发模式的时候，HTML5和CSS3都是这方面的尝试。但是，仍感觉是过度性的，尤其CSS3。</p>
  </li>
  <li>
    <p>未来需要一些高质量的平台或框架类的产品，尤其是针对问题域提供高度抽象的语言，Lisp会有用武之地。</p>
  </li>
  <li>
    <p>随着Lisp的传播，当更多高水平开发者认识到Lisp的价值，会用Lisp开发出来一些“杀手级”产品。</p>
  </li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/the-art-of-interpreter-part-1/">The Art of Interpreter: Part One</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-24T14:50:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>24</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:50 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">第一部分：变量范围</h3>
<p>Part One
Variable Scoping Disciplines</p>

<h4 id="procedures-as-data">Procedures as Data</h4>

<p>The simple LISP described in Part Zero can be a pleasant medium for
encoding rather complex algorithms, including those of symbolic
mathematics. Often lists are used for representing such structures as the
set of coefficients of a polynomial or coordinates of a space vector. Many
problems require one to perform an operation on each element of a list and
produce a new list of the results. For example, it may be useful to make a list of the squares of each of the elements in a vector. We would write this as follows:</p>

<p>在第零部分描述的简单LISP，可以作为令人愉快的媒介，去编码相当复杂的算法，包括那些符号数学。列表经常用于表示比如多项式系数或者空间向量的坐标等这样的结构。许多问题需要人去执行对列表每个元素的操作，并产生一个作为结果的新列表。例如，产生向量中每个元素平方的列表，可能是有用的。我们这么写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SOUARELIST</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">SQUARE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">SOUARELIST</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We find ourselves writing this pattern over and over again:</p>

<p>我们发现我们自己一再地写这样的模式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">fLIST</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">fLlST</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where f is a function defined on the elements of our list. It would be
nice to be able to define an entity of the programming language which would
capture this abstract pattern. The “obvious” solution is to write the variable function as a functional variable which can be accepted as an argument:</p>

<p>这f是一个定义在列表元素上的函数。如果能够定义一个编程语言的实体可以捕捉这一抽象模式，会是极好的。“明显的”解决方法是写一个可变的函数作为函数化变量，它可以作为一个参数被接受。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">F</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">F</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">F</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(MAPCAR is the traditional name of this abstraction.) Using this we could
say:</p>

<p>(MAPCAR是这一抽象的传统名字) 利用此，我们可以写出：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">SQUARE</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Unfortunately, this will not work in our recursion equations interpreter.
Why not?</p>

<p>不幸的是，这不能在我们的递归方程解释器中运行。为什么不行？</p>

<p>The essence of the problem is that our interpreter segregates procedures from other kinds of objects. We refer to F as a procedure but it was passed in as a variable. Procedures are only looked up in the PROCEDURES symbol table, but variables are bound in ENV. Moreover, in the call to MAPCAR, SQUARE is used as a variable, which is looked up in ENV, but its definition is only available in PROCEDURES.</p>

<p>问题的关键是，我们的解释器将过程从其它类型的对象分离开。我们将F引用为一个过程，但是它作为变量传递。过程只在PROCEDURES符号表中查找，但是变量在绑定在ENV里。而且，对MAPCAR的调用，SQUARE被当做变量来使用，它将在ENV中查找，但是它的定义只存在于PROCEDURES。</p>

<p>Let’s merge the two symbol tables… How could that hurt?
让我们将两个符号表合并起来… 这有如何损害？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER-LOOP-1</span> <span class="nv">ENV</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span> <span class="nv">ENV</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="ss">&#39;DEFINE</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))</span>
</span><span class="line">                                    <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CDADR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FORM</span><span class="p">)))</span>
</span><span class="line">                                    <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))))</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">ENV</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="nv">ENV</span><span class="p">))))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For DRIVER—LOOP see Figure 1.
For EVAL see Figure 5.
For BIND see Figure 3.</em></p>

<center>
Figure 4
<br />
Modified Driver Loop for Treating Procedures as Objects
</center>

<p>We will eliminate PROCEDURES, and use ENV to contain both procedures
and other objects. The driver loop requires no particular changes (see
Figure 4), except for eliminating the argument 1) in the calls to EVAL. We
will change the name PROCEDURES to ENV throughout as well, but of course that
isn’t logically necessary, because our language is referentially
transparent. (snicker!) {Note EVALQUOTE}</p>

<p>我们去掉了PROCEDURES，然后使用ENV包含过程和其它对象。在调用EVAL时，driver loop 没有要求特别的改变(看图4，除过去掉参数1)。我们也将改变PROCEDURES的名字为ENV，但是当然在逻辑上是不必要的，因为我们的语言是引用透明的。(窃笑!) {Note EVALQUOTE}</p>

<p>(We have introduced a funny object &amp;PROCEDURES which we use to flag
procedural objects. In the previous interpreter it was impossible for the
user to request application of an object which was not either a primitive
operator or a procedure produced by a DEFINE form. Now that procedures
mingle freely with other data objects, it is desirable to be able to
distinguish them, e.g. for error checking in APPLY. We also have some
deeper motivations having to do with avoiding the confusion of a procedure
with its textual representation, but we do not want to deal with this issue
yet.)</p>

<p>(我们已经引入了一个有趣的对象&amp;PROCEDURES，我们用来标记过程兑现。在前面的解释器中，对用户来说，不可能请求应用一个对象，它既不是原语操作符，也不是由DEFINE form生成的一个过程。既然过程可以自由地与其它数据对象混合，能够将它们区分开，是可取的，例如对于APPLY中的错误检查。我们也有一些更深的动机不得不避免过程与它的文本表达之间的混淆，但是我们还不想处理这个议题。)</p>

<p>To fix up the evaluator, we eliminate all occurrences of PROCEDURES.
In EVAL, where the name of a procedure in a combination is looked up, we
change it to perform the lookup in ENV. Finally, there is a problem in
APPLY: if the call to EVAL to evaluate the body is simply</p>

<p>为了修补求值器，我们去掉所有PROCEDURES的出现。在EVAL中，在组合里面查找过程的名字，我们改变它，以便在ENV中执行查找。最后，在APPLY中有个问题：如果为了对求值主题而对EVAL的调用，简单地是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="o">&#39;</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>then the new ENV given to EVAL does not have the procedure definitions in
it. Moreover, APPLY does not even have access to an environment which
contains the procedure definitions (because its parameter PROCEDURES was
deleted)! We can easily fix this. When APPLY is called from EVAL, ENV can be passed along (as PROCEDURES used to be), and the call to EVAL from APPLY
can be changed to</p>

<p>那么传递给EVAL的新的ENV，不能在它其中包含过程定义。而且，APPLY甚至不能访问包含过程定义的环境(因为它的参数PROCEDURES被删除了)。我们能容易地修正这个。当从EVAL中调用APPLY时，ENV能单独地给传递，然后从APPLY中对EVAL的调用，能够被改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In this way the environment passed to EVAL will contain the new variable
bindings added to the old environment containing the procedure definitions.
(See Figure 5.) This is indeed a good characteristic: if the name of a
defined procedure is used as a local variable (procedural or otherwise), the new binding takes precedence locally, temporarily superseding the global definition.</p>

<p>在这个方式下，新的变量绑定将添加到包含过程定义的旧环境中，作为传递给EVAL的环境(见图5)。这的确是一个好的特征：如果一个被定义的过程的名字，被作为局部变量使用(过程的或其它)，那么新的绑定将采用局部优先，临时地替换全局的定义。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="ss">&#39;&amp;PROCEDURE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="nv">CLAUSES</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVLIS</span> <span class="nv">ARGLIST</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CON</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE and BIND see Figure 3.</em></p>

<center>
Figure 5
<br />
Evaluator for Treating Procedures as Objects
</center>

<p>Another good thing about this version of the interpreter is that
the gross non-modularity of the scattered occurrences of PROCEDURES has
disappeared. The problem has not been solved, of course, but we certainly
feel relieved that the particular manifestation has been removed!</p>

<p>这个版本解释器的另一个好处是，散落出现的PROCEDURES的显而易见的非模块性消失了。当然，问题还没有解决，但是我们确实感觉到轻松一些，特别的表现已经被移除了。</p>

<p>By the way, we also eliminated the explicit tests for T and NIL in
EVAL, assuming that we can simply put their initial values in the initial
environment provided by DRIVER.</p>

<p>顺便，我们也去掉了EVAL中对T和NIL显式地测试，假设我们能简单第将他们的初始值放在DRIVER提供的初始环境中。</p>

<p>An interesting property of this interpreter is that free variables
now have been given a meaning, though we originally did not intend this.
Indeed, in the original recursion equations interpreter, there were free
variables in a sense: all procedural variables were free (but they could
be used only in operator position in a combination). In our new interpreter, thanks to the merging of the procedural and variable environments, we may have not only bound procedure names, but also free variable names, for after all the two kinds of names are now one.</p>

<p>这个解释器的一个有趣的属性是，自由变量已经被给出一个含义，尽管我们开始不是有意为之。事实上，在原始的递归方程解释器，存在自由变量有点意思：所有的过程变量是自由的(但是它们只能在组合的操作符位置被使用)。在我们新的解释器，感谢过程和变量环境的合并，我们不但有绑定的过程名，也有自由变量的名字，因为毕竟现在这两类名字合一了。</p>

<p>This interpreter differs in only small details from the one in LISP
1.5 [LISP 1.5M]. Both have dynamically scoped free variables (we will
elaborate on this point later). We might note that the reference to VALUE
in EVAL when computing the first argument for APPLY can be replaced by a
reference to EVAL; this does the same thing if a variable appears in the
operator position of a combination, and allows the additional general
ability to use any expression to compute the procedure. This difference in
fact appears in the LISP 1.5 interpreter. There are other slight
differences, such as the representation of primitive operators and the
handling of procedures which are not primitive or user—defined. Aside from
these, the greatest difference between our interpreter and LISP 1.5’s is
the use of lambda notation. This we will meet in the next section.</p>

<p>这个解释器只和LISP 1.5 [LISP 1.5M]中的解释器有细小的差别。两者都有动态范围的自由变量(我们将在后面详述这点)。我们可能注意到，当为APPLY计算第一个参数时，在EVAL中对VALUE的引用，可以被到EVAL的引用代替；如果一个变量出现在组合的操作符位置，这是做相同的事，并且允许附加的普遍能力去使用任何表达式来计算过程。这个差异事实上出现在LISP 1.5解释器里。这有轻微的不同，比如对原语操作符的表示以及对不是原语或用户定义的过程的处理。除此之外，我们的解释器与LISP 1.5的最大区别是对lambda 记号的使用。我们将在下一节讨论。</p>

<h4 id="section-1">局部过程</h4>
<p>Local Procedures</p>

<p>We now have the ability to define and use the MAPCAR procedure.
After some more experience in programming, however, we find that, having
abstracted the common pattern from our loops, that the remaining part (the
functional argument) tends to be different for each invocation of MAPCAR.
Unfortunately, our language for all practical purposes requires that we use
a name to refer to the functional arguments, because the only way we have
to denote new procedures is to DEFINE names for them. We soon tire of
thinking up new unique names for trivial procedures:</p>

<p>我们现在有能力定义和使用MAPCAR过程。但是，有过一些编程经验之后，我们发现，在从我们的循环提取的共通模式之后，对每个MAPCAR的调用，剩下的部分常常不同。不幸的是，我们的语言针对所有实际目的，要求我们使用一个名字去引用函数化参数，因为我们表示一个新过程的唯一方式，是为它们定义名字。我们很快对无关紧要的过程想一个新的唯一的名字感到厌倦。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FOOBAR-43</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">X</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="o">...</span> <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">FOOBAR-43</span> <span class="nv">L</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We run the risk of name conflicts; also, it would be nice to be able to
write the procedure definition at the single point of use.</p>

<p>我们承担名字冲突的风险；而且，能够在唯一使用点去写过程的定义，是极好的。</p>

<p>More abstractly, given that procedures have become referenceable
objects in the language, it would be nice to have a notation for them as
objects, or rather in way to write an S-expression in code that would
evaluate to a procedure. LISP [LISP 1M] adapted such a notation from the
λ-calculus of Alonzo Church [Church]:</p>

<p>更抽象地，如果过程在语言中变成可引用的对象，那么有一个把他们当做对象的记号，是不错的，而非在代码中写一个对过程求值的S-表达式。LISP [LISP 1M] 从Alonzo Church那里采纳了这样的记号[Church]：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">variables</span><span class="p">)</span> <span class="nv">&lt;body&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Comparing this with the DEFINE notation, we see that it has the same parts:
a keyword so that it can be recognized; a list of parameters; and a body.
The only difference is the omission of an irrelevant name. It is just the
right thing.</p>

<p>将它与DEFINE记号比较，我们看到，它有相同的部分：一个关键字，从而它能被识别；一个参数列表；和一个主题。唯一的区别是省略了无关紧要的名字。它恰恰是正确的事。</p>

<p>Given this, we can simply write</p>

<p>如果有这个，我们能简单地写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">X</span><span class="p">))</span> <span class="nv">L</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rather than having to define SQUARE as a separate procedure. An additional
benefit is that this notation makes it very easy for a compiler to examine
this code and produce an efficient iterative implementation, because all
the relevant code is present locally (assuming the compiler knows about
MAPCAR).</p>

<p>而非必须将SQUARE定义为单独的过程。一个附加的好处是，这个记号让编译器很容易检验这个代码，并产生有效的迭代实现，因为所有相关的代码都在局部提供了(假设编译器知道MAPCAR)。</p>

<p>Installing this notation requires only a two-line change in EVAL (see Figure 6).</p>

<p>加上这一记号仅需EVAL有两行代码的改变。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">ExP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;LAMBDA</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CONS</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">ENV</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE see Figure 3.</em>
<em>For APPLY, EVCOND, and EVLIS see Figure 5.</em></p>

<center>
Figure 6
<br />
Evaluator for LAMBDA-notation (Dynamically Scoped)
</center>

<p>(The reader might have noticed that all EVAL does for a LAMBDA-
expression is replace the word LAMBDA with the word &amp;PROCEDURE, and that we
could avoid that work by uniformly using LAMBDA instead of &amp; PROCEDURE as the
flag for an procedural object. Given then that EVAL on a LAMBDA-expression
is an identity operation, we can eliminate the handling of LAMBDA in EVAL
merely by requiring the user to write ‘(LAMBDA …) instead of (LAMBDA .).
Although the implementors of most LISPs have in fact done just this ever
since LISP 1, it is a very bad idea. EVAL is supposed to process
expressions and produce their values, and the fact that it might be
implemented as an identity operation is no business of the user. The
confusion between a procedural object and an expression having that object
as its value will lead to serious trouble. (Imagine confusing 15 with
(+ 7 8), and trying to take the car of the former instead of the latter, or
trying to add 3 to the latter instead of the former!) The quoted LAMBDA-
expression engineering trick discourages the implementation of a
referentially transparent LISP. In Part Four we will see the extreme
difficulties for a LISP compiler (or other program-understander) caused by
the blatant destruction of referential transparency. {Note QUOTE Shafts
the Compiler})</p>

<p>(读者可能注意到EVAL对一个LAMBDA表达式所做的所有事，就是将词LAMBDA替换为词&amp;PROCEDURE，我们能避免这个工作，通过统一使用LAMBDA而非&amp;PROCEDURE作为一个过程对象的标记。然后如果EVAL在LAMBDA表达式上是一个恒等操作，我们能去掉对EVAL中对LAMBDA的处理，仅仅通过要求用户写’(LAMBDA …) 而非 (LAMBDA .)。虽然自从LISP1，绝大多数LISP的实现器事实上恰恰这么做的，但这是个坏主意。EVAL被假定去处理表达式并产生它们的值，它可能以恒等操作来实现的事实不是用户的事情。过程对象和一个带有那个对象作为其值的表达式，会混淆，这将导致严重的麻烦。(想象混淆 15 和 (+ 7 8)，试试对前者而非后者取car，或者给后者而非前者加3! ) 被引用的LAMBDA表达式工程技巧，阻碍了实现一个引用透明的LISP。在第4部分，我们将看到由于对引用透明性明显的破坏，导致的LISP编译器的极端困难。{Note QUOTE Shafts
the Compiler})</p>

<p>The ability to use free variables and local procedures gives us
additional freedom to express interesting procedures. For example, we can
define a procedure SCALE which multiplies a vector of arbitrary length by a
scalar. If the vector is represented as a list of components, then we can
use MAPCAR and a local procedure with a free variable:</p>

<p>使用自由变量和局部过程的能力，给我们额外的自由去表达有趣的过程。例如，我们能定义一个过程SCALE，它能让任意长度的向量乘以一个标量。如果向量被表达为分量的列表，那么我们使用MAPCAR和一个带有自由变量的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SCALE</span> <span class="nv">S</span> <span class="nv">V</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">S</span><span class="p">))</span>
</span><span class="line">                <span class="nv">V</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Everything would be just peachy keen, except for one small glitch.
Suppose that the programmer who wrote SCALE for some reason chose the name L
rather than S to represent the scalar:</p>

<p>所有事情都看起来是极好的，除过一个小差池。假使写SCALE的程序员由于某些原因，选择了名字L而非去表达标量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SCALE</span> <span class="nv">L</span> <span class="nv">V</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                <span class="nv">V</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Although the version with S works, the version with L does not work. This
happens because MAPCAR also uses the name L for one of its arguments (that
is, a “local” variable). The reference to L in the LAMBDA-expression in
SCALE refers to the L bound in MAPCAR and not to the one bound by SCALE. In
general, free variable references in one procedure refer to the bindings of
variables in other procedures higher up in the chain of calls. This
discipline is called dynamic scoping of variables, because the connection
between binding and reference is established dynamically, changing as
different procedures are executed.</p>

<p>虽然带S的版本能运行，但是带L的版本却不行。这是因为MAPCAR使用名字L作为它的参数 (也就是，一个局部变量)。在SCALE中的LAMBDA表达式中对L的引用，引用了绑定在MAPCA中的L，而不是由SCALE绑定的那个。普遍地讲，在一个过程中自由变量的引用指向了在调用链中更高层次的其它过程。这个纪律称为变量的动态绑定，因为绑定和引用之间的连接是动态建立的，随着所执行过程的不同而变化。</p>

<p>That the behavior of the SCALAR program depends on the choice of
names for its local variables is a violation of referential transparency.
The modularity of the MAPCAR abstraction has been destroyed, because no one
can use that abstraction without understanding the details of its
implementation. This is the famous “FUNARG problem” [Moses] [LISP
History].</p>

<p>SCALAR程序的行为依赖于它局部变量名称的选择，这一行为，是对引用透明性的侵犯。MAPCAR抽象的模块化被破坏了，因为如果不了解其实现的细节，没有人能使用此抽象。这是著名的”FUNARG 问题“[Moses] [LISP
History]。</p>

<p>If we are to avoid such conflicts between different uses of the same name, we must arrange our language so that the choice of names locally cannot have global repercussions. More specifically, we must have the ability to bind a variable in such a way that it will have a truly local meaning (though in general we might not want all variables to be strictly local -— we will consider later the possibility of having several types of variables).</p>

<p>如果我们要避免相同名称的不同使用之间的冲突，我们必须组织我们的语言使得在局部选择的名字不具有全局的余波。更明确第，我们必须能够这样绑定一个变量，使得它有真正的局部含义 （尽管通常我们不可能想让所有变量都是严格局部的 – 我们将随后考虑有这几种变量类型的可能性)。</p>

<h4 id="section-2">词法范围</h4>
<p>Lexical Scoping</p>

<p>We now construct an interpreter in which all variables have
strictly local usage. This discipline is called lexical scoping of
variables, and has been used in many programming languages, including Algol
60 [Naur]. The term “lexical” refers to the fact that all references to a
local variable binding are textually apparent in the program. The term
static binding is also used, indicating that the connection between binding
and reference is unchanging at run time.</p>

<p>我们现在构造一个解释器，在其中所有的变量都是严格局部使用的。这个纪律被称为变量的词法范围，而且已经被用在很多语言，包括Algol 60  [Naur]。术语”词法”指代这样的事实，所有对一个局部变量绑定的引用，都在程序中文笔可见。术语静态绑定也被使用了，指示绑定和引用在运行时是不改变的。</p>

<p>The difficulty in SCALE is that the body of the LAMBDA-expression
(* X L) is evaluated using the ENV which was available to EVAL (and so passed
to APPLY) when it was working on the body of MAPCAR. But we want the (* x L)
to be evaluated using the ENV which was available when the body of SCALE was
being evaluated. Somehow we must arrange for this environment to be available for evaluating(* X L).</p>

<p>在SCALE中的困难是，LAMBDA表达式 (* X L) 通过使用ENV被求值。当EVAL对MAPCAR的主体工作时，ENV对EVAL是可用的(因此被传递给APPLY)。但是我们想使用ENV对(* X L)求值时，ENV在SCALE的主体被求值时是可用的。我们必须安排这个环境从而对求值(* X L)是可用的。</p>

<p>The correct environment was available at the time the LAMBDA-
expression was evaluated to produce a &amp;PROCEDURE—object. Why not just tack
the environment at that point onto the end of the &amp;PROCEDURE-object so that
it can be used when the procedure is applied?</p>

<p>当前的环境在LAMBDA表达式被求值而产生&amp;PROCEDURE对象是可用的。为什么不在&amp;PROCEDURE对象终止的店商跟踪环境，从而环境能在过程应用时被用到？</p>

<p>This is in fact the right thing to do. The object we want to give
to MAPCAR must be not just the text describing the computation to be
performed, but also the meanings of the free variables referenced in that
text. Only the combination of the two can correctly specify the
computation which reflects the complete meaning of the abstract function to
be mapped. This is the first place where we find it crucial to distinguish
the three ideas: (1) The program — the text describing a procedure, e.g.
in the form of an S-expression; (2) The procedure which is executed by the
computer; and (3) The mathematical function or other conceptual operation
computed by the execution of the procedure.</p>

<p>这就是事实上要做的正确事情。我们想给MAPCAR的对象必须不仅是描述计算的问题，而且要有引用在文本中的自由变量的含义。只有组合这二者才能正确地指定计算，它可以反映所映射函数的完全含义。这就是我们发现区分三个想法如此重要的第一个地方：(1) 程序 - 描述过程的问题，例如，以S表达式的形式；(2) 被计算机执行的过程; 以及 (3) 执行过程所要计算的数学函数或其它概念性计算。</p>

<p>To install lexical scoping in our interpreter, we must change the treatment of LAMBDA—expressions in EVAL to make the current environment ENV part of the &amp;PROCEDURE-object. We say that the procedure is closed in the current environment, and the &amp;PROCEDURE-object is therefore called a closure of the procedure, or a closed procedure. We must also change APPLY to bind the new variable—value associations onto the environment in the &amp;PROCEDURE-object, rather than onto that passed by EVAL. When we have done this, we see that in fact the environment passed by ENV is not used, so we can eliminate the parameter ENV from the definition of APPLY, and change the invocation of APPLY that occurs in EVAL. Thus, while the handling of LAMBDA-expressions has become more complicated, the handling of ENV has been correspondingly simplified. (See Figure 7.)</p>

<p>为了在我们的解释器中安装词法范围，我们必须改变EVAL中对LAMBDA表达式的处理，让当前环境是&amp;PROCEDURE-object对象的一部分。我们说过程在当前环境被关闭，&amp;PROCEDURE 对象因此被称为过程的闭包，或者一个闭合的过程。我们也必须改变APPLY，以便将新的对象-值联合绑定到&amp;PROCEDURE对象的环境中，而非到由EVAL传递的那个对象。当我们这么做之后，我们看见事实上，由ENV传递的对象没有被用到，因此我们能将参数ENV从APPLY的的定义去掉，并改变发生在EVAL中对APPLY的调用。因此，尽管处理LAMBDA-表达式变得更复杂了，但是对ENV的处理却相应地简单了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;LAMBDA</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">LIST</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="ss">&#39;&amp;PROCEDURE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="p">(</span><span class="nv">CADDDR</span> <span class="nv">FUN</span><span class="p">))))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE and BIND see Figure 3.
For EVCOND and EVLIS see Figure 5.</em></p>

<center>
Figure 7
<br />
Evaluator for Lexically Scoped LAMBDA—notation
</center>

<p>Had we previously adopted the trick described in the preceding
section, wherein the user was required to write ‘UAMMm H.) rather than
(LAMBDA…), it would have been more difficult to adjust the interpreter to
accommodate lexical scoping — it would have involved a large change rather</p>

<p>. than a small tweak. (The change from dynamic scoping to lexical scoping</p>

<p>does involve a gross change of programming style, and this is undoubtedly
why, once dynamic scoping had historically become the standard discipline,
the quotation problem was never cleared up. We will see later that dynamic
Steele and Sussman 22 The Art of the Inter rater</p>

<p>scoping is a valuable technique for producing modularity, but we see no
virtue at all in the confusion produced by quoted LMm0A-expressions. While
quoted LAMBUA-expressions do produce dynamic scoping, the support of dynamic
scoping does not depend on the quotation of LMmnA—expressions.)</p>

<p>while lexical scoping solves our problems of referential
transparency, we will see later that we must in turn pay a large price for</p>

<p>it —— but it is not a price of run—time efficiency (contrary to popular
belief)!</p>

<p>Let’s see what we have bought. One thing we can do is generalize
MAPCAR. After yet more programming experience we find that we write many
MANMR-like procedures. For example, we might need a kind of HMWAR where
the function F always returns a list, and we want to produce not a list of
the lists, but the concatenation of the lists. We might also want to take
the sum or the product of all the numbers in a list, or the sum of the cars
of all elements in a list. The general pattern-is that we 1ook.at each
element of a list, do something to it, and then somehow combine the results
of all these elementwise operations. Another application might be to check
for duplicates in a list; for each element we want to see whether another
copy follows it in the list. We further generalize the pattern to look at
successive trailing segments of the list; we can always take the car to
Steele and Sussman A 23 The Art of the Inter reter
<strong>__</strong><strong>__</strong>,<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><em>JL</em>___</p>

<p>get a single element.
we could simply add more procedural parameters to MMAR:</p>

<p>(DEFINE (MAP F OP 10 L)
(COND ((NuLL L) 10)
(T (oP (F L)
(MAP F OP ID (CDR L))))))
Using this, we can make a copy of the list L:
(MAP CAR CONS ‘() L)
we can simulate (MMARF Ln
(MAP (LAMBDA (X) (F (CAR x))) cows ‘() L)</p>

<p>Indeed, we can write:</p>

<p>(DEFINE (MAPCAR F L) ‘
(MAP (LAMBDA (X) (F (CAR  CONS ‘() L))</p>

<p>We can sum the elements of L:
(MAP CAR + 0 L)</p>

<p>we can take the product of the elements of L:</p>

<p>(MAP CAR A 1 L)</p>

<p>we can count the pairs of duplicate elements of L:</p>

<p>(MAP (LAMBDA (x) x)
(LAMBDA (Y N) (coup ((MEMBER (CAR Y) (con Y))
(+ N 1))</p>

<p>(T N)))
0</p>

<p>L)</p>

<p>If we have occasion to take the sum over lots of lists in different</p>

<p>places, we might want to package the operation “sum over list“ —- we get
awfully tired of writing “CAR4-0”. we can write:</p>

<p>(DEFINE (MAPGEN r OP ID)
(LAMBDA (L) (MAP F op 10 L)))</p>

<p>The result of (MMmENcAP+-o) we might call sun-— it is a procedure of one
argument which will sum the elements of a list. The reason we wrote a
procedure to construct sum, rather than just writing:
Steele and Sussman 24 ‘ The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong>~<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__<em>£</em></strong>_</p>

<p>(DEFINE (sum L)
(MAP CAR + o L))</p>

<p>is that MANHN serves as a generalized constructor of such procedures, thus
capturing an interesting abstraction-— we might call the result of (MAPGEN
CAR « 1), for example. PRONET, and so on. L</p>

<p>What is interesting about this is that we can write procedures
which construct other procedures. This is not to be confused with the
ability to construct S-expression representations. of procedures; that
ability is shared by all of the interpreters we have examined. The ability
to construct procedures was not available in the dynamically scoped
interpreter. In solving the violation of referential transparency we seem
to have stumbled across a source of additional abstractive power. While
the MAP example may seem strained, this example is quite natural: given a
numerical function, to produce a new function which numerically
approximates the derivative of the first.</p>

<p>(DEFINE (DERIVATIVE F AX)
(LAMBDA (x)
(/ (— (F (+ X AX))
(F X))
AXH)</p>

<p>Notice that this is not a symbolic process dealing with the representation
of F. The DEMVAHVE procedure knows nothing about the internal structure of
F. All it does is construct a new procedure which uses F only by invoking
it. The program tmaxvnnvz captures (in approximation) the abstraction of</p>

<p>“derivative” as a mapping from the space of numerical (and reasonably well-
behaved!) functions to itself.</p>

<p>The ability to define procedures which construct other procedures
is powerful. we,can use it to construct procedures which behave like data</p>

<p>objects. For example, since the only constraints which cons must (so far)
obey are the algebraic identities:</p>

<p>(CAR-(CONS a 3)) = a and (con (cons a ﬁ)) = 3</p>

<p>the value of (emu a G) can be thought of as a procedure which produces a or</p>

<p>8 on demand (cf. [Hewitt and Smith] [Fischer]). We can write this as
follows: i</p>

<p>(DEFINE (cows A o)
(LAMBDA (M)
(COND ((= M o) A)
((= M 1) D))))</p>

<p>(DEFINE (CAR X) (X 0))</p>

<p>(DEFINE (COR X) (X 1))
Steele and Sussman 25 The Art of the Inter reter
<strong>__</strong><strong>__H</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__<em>£</em></strong>_</p>

<p>Here we have envisioned the value of unusa G) as a vector of two elements,
with zero—origin indexing. However, this definition of cows makes use of
the primitive operator =. we can define the “primitive operators“ cons,
CAR, and can without using another primitive operator at all! Following
[Church], we write:</p>

<p>(DEFINE (cows A 0)
(LAMBQA (M) (M A D)))</p>

<p>(DEFINE (CAR X)
(X (LAMBDA (A D) A)))</p>

<p>(DEFINE (CUR X)
(X (LAMBDA (A D) D)))</p>

<p>Rather than using 0 and 1 (i.e. data objects) as selectors, we instead use
(LAMBOA (A 0) A) and (LAMBDA(A D) 0) (i.e. procedures).</p>

<p>we can think of the LMmnA-expression which appears as the body of
the definition of DERWATWE or of ams as a prototype for new procedures.
when DERIVATIVE or cows is called, this prototype is instantiated as a
closure, with certain variables free to the prototype bound to the
arguments given to the constructor.</p>

<p>At this point it looks like we have solved all our problems. We
started with a referentially transparent but expressively weak language.
We augmented it with procedural objects and a notation for them in order to
capture certain notions of abstraction and modularity. In doing this we
lost the referential transparency. we have now regained it, and in the
process uncovered even more powerful abstraction capabilities.</p>

<p>Top Levels versus Referential Transparency</p>

<p>“The Three Laws of Thermodynamics:
1. You can’t win.
2. You can’t break even.
3. You can’t get out of the game.”
— Unknown</p>

<p>There is no free lunch. We have ignored a necessary change to the
top level driver loop. we have changed the format of avmmemme-objects.
onxvkk-LooP—1 constructs &amp;PRmxnuR£—objects; it must be rewritten to
accommodate the change. We must include an environment in each such
object. The obvious fix is shown in Figure 8.
Steele and Sussman 26 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>£</strong>___</p>

<p>(DEFINE (DRIVER—LO0P-1 ENV FORM)
(COND ((ATOM FORM)
(DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
((EO (CAR FORM) ‘DEFINE)
(DRIVER-LOOP (BIND (LIST (CAADR FORM))
(LIST (LIST ‘&amp;PROCEDURE
(CDADR FORM)
(CADDR FORM)
ENV))
ENV)</p>

<p>(PRINT (CAADR FORM))))
(T (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))))</p>

<p>For onxvewioov see Figure 1.
For BIND see Figure 3.
For EVAL see Figure 7.</p>

<p>Figure 8
Modified Driver Loop for Lexically Scoped LAMBDA-notation</p>

<p>It doesn’t work. This patch does put the finishing touch on the
preservation of referential transparency. It does it so well, that each
new definition can only refer to previously defined names! We have lost
the ability to make forward references. we can’t redefine a procedure
which had a bug in it and expect old references to use the new definition.
In fact, we cannot use DEFHE to make a recursive procedure. {Note Y-
operator} The avmmsmme-object for each defined procedure contains an
environment having only the previously defined procedures.</p>

<p>We are finally confronted with the fact that we have been seeking
the impossible._ We have tried to attain complete referential transparency
(in the expectation that modularity would be enhanced), while trying also
to retain the notion of an incremental, interactive top—level loop for
reading definitions. But the very existence of such a top level inherently
constitutes a violation of referential transparency. A piece of code can
be read in which refers to an as yet undefined identifier (the name of a
procedure, for example), and then later a definition for that identifier
read in (thereby altering the meaning of the reference).</p>

<p>If we stubbornly insist on maintaining absolute referential
transparency in our language, we are forced to eliminate the incremental
top level loop. A program must be constructed monolithically. We must
read in all our procedure definitions at once, close them all together, and
then take one or more shots at running them. (This is the way many Algol
implementations work; development of large systems can be very difficult
if parts cannot be separately constructed and compiled.) We are forced to
give up interactive debugging, because we cannot redefine erroneous</p>

<p>procedures easily. We are forced to give up incremental compilation of
separate modules.
.St’ee1e and Sussman 27 The Art of the Inter rater</p>

<p>we have thrown the baby out with the bath water. The very purpose
of referential transparency is to permit programs to be divided into parts
so that each part can be separately specified without a description of its
implementation. The desirable result is that pieces can be separately
written and debugged. {Note Debugging}</p>

<p>On the other hand, if we give up absolute referential transparency,
we can fix the top level_ loop. The basic problem is that we really want
procedures defined at top l.eve.l to be able to refer to procedures defined
later. The problem with pure lexical scoping is that the apnocaouke-objects
are created too early, when the desired environment is not yet available.
we must arrange for them to be constructed at a later time. We could
simply use the environment in use by the caller at the time of invocation
(reverting to dynamic scoping). But dynamic scoping would lose a great
deal of referential transparency and abstractive power. Procedures must
not be allowed to refer to variables internal to other procedures, but only
to top—1eve1 variables existing at the time they are called. Therefore
only the future top-level environment is to be included in the &amp;PROCEDURE-
object when it is eventually constructed. In this way free variable
references will be dynamic only with respect to the top-level environment.</p>

<p>Considering our dynamically-scoped interpreter above (see Figure
5). we would be led toimodify APPLY again, to combine the best properties
of the dynamically and lexically scoped interpreters. Indeed, the two
kinds of function can easily coexist. We borrow the code involving the
passing of PROCEDURES (including the DRIVER-LOOP, modified to initialize euv to
PROCEDURES) from the recursion-equations interpreter (Figures 1 and 2), the
code for using this top—level environment from the dynamically—scoped
interpreter (Figure 5), and the code for constructing 8-PROCEDURE-Objects for
LAMaoA-expressions from the lexically-scoped interpreter (Figure 7).. The
result appears in Figure 9. ‘
Steele and Sussman ‘ 26 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>J1</strong>___</p>

<p>(DEFINE (EVAL EXP ENv PROCEDURES)
(coND ((ATOM EXP)
(COND ((NUMBERP EXP) EXP)
(T (VALUE EXP ENv))))</p>

<p>((Eo (CAR EXP) ‘QUOTE)</p>

<p>(CADR ExP))
((Eo (cAR EXP) ‘LAMBDA)</p>

<p>(LIST ‘&amp;PROCEDURE (CADR EXP) (CADDR EXP) ENV))
((Eo (CAR EXP) ‘COND)</p>

<p>(EvcoND (CUR EXP) ENv PRocEDuREs))</p>

<p>(T (APPLY (EvAL (CAR EXP) ENv PROCEDURES)</p>

<p>(EvLIs (CUR EXP) ENV PROCEDURES)
PRocEDuREs))))</p>

<p>(DEFINE (APPLY FUN ARGS PRocEDuREs)
(COND ((PRlMOP FUN) (PRIMOP—APPLY run ARGS))
((Eo (CAR run) ‘&amp;PROCEDURE)
(EVAL (cADDR FUN)
(BIND (CADR FUN) ARGS (CADDDR FUN))
PROCEDURES))
(T (EVAL (cADR FUN)
(BIND (cAR FUN) ARGS PRocEouREs)
PRocEDuREs))))</p>

<p>(DEFINE (DRIVER-LooP-I PROCEDURES FORM)
(coND ((AToN FORM)
(DRIVER-LooP PROCEDURES
(PRINT (EVAL FORM PROCEDURES PRocEDuREs))))
((Eo (cAR FORM) ‘DEFlNE)
(DRIVER-LOOP (BIND (LIST (cAADR FORM))
(LIST (LIsT (CDAUR FORM) (CADDR FORM)))
PROCEDURES)
(PRINT (cAADR FORM))))
(T (DRIVER-LooP PROCEDURES
(PRINT (EVAL FORM PROCEDURES PRocEDuREs))))))</p>

<p>For DRIVER-LooP see Figure 1.
For VALUE and BIND see Figure 3.
For EvcoND and EvLIs see Figure 2.</p>

<p>Figure 9
An Evaluator for Local Lexical Scoping
and Dynamic Top-Level References</p>

<p>Ugh bletch, PmmEmmEs is back! Also, there are two kinds of user-
defined procedural objects floating around. There happens to be another
way to fix the top level, which yields additional flavor. We note that
Steele and Sussman 29 The Art of the Inter reter</p>

<p>during any one processing cycle of EVAL/APPLY, PROCEDURES remains constant.
We can thus choose to associate the top level environment with a top-level
procedure at a time earlier than invocation time in APPLY. we also note
that LOOKUPI will have its hands on the top-level environment anyway just
before it locates the definition of a top-level procedure. Exploiting this
idea yields an alternate solution. {Note LABELS}</p>

<p>In the new driver (see Figure 10) loop we no longer use BIND to
augment the top-level environment whenever a new definition is made. We
instead have all of the top-level definitions in one frame of the
environment. when a new definition is to be made we extract the list of
names and the list of values for the old definitions from the old
environment and make a new top—leve1 environment with the lists of names
and values separately augmented.</p>

<p>Instead of creating aprzocwune-objects, this driver loop creates
&amp;LABELED-Objects, which have the same format except that they contain no
environment. A a.LAB£LEo—object is purely internal and can never be seen by
a user program. when LOOKUPI encounters such an object as the value of a
variable, it immediately creates the corresponding apnoceounrobject, using
the environment a-t hand, which turns out to be the top-level environment.
Stee1e and Sussman 30 The Art of the Inter reter
<strong>__<em>.</em></strong><strong>__</strong><strong>i</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__.</strong><strong>__</strong><strong>__</strong><strong>__JL</strong>__</p>

<p>(DEFINE (DRIVER—LO0P-1 ENV roan)
(cono ((ATOM FORM)
(DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
((50 (CAR FORM) ‘DEFlNE)
(DRIVER-LOOP (LIST (cons (cons (CAADR FORM) (CAAR ENV))
(cons (LIST ‘&amp;LABELEO
(CDADR roan)
(CADUR FORM))
(CDAR ENV))))
(PRINT (CAADR FORM))))
(T (DRIVER-LOOP ENV (PRINT (EVAL roan euv))))))</p>

<p>(DEFINE (LOOKUP1 NAME VARS VALS ENV)
(couo ((NULL VARS)
(LOOKUP NAME (con ENV)))
((50 NAME (CAR VARS)) 4
(COND ((ATOM (CAR VALS)) VALS)</p>

<p>((50 (CAAR VALS) ‘&amp;LABELED)
(LIST ‘&amp;PROCEDURE (CADAR VALS) (CADDAR VALS) euv))
(T VALS)))</p>

<p>(T (LOOKUPI NAME (CDR VARS) (COR VALS) ENV))))</p>

<p>_ For DRIVERJDOP see Figure 1.
For LOOKUP see Figure 3.
For EVAL see Figure 7.</p>

<p>Figure 10
An Alternative Solution for Local Lexical Scoping
and Dynamic Top-Level References
(Modified Top—Leve1 Driver Loop and Environment Lookup)
Steele and Sussman 31 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__JL</strong>__</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/the-art-of-interpreter-part-0/">The Art of Interpreter: Part Zero</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-18T16:52:51+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>4:52 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="lisp">第零部分： LISP和解释器</h3>
<p>Part Zero 
LISP and Interpreters</p>

<h4 id="section">递归方程</h4>
<p>Recursion Equations</p>

<p>Contrary to popular belief, LISP was not originally derived from
Church’s λ—calculus [Church] [LISP History]. The earliest LISP did not
have a well—defined notion of free variables or procedural objects. Early
LISP programs were similar to recursion equations, defining functions on
symbolic expressions (“S—expressions”). They differed from the equations
of pure recursive function theory [Kleene] by introducing the conditional
expression construction (often called the “McCarthy conditional”), to avoid
“pattern-directed invocation”. That is, in recursive function theory one
would define the factorial function by the following two equations:</p>

<p>与流行的说法相反，LISP最初不是从邱奇的λ演算中派生出来的。最早的LISP没有一个对自由变量和过程对象的良好定义的记号。早期的LISP程序与递归方程类似，在符号表达式(“S-expressions”)上定义函数。他们不同于纯粹递归函数理论公式，是在于引入了条件表达式构造(经常称为”McCarthy条件”)，从而避免“模式导向的调用”。也就是，在递归函数理论中，可以通过如下两个方程定义阶乘函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="nb">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nv">factoria1</span><span class="p">(</span><span class="nv">successor</span><span class="p">(</span><span class="nv">x</span><span class="p">))</span> <span class="nb">=</span> <span class="nv">successor</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nb">*</span> <span class="nv">factorial</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In early LISP, however, one would have written:</p>

<p>但是在早期的LISP中，需要写成这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factoria1[x]</span> <span class="nb">=</span> <span class="nv">[x=0</span> <span class="nv">-&gt;</span> <span class="mi">1</span><span class="c1">; T -&gt; x*factorial[x-1]]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where “[a -&gt; b; T —&gt; c]” essentially means “if a then b else c”. The
recursive function theory version depends on selecting which of two
equations to use by matching the argument to the left-hand sides (such a
discipline is actually used in the PROLOG language [Warren]); the early
LISP version represents this decision as a conditional expression.</p>

<p>这里 [a -&gt; b; T —&gt; c] 根本上意指 “如果a就b，或者c”。这个递归函数理论的版本在于，通过将参数匹配到左侧(这样的规则的确在PROLOG语言中用到)，来选择要使用哪个公式；早期的LISP版本将这个决策表示为一个条件表达式。</p>

<p>The theory of recursion equations deals with functions over the
natural numbers. In LISP, however, one is interested in being able to manipulate algebraic expressions, programs, and other symbolic expressions
as data structures. While such expressions can be encoded as numbers
(using the technique of “arithmetization” developed by Kurt Godel), such an
encoding is not very convenient. Instead, a new kind of data called “S-
expressions” .(for “symbolic expressions”) is introduced specifically to
provide convenient encodings. S-expressions can be defined by a set of
formal inductive axioms analogous to the Peano Postulates used to define
natural numbers. Here we will give only an informal and incomplete definition of S—expressions; for a more complete description, see {Note S-
expression Postulates and Notation}.</p>

<p>递归公式处理自然数的函数。然而，在LISP里，人们的兴趣在于能够操作代数表达式、程序和如数据结构一样的符号表达式。虽然这样的表达式能用数字编码(使用Kurt Godel开发的”算术化“技术)，但这样的编码不是很方便。相反，一种称为”S表达式“(即：符号化表达式, symbolic expression)的新的类型的数据被特别引入进来，为了提供方便的编码。S-表达式能通过一组正规的归纳公理来定义，它与Peano假定用以定义自然数的类似。这里，我们仅给出一个非正规和不完备的S表达式定义；对于一个更为完备的描述，请看注释{Note S-
expression Postulates and Notation}。</p>

<p>For our purposes we will need only the special cases of S-expressions called atoms and lists. An atom is an “indivisible” data object, which we denote by writing a string of letters and digits; if only digits are used, then the atom is considered to be a number. Many special characters such as “-“ and “+” are considered to be letters; we will see below that it is not necessary to specially reserve them for use as operator symbols. A list is a (possibly empty) sequence of S—expressions, notated by writing the S—expressions in order, between a set of parentheses and separated by spaces. A list of the atoms “F00”, “43”, and “BAR” would be written “(F00 43 BAR)”. Notice that the definition of a list is
recursive. For example,</p>

<p>对于我们的目的，我们只需要S表达式特殊的情形，称为atom和list。一个“原子”是不可分割的数字对象，我们表示为字母和数字的串；如果只用到数字，那么原子就被认为是数字。许多特殊的字符，比如”-“和”+“，被认为是字母；我们将在后面看到，没有必要特别地将它们保留下来作为操作符号。一个列表是S表达式的序列(可能是空的)，表示为按顺序写S表达式，用空格分开，在一组括号中间。原子”F00”, “43”和”BAR”的列表写为”(FOO 43 BA)”。注意列表的定义是递归的。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SECOND</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CAR</span> <span class="p">(</span><span class="nv">CUR</span> <span class="nv">X</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>is a list of three things: the atomic symbol DEFINE, a list of the two
atomic symbols SECOND and X, and another list of two other things.</p>

<p>是有3个事物的列表：原子符号 DEFINE，一个有两个原子符号SECOND和X的列表，和另一个列表，它包含两个其它事物。</p>

<p>We can use S-expressions to represent algebraic expressions by
using “Cambridge Polish” notation, essentially a parenthesized version of
prefix Polish notation. Numeric constants are encoded as numeric atoms;
variables are encoded as non—numeric atoms (which henceforth we will call
atomic symbols); and procedure invocations are encoded as lists, where the
first element of the list represents the procedure and the rest represent
the arguments. For example, the algebraic expression “a<em>b+c</em>d” can be
represented as “(+ (* a b) (* c d))”. Notice that LISP does not need the
usual precedence rules concerning whether multiplication or addition is
performed first; the parentheses explicitly define the order. Also, all
procedure invocations have a uniform syntax, no matter how many arguments
are involved. Infix, superscript, and subscript notations are not used;
thus the expression “$J_p (x^2+1)$” would be written “(J p (+ (^ x 2) 1))”.</p>

<p>我们通过使用”剑桥波兰“记号来表示代数表达式，它本质上是加括号的前缀波兰版本。数字常数被编码为数字原子；变量被编码为非数字的原子(今后我们将称其为原子符号)；一个过程的调用被编码为列表，其中列表的第一个元素代表过程，剩余的部分代表参数。例如，代数表达式”a<em>b+c</em>d”可以表示为”(+ (* a b) (* c d))”。注意LISP不需要通常的优先级规则，比如先执行乘法还是加法；括号已经显式地定义了次序。而且，所有的过程调用有一致的语法，无论有多少个参数。没有用到，中缀、上标或下标：因此表达式”$J_p (x_2+1)$”，将被写成”(J p (+ (^ x 2)1))”。</p>

<p>To encode a conditional expression：</p>

<p>为了编码一个条件表达式：</p>

<script type="math/tex; mode=display">[p_1 -> e_1; p_2 -> e_2; ... ; p_n -> e_n]</script>

<p>(which means to evaluate the predicates p_i in order until a true one is found, at which point the value of $e_j$ is taken to be the value of the
conditional) we write the S-expression</p>

<p>其含义是对判定式p_i按顺序求值，直到发现一个为真，此时$e_j$会被取出作为条件的值。我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">COND</span> <span class="p">(</span><span class="nv">p_1</span> <span class="nv">e_1</span><span class="p">)</span> <span class="p">(</span><span class="nv">p_2</span> <span class="nv">e_2</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nv">p_n</span> <span class="nv">e_n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we can now encode sets of LISP recursion equations as S-expressions. For the equation</p>

<p>我们能将一组LISP递归等式编码为S表达式的形式。对于等式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factoria1[x]</span> <span class="nb">=</span> <span class="nv">[x=0</span> <span class="nv">-&gt;</span> <span class="mi">1</span><span class="c1">; T -&gt; x*factoria1[x-1]]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we write the S-expression</p>

<p>我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">	<span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">X</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">		  <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(we could also have written</p>

<p>(我们也能写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">=</span>
</span><span class="line"><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span>
</span><span class="line"><span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>but we conventionally lay out S-expressions so that they are easy to read.)</p>

<p>但是我们习惯上会排版S表达式以便易于阅读。</p>

<p>We now have a complete encoding for algebraic expressions and LISP
recursion equations in the form of S-expressions. Suppose that we now want
to write a LISP program which will take such an S-expression and perform
some useful operation on it, such as determining the value of an algebraic
expression. We need some procedures for distinguishing, decomposing, and
constructing S-expressions.</p>

<p>我们现在已经有了对代数表达式的完整编码，以及S表达式的形式下的递归等式。假设我们现在想写一个LISP程序，它能拿起这样的S表达式并对其执行一些有用的操作，比如确定代数表达式的值。我们需要一些过程来区分、分解、构造S表达式。</p>

<p>The predicate ATOM, when applied to an S-expression, produces true
when given an atom and false otherwise. The empty list is considered to be
an atom. The predicate NULL is true of only the empty list; its argument
need not be a list, but may be any S-expression. The predicate NUMBERP is
true of numbers and false of atomic symbols and lists. The predicate EQ,
when applied to two atomic symbols, is true if the two atomic symbols are
identical. It is false when applied to an atomic symbol and any other S-
expression. (We have not defined EQ on two lists yet; this will not
become important, or even meaningful, until we discuss side effects.)</p>

<p>断言ATOM，当应用到S表达式上，如果给的是原子，则产生真，否则为假。空列表被认为是一个原子。断言NULL只有对空列表是为真；它的参数不必要是列表，可以是任何表达式。当一个原则符号和列表是数字时，断言NUMBERP是真，否则为假。断言EQ，当应用到两个原子符号时，如果两个原子符号相等，则为真。如果应用到一个原子符号，和任何其他S表达式上，则为假。(我们还没有定义两个列表的EQ；这将不那么重要，或甚至有意义，直到我们讨论副作用。)</p>

<p>The decomposition operators for lists are traditionally called CAR
and CDR for historical reasons. [LISP History] CAR extracts the first
element of a list, while CDR produces a list containing all elements but
the first. Because compositions of CAR and CDR are commonly used in LISP,
an abbreviation is provided: all the C’s and R’s in the middle can be
squeezed out. For example, ‘(CDR (CDR (CAR (CDR X))))’ can be written as
“(CDDADR X)”.</p>

<p>由于历史的原因，列表的分解操作符传统上被称为car和cdr。[LISP History] CAR提取列表的第一个元素，而CDR生成一个除过第一个元素之外的所有剩余元素的列表。因为car和cdr的组合在LISP中经常用到，就提供了一个缩写：所有中间的C和R可以积压出去。例如’(CDR (CDR (CAR (CDR X))))’，可以写为”(CDDADR X)”。</p>

<p>The construction operator CONS, given an S-expression and a list,
produces a new list whose CAR is the S-expression and whose CDR is the
list. The operator LIST can take any number of arguments (a special
feature), and produces a list of its arguments.</p>

<p>构造操作符CONS，给定S表达式和一个列表，生成一个新的列表，其CAR是S表达式，而CDR是列表。操作符LIST能接收任意数目的参数(一个特殊特性)，然后产生这些参数的列表。</p>

<p>We can now write some interesting programs in LISP to deal with S-expressions. For example, we can write a predicate EQUAL, which determines whether two S-expressions have the same CAR-CDR structure:</p>

<p>我们现在可用LISP写一些有趣的程序，来处理S表达式。例如，我们写一个断言EQUAL, 它确定两个S表达式有相同的CAR-CDR结构。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">X</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                       <span class="p">(</span><span class="no">T</span> <span class="no">NIL</span><span class="p">)))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">EQ</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">Y</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class="line">                <span class="p">((</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">Y</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we have used the standard names T and NIL to represent ture and false.
(Traditionally NIL is also considered to be the empty list, but we will
avoid this here, writing “()” for the empty list.)</p>

<p>这里我们使用标准的名字T和NIL来表示和false。(传统上，NIL也被认为是空列表，但是我们将在这里避免这些，写”()”代表空列表)。</p>

<p>Because LISP programs are represented as LISP data structures (S-expressions), there is a difficulty with representing constants. For
example, suppose we want to determine whether or not the value of the
variable X is the atomic symbol “FOO”. we might try writing:</p>

<p>因为LISP程序表示为LISP数据结构(S表达式)，在表达常量时有些困难。比如，假设我们想确定变量X的值是否为原子符号”F00”，我们可能试图写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQ</span> <span class="nv">X</span> <span class="nv">FOO</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This doesn’t work. The occurrence of “FOO” does not refer to the atomic
symbol FOO as a constant; it is treated as a variable, just as “X” is.</p>

<p>这不能奏效。FOO的出现没有将FOO引用为一个常量；它被看做一个变量，如同X一样。</p>

<p>The essential problem is that we want to be able to write any 5-
expression as a constant in a program, but some S—expressions must be used
to represent other things, such as variables and procedure invocations. To
solve this problem we invent a new notation: (QUOTE X) in a program
represents the constant S-expression x. {Note QUOTE Mapping} Thus we can
write our test as “(EQ X (QUOTE FOO)”. Similarly,</p>

<p>本质的问题是，我们想能够在程序中将任何S表达式按照常量的方式书写，但是一些S表达式必须被用来表示其它一些，比如变量和过程调用。为了解决这个问题，我们发明了一个新记号：(QUOTE X)在程序中表示常数S表达式X。{注释： QUOTE Mapping} 因此我们能将我们的测试写为：(EQ X (QUOTE FOO)。类似的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">Y</span> <span class="nv">Z</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>constructs a list from the values of Y and z, and compares the result to
the value of X, while</p>

<p>从X和Y的值中构造一个列表，然后将结果与X的值比较，而：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="p">(</span><span class="nv">QUOTE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">Y</span> <span class="nv">Z</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>compares the value of X to the constant S-expression “(LIST Y Z)”. Because
the QUOTE construction is used so frequently in LISP, we use an abbreviated
notation: “‘FOO” is equivalent to “(QUOTE FOO)”. This is only a notational
convenience; the two notations denote the same S-expression. (S-
expressions are not character strings, but data objects with a certain
structure. We use character strings to notate S-expressions on paper, but
we can use other notations as well, such as little boxes and arrows. We 
can and do allow several different character strings to denote the same S-
expression.) </p>

<p>将X的值与常数表达式(LIST Y Z)去比较。因为在LISP中QUOTE构造经常被用到，我们使用一个缩写记号：”’FOO”等价于”(QUOTE FOO)”。这只是一个记号的惯例。两个记号表示相同的S表达式。(S表达式不是字符串，而是带有特定结构的数据对象。我们使用字符串去表示文章中的S表达式。我们能够且也允许几种不同的字符串去表示相同的S表达式)。</p>

<h4 id="lisp-">LISP 递归等式的解释器</h4>
<p>An Interpreter for LISP Recursion Equations</p>

<p>We now have enough machinery to begin our examination of the
genetic history of LISP. We first present a complete interpreter for LISP
recursion equations. The language interpreted is a dialect of LISP which
allows no free variables except for names of primitive or defined
procedures, and no definitions of procedures within other procedures.</p>

<p>我们现在有足够的机制去开始对LISP起源历史的检视。我们首先展现一个LISP递归等式的完全解释器。被解释的语言是LISP的一个方案，它不允许自由变量，除过原语或已定义过程的名字，在别的过程中没有过程的定义。</p>

<p>The driver loop reads in definitions of procedures of the form:</p>

<p>驱动循环的读取 form的过程定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">F</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">...</span><span class="p">)</span> <span class="nv">&lt;expression</span> <span class="nv">in</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">...</span> <span class="nb">and</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="o">...</span><span class="nb">&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and saves them. It can also read in requests to apply some defined
procedure to some arguments (or, more generally, to evaluate any
expression), in which case it prints the resulting value. An expression
may consist of variable references, constants (numbers and quoted s-
expressions), procedure calls, and conditional expressions (COND). The
defined procedures may refer to each other and to initially supplied
primitive procedures (such as CAR, CONS, etc.). Definitions may contain
“forward references”, as long as all necessary definitions are present at
the time of a request for a computation. The interpreter itself is
presented here as a set of such definitions, and so is meta—circular.</p>

<p>并保存它们。它也能读入请求去将一些定义的过程应用到一些参数(或者，更通常，去求值任意表达式)，在这种情况下它打印结果值。一个表达式可以包含变量引用，常数(数字和引号的S-表达式)，过程调用和条件表达式。被定义的过程可能相互引用，并引用到初始提供的原语过程(比如CAR, CONS，等等)。定义可能包括“向前引用”，只要所有必须的定义在请求计算的那一刻是存在的。这呈现的解释器自身是一组如此的定义，也就是元循环。</p>

<p>The language is intended to be evaluated in applicative order; that is, all arguments to a procedure are fully evaluated before an attempt
is made to apply the procedure to the arguments. (It is necessary to state
this explicitly here, as it is not inherent in the form of the meta-circular definition. See [Reynolds] for an explication of this problem.)</p>

<p>语言打算被按应用的次序去求值；也就是，对一个过程所有的参数都被完全求值之后，才试图将过程应用到参数上。(有必要在这里这里显式地说，这不是元循环定义的形式本自具有的。看[Reynolds]对这个问题的解释。)</p>

<p>The driver loop (see Figure 1) is conceptually started by a request
to invoke DRIVER with no arguments. Its task is to first print the message
“LITHP ITH LITHTENING” (a tradition of sorts) and then invoke DRIVER—LOOP.
The expression <the-primitive-procedures> is intended to represent a constant
list structure, containing definitions of primitive procedures, to be supplied to DRIVER—LOOP.</the-primitive-procedures></p>

<p>驱动循环(看图1)是概念性第启动，通过请求不带参数的调用DRIVER。它的任务首先是打印消息“”LITHP ITH LITHTENING”，然后调用DRIVER-LOOP。表达式<the-primitive-procedures>目的是打印一个常量列表结构，包含原语过程的定义，以便提供给DRIVER—LOOP。</the-primitive-procedures></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">&lt;THE-PRIMITIVE</span><span class="err">—</span><span class="nv">PROCEDURES&gt;</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="ss">&#39;|LITHP ITH LITHTENlNG|</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span> <span class="nv">PROCEDURES</span> <span class="nv">HUNOZ</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span><span class="err">—</span><span class="mi">1</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">READ</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER-LOOP-1</span> <span class="nv">PROCEDURES</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="o">&#39;</span><span class="p">()</span> <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="ss">&#39;DEFINE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))</span>
</span><span class="line">                                  <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CDADR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FORM</span><span class="p">)))</span>
</span><span class="line">                                  <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                            <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="o">&#39;</span><span class="p">()</span> <span class="nv">PROCEDURES</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>
Figure 1
<br />
Top Level Driver Loop for a Recursion Equations Interpreter
</center>

<p>DRIVER-LOOP reads an S—expression from the input stream and passes
it, along with the current procedure definitions, to DRIVER-LOOP-1. This
procedure in turn determines whether the input S-expression is a definition. If it is, then it uses amp (described below) to produce an augmented set of procedure definitions, prints the name of the defined procedure, and calls DRIVER-LOOP to repeat the process. The augmented set of procedures is passed to DRIVER-LOOP, and so the variable PROCEDURES always contains all the accumulated definitions ever read. If the input S-expression is not a definition, then it is given to the evaluator EVAL, whose purpose is to determine the values of expressions. {Note Value Quibble} The set of currently defined procedures is also passed to EVAL.</p>

<p>DRIVER-LOOP 从输入流读一个S表达式，然后将它，连同当前的过程定义，给DRIVER-LOOP-1。这个过程然后确定输入的S表达式是否是一个定义。如果是，则它利用amp(下面描述)来产生一个过程定义的扩充集，打印定义所定义过程的名字，然后调用DRIVER-LOOP来重复过程。扩充的过程集被传输给DRIVER-LOOP，从而变量PROCEDURES总是包含所有曾经读取的累计的定义。如果输入的S表达式不是一个定义，那么它会交给求值器eval，其目的是确定变量的值。{注释：Value Quibble} 当前所定义的过程集也会传输给EVAL。</p>

<p>The process carried on by the driver loop is often called the “top
level”; all user programs and requests are run‘ “under” it. The growing set of procedure definitions is called the “top—level environment”; this environment changes in the course of the user interaction, and contains the state of the machine as perceived by the user. It is within this environment that user programs are executed. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">EQ</span> <span class="nv">EXP</span> <span class="ss">&#39;NIL</span><span class="p">)</span> <span class="ss">&#39;NIL</span><span class="p">)</span>
</span><span class="line">                     <span class="p">((</span><span class="nv">EQ</span> <span class="nv">EXP</span> <span class="ss">&#39;T</span><span class="p">)</span> <span class="ss">&#39;T</span><span class="p">)</span>
</span><span class="line">                     <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                       <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="nv">CLAUSES</span> <span class="nv">ENV</span> <span class="nv">PROCEDURED</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVLIS</span> <span class="nv">ARGLIST</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>                    
Figure 2
<br />
Evaluator for a Recursion Equations Interpreter
</center>

<p>The evaluator proper (see Figure 2) is divided into two conceptual
components: EVAL and APPLY. EVAL classifies expressions and directs their
evaluation. Simple expressions (such as constants and variables) can be
evaluated directly. For the complex case of procedure invocations
(technically called “combinations”), EVAL looks up the procedure
definition, recursively evaluates the arguments (using EVLIS), and then
calls APPLY. APPLY classifies procedures and directs their application.
Simple procedures (primitive operators) are applied directly. For the
complex case of user-defined procedures, APPLY uses BIND to build an
environment, a kind of symbol table, associating the formal parameters from
the procedure definition with the actual argument values provided by EVAL.
The body of the procedure definition is then passed to EVAL, along with the
environment just constructed, which is used to determine the values of variables occurring in the body.</p>

<p>求值器章节(见图2)被分为两概念部分：EVAL和APPLY。EVAL 将表达式分类并引导他们的求值。简单的表达式(比如常量和变量)能直接求值。对于过程调用这样复杂的情形(技术上称为“组合”)，EVAL查找过程定义，递归地对参数求值(使用EVLLIS)，然后调用APPLY。APPLY区分过程，然后引导它们的应用。简单的过程(原语过程)，被直接应用。对于用户所定义过程这样复杂的情形，APPLY使用BIND来构造一个环境，一种符号表，将来自过程定义的正规参数与EVAL所提供的真实参数值关联起来。然后，过程定义体连同构造的环境，被传给EVAL，这个环境用以确定函数体中出现的变量值。</p>

<p>In more detail, EVAL is a case analysis on the structure of the S-
expression EXP. If it is an atom, there are several subcases. The special
atoms T and NIL are defined to evaluate to T and NIL (this is strictly for
convenience, because they are used as truth values). Similarly, for
convenience numeric atoms evaluate to themselves. (These cases could be
eliminated by requiring the user to write lots of QUOTE forms: ‘T, ‘NIL,
‘43, etc. This would have been quite inconvenient in early LISP, before
the “’” notation had been introduced; one would have had to write (QUOTE
43), etc.) Atomic symbols, however, encode variables; the value
associated with that symbol is extracted from the environment ENV using the
function VALUE (see below).</p>

<p>说的更详细一些，EVAL是对S表达式EXP的结构的情形分析。如果它是一个原子，会有几种子情况。特别的原子T和NIL被定义，以便求值出T和NIL(严格说，这是为了方便，因为它们被当真值使用)。类似地，为了方便，数值的原子被定义求值为它们自己。(这种情况可以省掉，通过要求用户写大量的QUOTE forms： ‘T, ‘NIL, ‘43 等等。在”&#8217;”记号被引入之前，这在早期的LISP中很不方便；一个人不得不 (QUOTE 43)，等等) 但是，原子符号编码了变量；使用函数VALUE，把与符号关联的值从环境ENV中提取出来(见下)。</p>

<p>If the expression to be evaluated is not atomic, then it may be a
QUOTE form, a COND form, or a combination. For a QUOTE form, EVAL extracts
the S-expression constant using CADR. Conditionals are handled by EVCOND,
which calls EVAL on a predicate expression; if the predicate is true,
EVCOND evaluates the corresponding result expression (by calling EVAL, of course); if the predicate is false, EVCOND calls itself to test the predicate of the next clause of the COND body. For combinations, the procedure is obtained, the arguments evaluated (using EVLIST), and APPLY called as described earlier. Notice that VALUE is used to get the procedure definition from the set PROCEDURES; we can do this because, as an engineering trick, we arrange for ENV and PROCEDURES to have the same structure, because they are both symbol tables.</p>

<p>如果被求值的表达式不是原子的，那么它可能是一个QUOTE form，一个COND form，或者一个组合。对一个QUOTE form, EVAL使用CADR提取S表达式的常熟。条件语句由EVCOND处理，它在一个判定表达式上调用EVAL；如果判定是真的，EVCOND对相应的结果表达式求值(当然，通过调用EVAL)；如果判定式为假，EVCOND调用自身去测试COND 主体中下一个子句的判定式。对于组合，先得到过程，然后对参数求值(使用EVLIST)，然后如前面所描述那样调用APPLY。注意VALUE被用以从集合PROCEDURES中得到变量定义；我们可以这么做，是因为作为工程的技巧，我们组织ENV和PROCEDURES让他们有相同的结构，因为它们都是符号表。</p>

<p>EVLIS is a simple recursive function which calls EVAL on successive arguments in ARGLIST and produces a list of the values in order. </p>

<p>EVLIS是个简单的函数，它对ARGLIST中相继的参数调用EVAL，然后顺序产生值的列表。</p>

<p>APPLY distinguishes two kinds of procedures: primitive and user-defined. For now we avoid describing the precise implementation of primitive procedures by assuming the existence of a predicate PRIMOP which is true only of primitive procedures, and a function PRIMOP-APPLY which deals with the application of such primitive procedures. (See {Note Primitive Operators} for the details of a possible implementation of PRIMOP and PRIMOP-APPLY.) We consider primitive procedures to be a kind of atomic S-expression other than numbers and atomic symbols; we define no particular written notation for them here. However, primitive procedures are not to be confused with the atomic symbols used as their names. The result of (VALUE ‘CAR PROCEDURES) is not the atomic symbol CAR, but rather some bizarre object which is meaningful only to PRIMOP-APPLY.</p>

<p>APPLY区分两种类型的过程：原语和用户定义。迄今我们避免描述原语过程的准确定义，通过假设存在一个判定式PRIMOP，它只对原语过程为真，同时有一个函数PRIMOP-APPLY，它处理如此原语过程的应用。(参看 {Note Primitive Operators} 详细了解PRIMOP和PRIMOP-APPLY的可能实现的细节。) 我们认为原语过程是一类原子表达式，而非数字或原子符号；我们这里为她们诶有定义特别的书写记号。但是，原语过程不能与使用它们名字的原子符号混淆。(VALUE ‘CAR PROCEDURES)的结果不是原子符号CAR，而是有些奇怪的对象，它只对PRIMOP-APPLY有意义。</p>

<p>User-defined procedures are represented here as lists. These lists are constructed by DRIVER-LOOP-1. The car of the list is the list of formal parameters, and the cadr is the body of the definition.</p>

<p>用户定义的过程在这里用列表表示。这些列表通过DRIVER-LOOP-1构造。list的car部分，是正规参数的列表，而cadr部分是过程定义的主体。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">BIND</span> <span class="nv">VARS</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nb">=</span> <span class="p">(</span><span class="nv">LENGTH</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">LENGTH</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">CONS</span> <span class="nv">VARS</span> <span class="nv">ARGS</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">VALUEI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">VALUEI</span> <span class="nv">NAME</span> <span class="nv">SLOT</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">EQ</span> <span class="nv">SLOT</span> <span class="ss">&#39;&amp;UNBOUND</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">SLOT</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ENV</span><span class="p">)</span> <span class="ss">&#39;&amp;UNBOUND</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">ENV</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDAR</span> <span class="nv">ENV</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="nv">VARS</span> <span class="nv">VALS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">VARS</span><span class="p">))</span> <span class="nv">VALS</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">VALS</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>
Figure 3
<br />
Utility Routines for Maintaining Environments
</center>

<p>The interpreter uses several utility procedures for maintaining
symbol tables (see Figure 3). A symbol table is represented as a list of
buckets; each bucket is a list whose car is a list of names and whose cdr
is a list of corresponding values. {Note This ain’t A—lists} If a variable
name occurs in more than one bucket, the leftmost such bucket has priority;
in this way new symbol definitions added to the front of the list can
supersede old ones.</p>

<p>解释器使用几个工具过程来维护符号表(见图3)。一个符号表被表示为桶的列表；每个桶也是个列表，其car是列表的名字，而cdr是对应值的列表。{Note This ain’t A—lists} 如果一个变量名出现在多个桶，最左边的桶优先；新的符号定义添加到符号的前端，按照这个方式，旧的会被取代。</p>

<p>BIND takes a list of names, a list of values, and a symbol table,
and produces a new symbol table which is the old one augmented by an extra
bucket containing the new set of associations. (It’s also performs a useful
error check —- LENGTH returns the length of a list.)</p>

<p>BIND 获得一个名字的列表，一个值的列表，一个符号表，然后将旧的符号表扩展一个桶，桶里包含关联的新集合，由此产生一个新的符号表。(它也执行一个有用的错误检查 —- LENGTH 返回列表的长度)</p>

<p>VALUE is essentially an interface to LOOKUP. We define it because later, in Part Three, we will want to use different versions of VALUE1 without changing the underlying algorithm in LOOKUP. The check for &amp;UNBOUND catches incorrect references to undefined variables.</p>

<p>VALUE 本质上是LOOKUP的接口。我们随后在第三部分定义它，我们将想使用不同版本的VALUE1，而不改变LOOKUP的基础算法。 对 &amp;UNBOUND 的检查捕获对未定义变量的不正确的引用。 </p>

<p>LOOKUP takes a name and a symbol table, and returns that portion of a bucket whose car is the associated value. (This definition will be more useful later than one in which the value itself is returned.)</p>

<p>LOOKUP 取得一个名字和一个符号表，然后返回桶的一部分，其car是关联的值。(这个定义随后将比返回值本身更加重要)</p>

<p>Note carefully the use of the variable PROCEDURES in the
interpreter. When DRIVER-LOOP-1 calls EVAL it passes the current list of
defined procedures (both primitive and user-defined). DRIVER-LOOP-1 is the
only routine which augments the value of PROCEDURES, and this value is only
used in EVAL, when it is passed to VALUE. However, <u>all</u> of the routines
APPLY, EVCOND, and EVLIS have to know about PROCEDURES, and dutifully pass it
along so that it may be eventually used by EVAL. The set of definitions
must be passed along because there is no provision for free variables or
side effects; there is no way to have “memory” or “state” other than in
passed variables. The absence of free variables effectively causes our
language to be referentially transparent. However, we sense a disturbing
lack of modularity in the use of PROCEDURES (and, to a lesser extent, in the
use of ENV — look at EVCOND and EVLIS). We will return to this point later.</p>

<p>仔细地注意在解释器中使用变量PROCEDURES。当DRIVER-LOOP-1调用EVAL，它传入所定义过程的当前列表(既有原语的，也有用户定义的)。DRIVER-LOOP-1 是唯一例程，它扩展PROCEDURES的值，并且这个值只在EVAL中使用，当它被传给VALUE时。但是，所有例程APPLY, EVCOND, EVLIS都必须知道PROCEDURES, 并尽责地顺延传递它，从而它可能最终被EVAL用到。定义的集合必须被顺延传递，因为对自由变量或副作用没有预先准备; 也没有方法去有“内存”或“状态”，除了在传递的变量中。缺少自由变量实际上致使我们的语言是引用透明的。但是，我们感觉到在PROCEDURES中缺少模块化的一种不安(并且，在较小的程度，在ENV的使用中 — 看看EVCOND和EVLIS)。我们后面再回到这个话题。</p>

<p>Our recursion equations language has no special iteration or
looping constructs, such as the Algol <u>for</u> statement or the FORTRAN DO loop.
All loops are constructed by arranging for recursive procedures to call
themselves or each other. For example, EVCOND (see Figure 2) iterates over
the clauses of a COND by calling itself on successive “tails” of the list
of clauses. Now such recursive calls may strike the reader familiar with
other languages (such as Algol, FORTRAN, PL/I, etc.) on an intuitive level
as being rather inefficient for implementing real programs. Even granted
that calls might be made fast, they would seem to consume space in the form
of return addresses and other control information. Examination of the
recursion equations evaluator will show, however, that this phenomenon does
not have to occur. This is because no extra information is saved if there
is nothing left to do on return from a recursive call. See [SCHEME] and
[Debunking] for a more thorough discussion of this.</p>

<p>我们的递归方程语言没有特殊的迭代或循环构造物，如同Algol的for语句或者FORTRAN的DO循环。通过安排递归过程去调用它们自身或相互调用，构造出所有的循环。例如，通过对子句列表的后续”尾部(tails)”调用自身，EVCOND(见图2)对COND的子句实现了迭代。现在这样的迭代调用可能让熟悉其它语言(比如Algol, FORTRAN, PL/I, 等等)的读者在直觉层面觉得实现真实的程序不太有效率。甚至想当然认识，调用可以更快一些，它们应该看似以返回地址和其它控制信息的形式消耗了空间。然而，对递归函数求值器的检验显示，这个现象没有发生。这是因为，如果从递归调用中没有剩下什么事情去做，那么没有额外的信息要被保存。参见[SCHEME]和[Debunking]，对此有更彻底的讨论。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/the-art-of-interpreter-Introduction/">The Art of Interpreter: Introduction</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-18T10:22:59+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>10:22 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原文地址：<a href="http://c2.com/cgi/wiki?TheArtOfTheInterpreter">http://c2.com/cgi/wiki?TheArtOfTheInterpreter</a>
<br /></p>
<hr />

<center> 
MASSACHUSETTSINSTYTUTECHTTECHNOLOCY ARTIFICIAL INTELLIGENCE LABORATORY
<br />

AI Memo No.453                May 1978
<br />

<strong>The Art of the Interpreter
<br />
or, The Modularity Complex
(Parts Zero, One, and Two)</strong>

<br />
by
<br />

Guy Lewis Steele Jr.* and Gerald Jay Sussman**

</center>

<h3 id="section">摘要</h3>
<p>Abstract:</p>

<p>We examine the effects of various language design decisions on the
programming styles available to a user of the language, with particular
emphasis on the ability to incrementally construct modular systems. At
each step we exhibit an interactive meta-circular interpreter for the
language under consideration. Each new interpreter is the result of an
incremental change to a previous interpreter.</p>

<p>我们检验了现存编程风格上的语言设计决策对语言使用者的影响，特别关注增量构造模块化系统的能力。在每一个步，针对所考虑的语言，我们展示了一个交互式的元-循环解释器。每个新的解释器都是对先前解释器增量修改的结果。</p>

<p>We explore the consequences of various variable binding disciplines
and the introduction of side effects. We find that dynamic scoping is
unsuitable for constructing procedural abstractions, but has another role
as an agent of modularity, being a structured form of side effect. More
general side effects are also found to be necessary to promote modular
style. We find that the notion of side effect and the notion of equality
(object identity) are mutually constraining; to define one is to define
the other.</p>

<p>我们探索了不同变量绑定纪律的后果，并引入了副作用(side-effect)。我们发现，动态范围不适合构造过程的抽象，但是有作为模块代理的另一作用，是副作用的一个结构化形式。也发现了更多普遍的副作用，对提升模块化风格是必要的。我们发现副作用的记号和相等的记号(对象同一性)是相互约束的。为了定义其中一个，就必须定义另一个。</p>

<p>The interpreters we exhibit are all written in a simple dialect of
LISP, and all implement LISP-like languages. A subset of these interpreters constitute a partial historical reconstruction of the actual evolution of LISP.</p>

<p>我们展示的解释器都用LISP的简单方言写出，它们都实现了类LISP的语言。这些解释器的子集包含LISP实际进化的部分历史再现。</p>

<p>Keywords: abstraction, actors, applicative order, bindings, control structures, debugging, dynamic scoping, environments, fluid variables, FUNARG
problem, functional objects, interactive programming, lambda-calculus.
lexical scoping, LISP, modularity, procedural data, recursion equations,referential transparency, SCHEME, side effects, static scoping, structured programming</p>

<p>This report describes research done at the Artificial Intelligence
Laboratory of the Massachusetts Institute of Technology. Support for the
laboratory’s artificial intelligence research is provided in part by the</p>

<p>Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N000l4-75-C-0643.</p>

<h3 id="section-1">内容</h3>

<ul>
  <li>Introduction
    <ul>
      <li>Modularity</li>
      <li>LISP-like Languages</li>
      <li>Structure of the Paper</li>
    </ul>
  </li>
  <li>Part Zero-— LISP and Interpreters
    <ul>
      <li>Recursion{Equations</li>
      <li>An Interpreter for LISP Recursion Equations</li>
    </ul>
  </li>
  <li>Part One —— Variable Scoping Disciplines
    <ul>
      <li>Procedures as Data</li>
      <li>Local Procedures</li>
      <li>Lexical Scoping</li>
      <li>Top Levels versus Referential Transparency</li>
    </ul>
  </li>
  <li>Part Two — State
    <ul>
      <li>Decomposition of State</li>
      <li>Side Effects and Local State</li>
      <li>Side Effects in the Interpreter</li>
      <li>Equipotency of SETQ and RPLACA</li>
      <li>Side Effects and Equality</li>
      <li>Dynamic Scoping as a State-Decomposition Discipline</li>
    </ul>
  </li>
  <li>Summary</li>
  <li>Acknowledgements</li>
  <li>Notes
    <ul>
      <li>{Can George do Better?}</li>
      <li>{Debugging}</li>
      <li>{Driver Loop with Side Effects}</li>
      <li>{EVALQUOTE}</li>
      <li>{Gaussian}</li>
      <li>{LABEL5}</li>
      <li>{LABEL5 with Side Effects}*</li>
      <li>{Primitive Operators}</li>
      <li>{PROGN wizardry}</li>
      <li>{QUOTE Mapping}</li>
      <li>{QUOTE Shafts the Compiler}</li>
      <li>{RPLACA Can Alter CAR Instead}</li>
      <li>{S—expression Postulates and Notation}</li>
      <li>{This ain’t A-lists}</li>
      <li>{Value Quibb1e}</li>
      <li>{Weber}</li>
      <li>{Y-operator}</li>
    </ul>
  </li>
  <li>References</li>
</ul>

<h3 id="section-2">介绍</h3>
<p>Introduction</p>

<h4 id="section-3">模块化</h4>
<p>Modularity</p>

<p>The entities constructed by programming are extremely complex.
Accurate construction of large programs would be impossible without
specific techniques for controlling this complexity. Most such techniques
are based on finding ways to decompose a problem into almost independently
solvable subproblems, allowing a programmer to concentrate on one
subproblem at a time, ignoring the others. When the subproblems are
solved, the programmer must be able to combine the solutions with a minimum
of unanticipated interactions. To the extent that a decomposition succeeds
in breaking a programming problem into manageable pieces, we say that the
resulting program is modular; each part of the solution is called a
module. Well—designed programming languages provide features which support
the construction of modular programs.</p>

<p>编程产生的实体极端复杂。如果没有控制这一复杂性的特定技术，要准确无误地构造大型程序是不可能的。绝大多数这样的技术是基于寻找一些方法，将问题分解为几乎独立可求解的子问题，允许程序员一次聚焦于一个子问题，而忽略其它的。当自问题被解决了，程序员必须能够以最小的不可预见的互作用，将解决方案组合在一起。如果一个分解达到了成功地将一个编程问题拆分成可管理部分的程度，我们称如此生成的程序是模块化的；解决方案的每个部分称为一个模块。设计良好的编程语言提供了支持构建模块化程序的特性。</p>

<p>One decomposition strategy is the packaging of common patterns of
the use of a language. For example, in Algol a for loop captures a common
pattern of if and goto statements. Packages of common patterns are not
necessarily merely abbreviations to save typing. While a simple
abbreviation has little abstraction power because a user must know what the
abbreviation expands into, a good package encapsulates a higher level
concept which has meaning independent of its implementation. Once a
package is constructed the programmer can use it directly, without regard
for the details it contains, precisely because it corresponds to a single
notion he uses in dealing with the programming problem.</p>

<p>一个分解策略是将使用一个语言的共同模式打包。例如，在Algol中，一个for loop 语句捕获了if和goto语句的共同模式。共同模式的包并非只是为了节约打字的缩写而需的。虽然一个简单的缩写没有什么抽象能力，因为用户必须知道缩写扩展成什么，但是一个好的包，能在更高层次的概念上封装，具有独立于实现的含义。一旦一个包构造出来，程序员能直接使用它，不需要考虑它包含的细节，正好是因为程序员在处理编程问题时将它作为单一的记号来使用。</p>

<p>A package is most useful if its behavior is independent of the
context of its use, thus reducing possible interference with other
packages. Such a package is called referentially transparent.
Intuitively, referential transparency requires that the meanings of parts
of a program be apparent and not change, so that such meanings can be
reliably depended upon. In particular, names internal to one module should
not affect or be affected by other modules — the external behavior of a
module should be independent of the choice of names for its local
identifiers.</p>

<p>如果一个包的行为独立于使用它的上下文，它是最有用的，从而减少了与其它包可能的干扰。这样的包被称为<strong>引用透明(referentially transparent)</strong>。直觉地，引用透明要求一个程序某部分的意思是明明白白的，不会改变，从而能可靠地依赖此意思。特别地，一个模块内部的名字不能影响到其它模块，或者被影响 – 一个模块的外部行为必须独立于它局部标识符的名字的选择。</p>

<p>To make a modular program, it is often necessary to think of a
computational process as having state. In such cases, if the state can be
naturally divided into independent parts, an important decomposition may be
the division of the program into pieces which separately deal with the
parts of the state.</p>

<p>为了编写模块化程序，经常有必要想起带状态的计算过程。在这些案例中，如果状态能被自然地分解为独立的部分，一种重要的分解可能是将程序划分为独立处理状态各部分的片段。</p>

<p>We will discuss various stylistic techniques for achieving
modularity. One would expect these techniques to complement each other.
We will instead discover that they can come into conflict. Pushing one to
an extreme in a language can seriously compromise others.</p>

<p>我们将讨论达到模块化的不同的风格化技术。有人会期待这些技术会相互补充。相反，我们将发现它们会产生冲突。在语言中，将一个推到极致能严重地损害其它的。</p>

<h3 id="lisp">类LISP语言</h3>
<p>LISP-like Languages</p>

<p>Of the hundreds or thousands of computer languages which have been
invented, there is one particular family of languages whose common ancestor
was the original LISP, developed by McCarthy and others in the late 1950’s.
[LISP History] These languages are generally characterized by in simple,
fully parenthesized (“Cambridge Polish”) syntax; the ability to manipulate
general, linked—list data structures; a standard representation for
programs of the language in terms of these structures; and an interactive
programming system based on an interpreter for the standard representation.
Examples of such languages are LISP 1.5 [LISP 1.5M], MacLISP [Moon],
InterLISP [Teitelman], CONNIVER [HcDermott and Sussman], QA4 [Rulifson],
PLASMA [Smith and Hewitt] [Hewitt and Smith], and SCHEME [SCHEME] [Revised
Report]. We will call this family the LISP—like languages.</p>

<p>在成百上千被发明的计算机语言中，有特殊的一个语言家族，其祖先是原始的LISP，由McCarthy和其他人在1950年代后期开发出来。这些语言的特征是：通常都与简单、封闭括号的语法(Cambridge Polish)；能够操作普遍的、链式列表数据结构；以这些结构的方式对程序的标准表示；有基于标准表示解释器的一个交互式编程系统。这样语言的例子是LISP 1.5, MacLISP, InterLISP, CONNIVER, QA4, PLASMA和Scheme。我们称这个家族为类LISP语言。</p>

<p>The various members of this family differ in some interesting and
often subtle ways. These differences have a profound impact on the styles
of programming each may encourage or support. We will explore some of
these differences by examining a series of small (“toy”) evaluators which
exhibit these differences without the clutter of “extra features” provided
in real, production versions of LISP-like language systems.</p>

<p>这个家族的各种成员的不同之处，在一些有趣和经常微妙的地方。这些差别对鼓励或支持每种编程风格有深刻的影响。我们将探索这些差别的一些，通过检视一系列小(玩具)求值器，这些求值器展示了这些差别，而没有被类LISP语言系统的真实、生产性版本所提供的“附加特性”搞乱。</p>

<p>The series of evaluators to be considered partially constitute a
reconstruction of what we believe to be the paths along which the family
evolved. These paths can be explained after the fact by viewing the historical changes to the language as being guided by the requirements of
various aspects of modularity.</p>

<p>这些被考虑的求值器系列，部分构成了一个再现，我们认为是此语言家族进化所沿着的路径。这些路径可以被这样的事实来解释，即看到对语言历史上所做的改变，是被模块化各种方面的需求推动引导着。</p>

<h4 id="section-4">文章的结构</h4>
<p>Structure of the Paper</p>

<p>Our discussion is divided into several parts, which form a linear
progression. In addition, there are numerous large digressions which
explore interesting side developments. These digressions are placed at the
end as notes, cross-referenced to and from the text.</p>

<p>我们的讨论分为几个部分，它们形成线性的推进。此外，有很多大的题外话，去探索有趣的侧面开发。这些题外话放在最后作为注解，被交叉引用到或来自正文。</p>

<p>We exhibit a large number of LISP interpreters whose code differs
from one to another in small ways (though their behavior differs greatly!).
In order to avoid writing identical pieces of code over and over, each
figure exhibits only routines which differ, and also contains cross-
references to preceding figures from which missing routines for that figure
are to be drawn.</p>

<p>我们展示很多LISP解释器，它们的代码相互间有很小的差别（但是它们的行为差别巨大）。为了避免到处写出相同的片段，每个图仅展示不同的例程，也包含一个交叉引用到前面的图，在那里图中缺失的例程被画出来。</p>

<p>Part Zero introduces the restricted dialect of the LISP language in
which most of our examples are written. It also discusses the basic
structure of an interpreter, and exhibits a meta-circular interpreter for
the language.</p>

<p>第零部分介绍了LISP语言中受限制的方言，我们大多数的例子都它写成。这部分也讨论解释器的基本结构，并展示了语言的一个元-循环解释器。</p>

<p>Part One introduces procedural data as an abstraction mechanism,
and considers its impact on variable scoping disciplines in the language.
We are forced through a series of such disciplines as unexpected
interactions are uncovered and fixed. Interpreters are exhibited for
dynamic scoping and lexical scoping.</p>

<p>第一部分介绍作为一个抽象机制的过程数据，并考虑它在语言的变量范围规则中的影响。随着未曾预期的交互性被发现和修正，我们被迫使穿越一些列这样的规则。为了动态范围和词法范围而展示了解释器。</p>

<p>Part Two considers the problems associated with the decomposition of state. Side effects are introduced as a mechanism for effecting such decompositions. We find that the notion of side effect is inextricably wound up with the notion of identity. Dynamic scoping is retrospectively viewed as a restricted kind of side effect.</p>

<p>第三部分考虑与分解状态相伴的问题。副作用被引入，作为影响如此分解的一个机制。我们发现，副作用的记号无法摆脱地与相等性的记号缠绕在一起。回想起来，动态范围被看作一种受限的副作用类别。</p>

<p>With this we summarize and conclude with many tantalizing questions yet unanswered.</p>

<p>带着这些，我们总结并给出结论，很多扰人的问题尚未有答案。</p>

<p>In Part Three (in a separate paper) we will find that the
introduction of side effects forces the issue of the order of evaluation of
expressions. We will contrast call-by-name and its variants with call—by-
value, and discuss how these control disciplines arise as a consequence of
different models of packaging. In particular, call-by-name arises
naturally from the syntactic nature of the Algol 60 copy rule. As before,
many little interpreters for these disciplines will be exhibited. </p>

<p>在第三部分(一个单独的论文)，我们将发现，副作用的引入将催生表达式求值的次序问题。我们将通过名称调用(call-by-name)及它的变体，与通过值调用，进行比较。然后讨论这些控制记录如何作为不同包建模的结果而产生。特别地，按名称调用自然地从Algol 60拷贝机制的语法属性中自然产生。正如以前，这些规则的很多小解释器也被展示出来。</p>

<p>In Part Four we will be led to generalize the notion of a syntactic package. We will discuss meta-procedures, which deal with the representations of procedures. The distinction between a procedure and its representation will be more carefully considered. Macro processors, algebraic simplifiers, and compilers will be considered as meta-procedures. Various interpreters, compilers, and simplifiers will be exhibited.</p>

<p>在第四部分，我们将导向推广语法包的记号。我们将讨论元过程，这处理过程的表示。过程及其表示的区分将被更加仔细地考虑。宏处理器，代数化简器和编译器，将被看做元过程。不同的解释器、编译器和化简器将被展示。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/haskell-resources/">Haskell Resources</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-07T15:31:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>3:31 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2 id="books">Books</h2>

<ul>
  <li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></li>
  <li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
  <li></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/implementing-arithmetic-in-lisp/">在Lisp中实现算术</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-27T11:51:18+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>11:51 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在上一篇文章中，Paul Graham介绍了Lisp的基础。通过7个原语操作，就可定义一些基本函数，进而实现对表达式求值函数eval.。本文将探索，基于这些Lisp的基本语言素材，如何实现算术。</p>

<p>整个背后的想法是，只要我们定义了语言的原语操作，就可推演出整个语言的体系。数字，本质上也是符号。而算术，则是对符号的操作。</p>

<h3 id="section">预备函数</h3>

<p>我们需要增加几个函数，作为预备：</p>

<p>(neq. x y) 判断x和y是否不相等。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; (defun neq. (x y)
</span><span class="line">    (not. (eq x y))) </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(member. x y)判断x是否是列表y的元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">member.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="ss">&#39;t</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">member.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(reverse. x) 反转整个列表x</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(findsub. x y) 在y中找元素x，如果找到，返回包含x在内的尾部。找不到，返回空。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">findsub.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(longer. x y) 比较两个列表x和y，哪个更长，即元素更多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">longer.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">()))</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;LT</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">longer.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">实现整数加法</h3>

<p>我们先实现整数的加法，而且先不考虑负数的情况。我们用列表表示数字，例如1234，表示为(1 2 3 4)。
高位在左，低位在右，以便符合人的阅读习惯。</p>

<p>我们先定义函数(basecomp. x y)，比较单个数字符号的大小。思路是比较它们在符号列表(0 1 2 3 4 5 6 7 8 9)中的位置，哪个靠前，哪个小。具体的算法，是处理相等的情况，直接返回相等。然后取得含有y的符号列表的尾部，如果包含x，则x要靠后，否则靠前。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">basecomp.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">         <span class="p">((</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)))</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;LT</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;3</span> <span class="ss">&#39;4</span><span class="p">)</span>
</span><span class="line"><span class="nv">LT</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;8</span><span class="p">)</span>
</span><span class="line"><span class="nv">EQ</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;9</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="nv">GT</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后，我们可以定义单个数字的加法，就如同小学时学的加法表一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">baseadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;GT</span><span class="p">)</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="ss">&#39;0</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">2</span> <span class="p">((</span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">3</span> <span class="p">((</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">4</span> <span class="p">((</span><span class="mi">4</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">5</span> <span class="p">((</span><span class="mi">5</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">6</span> <span class="p">((</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">7</span> <span class="p">((</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">8</span> <span class="p">((</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">7</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">9</span> <span class="p">((</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">8</span><span class="p">))))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>先按照x, 再按y，查找加法表，返回结果。如果有进位，就返回列表，比如(1 5)。由于加法表，要求y&gt;=x。所以用到比较函数basecomp.，如果x大于y，则将次序调换在调用baseadd.。如果不要求x和y的次序，亦可，但加法表要多写一倍，这是冗余而无趣的工作。</p>

<p>试试我们的一位数加法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;2</span> <span class="ss">&#39;3</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;5</span> <span class="ss">&#39;0</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>万事俱备了，可以写最终的加法函数。但别急，还有点小的问题。我们知道多位数的加法，是先算低位再算高位。但是，我们的数字用列表表示时，是高位在左，低位在右。用lisp的car, cdr要先取出最右边(尾部)的元素很不方便。一个解决办法是，先将列表反转过来计算，计算完毕后，再反转回来。</p>

<p>这个就是整数加法的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">y</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>反转后列表的加法函数，intaddreverse. 如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))</span>
</span><span class="line">                   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                            <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看看效果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">应用</h3>

<p>利用上面的加法函数，我们可以写一个计算列表长度的函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">length.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">length.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">k</span> <span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>(1 4)就是14。</p>

<h3 id="section-3">回顾</h3>

<p>上面通过简单的符号计算规则，就实现了整数的加法运算，让我们更进一步理解，一切计算皆是符号的本质。当然，基本规则的定义稍有冗余。上面定义了自然数的大小和加法表。更简洁的定义，只需包含三个部分：</p>

<ul>
  <li>自然数 $a_0$ = 1</li>
  <li>$a_n$ = $a_{n-1}$ + 1</li>
  <li>十进制的进位和表示法</li>
</ul>

<p>循着类似的思路，减法运算也可定义出来。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/the-roots-of-lisp/">LISP的根本</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-14T14:30:54+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>2:30 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="section">前言</h3>
<p>《黑客与画家》的作者Paul Graham极力推崇Lisp，并使用Lisp获得了巨大的商业成功。他也写了一篇<a href="http://ep.yimg.com/ty/cdn/paulgraham/jmc.ps">《The roots of Lisp》</a>(postscript文件)来介绍Lisp。本文是其文章内容的学习和理解，再加上Lisp Manual 1.5的内容。</p>

<p><br /></p>
<hr />

<p><br /></p>

<p>Lisp的伟大之处，在于John McCarthy采用了类似于欧氏几何的公理化体系。欧氏几何通过几个简单的公理，借助逻辑推演，构建了整个几何体系。其结构之整洁、推理之严密，有一种深深的数学之美和逻辑的力量。MaCarthy在1960年的文章中展示了，如何通过少数几个简单的运算符和函数定义的记号，就可以构建整个编程语言。这个语言被称为Lisp，即列表处理(List Processing的意思)。而列表是表达数据和代码的一种简单数据结构。</p>

<p>值得去理解，McCarthy所发现的，不仅仅是计算机历史上的地标，而且是在今天我们的时代里，编程发展所趋向成为的一个模型。迄今为止，存在两个真正干净、一致的编程模型：C模型和Lisp模型。这两个是平地上的高点，在其之间是沼泽地带。随着计算机变得更为强大，正在开发的新语言正稳定地向Lisp模型靠拢。在过去20年中新编程语言的流行配方是采用C计算模型，然后从Lisp模型中抓取一点诸如运行时类型、垃圾回收等零碎的东西，加到里面。</p>

<p>本文将解释McCarthy发现的最简单的术语。要点不是仅仅学会一个40年前就有人弄明白的有趣的理论结果，而是去看看语言朝哪方面去发展。事实上，关于Lisp不寻常的事 - Lisp决定性的品质，是它是用自身写成的。为了理解McCarthy想说明的意思，我们将追溯他的脚步，将他的数学符号转译为可运行的Common Lisp代码。</p>

<h3 id="symbolic-expressions">符号性表达式(Symbolic Expressions)</h3>

<p><em>注：本节是由译者添附，内容来自<a href="http://en.wikipedia.org/wiki/S-expression">http://en.wikipedia.org/wiki/S-expression</a>，先交代基本概念，便于理解</em></p>

<p>符号表达式，即S表达式中最基本的类型，是原子。</p>

<p><strong>原子</strong>符号，是由字母和数字组成的字符串。其首字符必须字母。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">a</span>
</span><span class="line"><span class="nv">abc</span>
</span><span class="line"><span class="nv">a123</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>一个S表达式，可以递归地定义为：</p>

<ol>
  <li>一个原子</li>
  <li>形式为(X . Y)的表达式，其中X和Y都是S表达式</li>
</ol>

<p>例如： </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="nv">b</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="o">.</span> <span class="p">(</span><span class="nv">b</span> <span class="o">.</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">foo</span> <span class="o">.</span> <span class="p">(</span><span class="nv">bar</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>更方便的是将列表写成不带点记号的任意长度的列表：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>它等价于 </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">a</span> <span class="p">(</span><span class="nv">b</span> <span class="p">(</span><span class="nv">c</span> <span class="p">(</span><span class="nv">d</span> <span class="nv">e</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有过编程经验的朋友，会觉得List貌似和数组类似。其实不然。List的长度不固定，它是一种递归结构。在计算机内部的List结构是：</p>

<p><img src="http://hack.the-lifematrix.net/images/lisp/list_structure.png" alt="" /></p>

<p><em>注：此图来自Lisp Manual 1.5</em></p>

<h3 id="seven-primitive-operators">7个原语操作符(Seven Primitive Operators)</h3>

<p>在算术中，表达式1+1的值是2。合法的Lisp表达式也有值。如果一个表达式$e$有个值$v$，我们说$e$返回$v$。</p>

<p>如果一个表达式是一个列表，我们称其第一个元素为操作符，剩下的为参数。我们将定义7个原语操作符：quote, atom, eq, car, cdr, cons 和 cond。</p>

<p>*注：如下代码均在GNU CLISP 2.49下调试通过，CLISP内部会将符号转换为大写，所以输出时会是大写的符号。这和The roots of Lisp原文的代码输出，略有不同 *</p>

<p>1.(quote A)返回$A$, 为了可读性，我们将(quote A)缩写为’A</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="ss">&#39;a</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="k">quote</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>2.(atom x)返回原子t，如果x是原子，否则返回空列表。在Lisp中我们用atom t代表布尔值的真值，用NIL或空列表代表假值。二者是一回事。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="err">􏰛</span><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">()</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>现在我们有了一个运算符，它的参数会被求值。我们可以看看quote针对什么。一个未被引用的列表，作为参数传给atom这样的运算符，其代码是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>通过引用一个列表，我们可以避免它被求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">atom</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这对应我们在英语中使用引用的方式。Cambridge是麻省的一个镇，有9万人。而“Cambridge”是有9个字母的单词。</p>

<p>引用是可能看似陌生的概念，因为很少有其它语言具有任何类似的东西。它与Lisp最引人注目的特性联系在一起：<strong>代码和数据都由相同的数据结构产生出来，而引用操作符是我们区分它们的方式</strong>。</p>

<p>3.(eq x y)返回t，如果x, y的值是相同的原子，或者二者是空列表。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">eq</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>4.(car x)期待x的值是一个列表，并返回它的第一个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="nv">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>5.(cdr x)期待x的值是一个列表，并返回它除过第一个元素之外的所有部分。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>6.(cons x y) 期待y的值是一个列表，返回一个列表，其第一个元素是x的值，而后是y的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="nv">A</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>7.(cond ($p_1$ $e_1$) … ($p_n$ $e_n$))的求值如下：表达式$p$会按顺序求值，直到遇到一个为真。当这个表达式找到后，对应的表达式$e$的值，就会被返回作为整个cond表达式的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">)</span> <span class="ss">&#39;first</span><span class="p">)</span>
</span><span class="line">            <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;second</span><span class="p">))</span>
</span><span class="line"><span class="nv">SECOND</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这七个操作符原语的后5个，当对这个操作符开始的表达式求值时，参数总是会被求值。我们称这样的操作符，为<strong>函数</strong>。</p>

<h3 id="denoting-function">2. 函数的表示(denoting function)</h3>

<p>接着我们来定义一个记号来描述函数。一个函数被表达为 (lambda ($p_1$ … $p_n$) $e$), 这里$p_1$ … $p_n$ 是原子(被称为参数），而$e$是一个表达式。一个这样的表达式，</p>

<p>((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>被称为函数调用。对其求值的方法如下：先对每个表达式$a_i$求值，然后再对$e$求值。在对$e$求值时，任何出现$p_i$的值，都是最近一次函数调用中对应$a_i$的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span><span class="p">)))</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))</span> <span class="ss">&#39;z</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">Z</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果一个表达式：
($f$ $a_1$ … $a_n$)
其第一个元素$f$不是一个操作原语，而$f$的值是一个函数(lambda ($p_1$ … $p_2$) $e$)，那么表达式的值就是：((lambda ($p_1$ … $p_n$) $e$ ($a_1$ … $a_n$))</p>

<p>换言之，在表达式中参数可与当操作符用，如同函数参数一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span>  <span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)))</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))</span>
</span><span class="line"><span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>还有另外一种标记函数的方式，使得函数可以引用它自己，这给我们很方便的途径去定义递归函数。
记号：
(label $f$ (lambda ($p_1$ … $p_2$) $e$))
标记了行为如同(lambda ($p_1$ … $p_2$) $e)的函数。 </p>

<p>我们进一步将 f = (label $f$ (lambda ($p_1$ … $p_2$) $e$))缩写为：
(defun f ($p_1$ … $p_2$) $e$)</p>

<p>假设我们想定义一个函数(subst $x$ $y$ $z$)，它接收一个表达式$x$, 一个原子$y$, 一个列表$z$，然后返回类似于$z$的列表，但是$z$中每个$y$的实例都会被替换成$x$。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="ss">&#39;m</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="p">(</span><span class="nv">A</span> <span class="nv">M</span> <span class="nv">C</span><span class="p">)</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>那么这个函数可以这样通过递归定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">subst-new</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span> <span class="nv">z</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="o">&#39;</span><span class="p">())</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="nv">z</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">z</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">)))</span>
</span><span class="line">      <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">z</span><span class="p">))</span>
</span><span class="line">               <span class="p">(</span><span class="nv">subst-new</span> <span class="nv">x</span> <span class="nv">y</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">z</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>刚好我们在这里可以看到如何在cond表达式中得到一个子句。第一个元素是t的子句，总会成功。注意’t和t等价。因此</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">cond</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="ss">&#39;t</span> <span class="nv">z</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>等价于我们可能在其它语言中看到的语法：
if $x$ then $y$ else $z$</p>

<h3 id="section-1">一些函数</h3>

<p>既然我们有了一个表达函数的方式，我们将用原语操作符的术语来定义一些新的函数。首先，将方便地介绍一系模式的缩写。我们使用c$x$r, 其中$x$是a或d的序列，作为对应car和cdr序列的缩写。因此，例如(cadr $e$)是 (car (cdr $e$))的缩写，它返回$e$的第二个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cadr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">caddr</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="nv">E</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cdar</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>而且，我们使用(list $e_1$ … $e_n$)代表(cons $e_1$ … (cons $e_n$ ‘()) …)。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;b</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;c</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;d</span> <span class="o">&#39;</span><span class="p">()))))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span> <span class="ss">&#39;c</span> <span class="ss">&#39;d</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们现在来定义一些新函数。我们在函数名的尾部加一个句号，这便于和现存的原语函数区分开，也不会和Common Lisp现有的函数冲突。</p>

<ol>
  <li>(null. $x$)测试其参数是否为空列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">null.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">()))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="ss">&#39;a</span><span class="p">)</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">null.</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(and. $x$ $y$) 返回真t，如果其两个参数都为真，否则返回空列表’()。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">and.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="no">t</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="o">&#39;</span><span class="p">())))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="p">(</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">atom</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(not. x) 返回真t, 如果它的参数是空列表，否则返回</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">not.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">(</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="no">t</span><span class="p">)))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">not.</span> <span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;b</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(concat. x y)收到两个列表，将它们联接起来。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">concat.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">concat.</span> <span class="o">&#39;</span><span class="p">()</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>*注：原文此函数命名为append，觉得concat 更适合一些 *</p>

<p>*注：这里用到了前面定义的函数null. *</p>

<ol>
  <li>(pair. $x$ $y$) 收到两个等长的列表，然后返回一个列表，每个元素是由$x$、$y$对应元素构成的列表。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">pair.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span>
</span><span class="line">          <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="nv">pair.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">pair.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">e</span> <span class="nv">g</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">c</span> <span class="nv">d</span> <span class="nv">f</span><span class="p">))</span>
</span><span class="line"><span class="p">((</span><span class="nv">A</span> <span class="nv">C</span><span class="p">)</span> <span class="p">(</span><span class="nv">B</span> <span class="nv">D</span><span class="p">)</span> <span class="p">(</span><span class="nv">E</span> <span class="nv">F</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>(assoc. x y) 收到一个原子$x$和一个由pair.生成的列表形式，然后返回列表$y$中其第一个元素是$x$的列表的第二个元素。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">assoc.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">           <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">           <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line"> <span class="nb">&gt;</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="ss">&#39;a</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">b</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">f</span><span class="p">)</span> <span class="p">(</span><span class="nv">a</span> <span class="nv">g</span><span class="p">)))</span>
</span><span class="line"><span class="nv">F</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">惊喜</h3>

<p>我们能够定义函数，完成级联列表、用一个表达式替换另一个等等。一个优雅的记号，但这又能怎么样呢？现在惊喜来了。我们也能证明，可以写一个函数作为语言自己的解释器：一个将任意Lisp表达式作为参数，并返回其值，见下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
<span class="line-number">31</span>
<span class="line-number">32</span>
<span class="line-number">33</span>
<span class="line-number">34</span>
<span class="line-number">35</span>
<span class="line-number">36</span>
<span class="line-number">37</span>
<span class="line-number">38</span>
<span class="line-number">39</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">eval.</span> <span class="p">(</span><span class="nv">e</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">e</span> <span class="no">t</span><span class="p">)</span> <span class="no">t</span><span class="p">)</span>
</span><span class="line">                      <span class="p">((</span><span class="nb">eq</span> <span class="nv">e</span> <span class="o">&#39;</span><span class="p">())</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">e</span> <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">atom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">       <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;quote</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;atom</span><span class="p">)</span> <span class="p">(</span><span class="nb">atom</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;eq</span><span class="p">)</span> <span class="p">(</span><span class="nb">eq</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                               <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;car</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cdr</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cons</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                                   <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">         <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;cond</span><span class="p">)</span> <span class="p">(</span><span class="nv">evcon.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                          <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">                    <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;label</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">))</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">e</span><span class="p">)</span> <span class="ss">&#39;lambda</span><span class="p">)</span>
</span><span class="line">       <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caddar</span> <span class="nv">e</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nv">pair.</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nv">evlis.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">                       <span class="nv">a</span><span class="p">)))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="nv">e</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">evcon.</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">))</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">evcon.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">a</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">evlis.</span> <span class="p">(</span><span class="nv">m</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nv">null.</span> <span class="nv">m</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">eval.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span><span class="line">                <span class="p">(</span><span class="nv">evlis.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">m</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<ul>
  <li>注：原文的代码存在小bug，这里修正了。一是对布尔常量的求值，要返回布尔量，不再从环境a中查找；二是, label 表达式的解析。</li>
</ul>

<p>这个函数eval.比我们之前看到的任何函数都要长。让我们看看它是如何工作的。</p>

<p>这个函数有两个参数：e, 将要求值的表达式，以及a, 原子所给定值的列表，在函数调用中以参数表现出来。这个列表被称之为<em>“环境”</em>(environment)，是由pair.创建的形式。eval.的骨架是由带有4个子句的cond表达式。我们如何对表达式求值取决于它的类别。第一个子句处理原子。如果e是一个原子，我们在环境中查找它的值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="ss">&#39;x</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">y</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)))</span>
</span><span class="line"><span class="nv">A</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>eval.的第二个子句是一个cond, 处理格式为($a$ …)的表达式，而$a$是原子。这些包含所有对原语操作符的使用，每个子句处理其中一个：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">eq</span> <span class="ss">&#39;a</span> <span class="ss">&#39;a</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line"><span class="no">T</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="nv">b</span><span class="p">)))</span>
</span><span class="line"><span class="p">(</span><span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>所有这些（除过 quote)调用eval. 去查找参数的值。</p>

<p>最后两个子句更为复杂，为了给cond表达式求值，我们调用一个附属函数evcon., 它递归式地遍历子句，寻找其第一个元素返回t的子句。当它找到时，就返回其第二个元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="ss">&#39;atom</span><span class="p">)</span>
</span><span class="line">                <span class="p">(</span><span class="ss">&#39;t</span> <span class="ss">&#39;list</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span><span class="p">))))</span>
</span><span class="line"><span class="nv">LIST</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>eval.第二个子句的最后一部分，处理作为函数的调用。它通过将原子替换为它的值，并对得到的表达式求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>定价于</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">f</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="ss">&#39;a</span> <span class="nv">x</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后返回(A B C)。</p>

<p>eval.的最后两个子句处理函数调用，其第一个元素是实际的 lambda或label表达式。对label表达式的求值是，将函数名和函数自身的列表压入环境中，然后对一个表达式调用eval.求值，其中用内部的lambda表达式替换label表达式。即：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">label</span> <span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                                    <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>变成</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                             <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>原文的代码是将label表达式，替换为如下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                             <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))</span>
</span><span class="line">           <span class="nv">y</span><span class="p">)</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">firstatom</span>
</span><span class="line">            <span class="p">(</span><span class="nv">label</span> <span class="nv">firstatom</span> <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">                               <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">                                     <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">firstatom</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nv">y</span> <span class="p">((</span><span class="nv">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nv">c</span> <span class="nv">d</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这样当函数递归调用时，每次都要解析label，导致不断有label定义添加到环境中。这是小bug，本文代码做了修正。</p>

<p>对形式为 ((lambda ($p_1$ … $p_n$) $e$) $a_1$ … $a_n$)的表达式取值，首先调用evlis., 来获得参数($a_1$ … $a_n$)的一组值($v_1$ … $v_n$), 然后将($p_1$ $v_1$) … ($p_n$ $v_n$)添加到前面的环境中，然后对$e$求值。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">           <span class="ss">&#39;a</span>
</span><span class="line">           <span class="o">&#39;</span><span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>变成</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nb">cons</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">         <span class="o">&#39;</span><span class="p">((</span><span class="nv">x</span> <span class="nv">a</span><span class="p">)</span> <span class="p">(</span><span class="nv">y</span> <span class="p">(</span><span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后返回(A C D)。</p>

<h3 id="section-3">尾声</h3>

<p>现在我们已经理解了eval怎么工作的，让我们回退一下考虑这意味着什么。我们现在所拥有的是非同寻常的优雅的计算模型。仅仅使用quote, atom, eq, car, cdr, cons 和 cond, 我们定义了一个函数eval., 它事实上实现了我们的语言，然后使用这些，我们可以定义任何想添加的函数。</p>

<p>当然已经有非常著名的计算模型，图灵机。但是图灵机读起来缺少启迪性。如果你想要一个描述算法的语言，你可能需要更为抽象一点的语言。这就是McCarthy定义Lisp的目的之一。</p>

<p>他在1960年定义的语言少了很多东西。没有副作用、没有顺序执行（不管怎样，它只有和副作用一起才有用）、没有使用的数字、没有动态范围。但是，这些局限可以用令人吃惊的少量代码来改进。Steele和Sussman在著名的论文“解释器的艺术”(The Art of the Interpreter)中，展示如何做这些。</p>

<p>如果你理解McCarthy的eval, 你理解到的不仅仅是编程语言历史上的一个阶梯。这些创意仍然是今天Lisp的语义核心。因此学习McCarthy的原文，在某种程度上，向我们展示了Lisp是什么。它不是McCarthy如此设计为他所发现的东西。它本质上，不是为了人工智能(AI)，快速搭建原型，任何其它这个层面的任务。它是当你试图公理化计算时，你得到的东西。</p>

<p>伴随着时间，中等程度的语言，即由中等程度程序员使用的语言，已经一贯地向Lisp方向去成长。因此，通过理解eval, 你正在理解未来可能的主要计算模型是什么。</p>

<h3 id="section-4">注释</h3>

<p>在将McCarthy的记号转化为可执行代码时，尽可能少做改动。我尝试让代码更加可读，但我试图保持原文的味道。</p>

<p>在McCarthy的论文中，“假”用f表示，而非空列表。我使用()来表示假，这样示例在Common Lisp上能很好运行。没有代码依赖“假”，也碰巧依赖空列表。空(nothing)一贯被cons到predict返回的结果。</p>

<p>我跳过了从带点的对(pair)中构造列表，因为你并不需要靠它们去理解eval。我也没提到apply，但apply(非常早期的形式，其目的是引用参数)正是McCarthy在1960年称之的普遍函数(universal function)；而eval只是个apply调用的子例程，去完成所有工作。</p>

<p>我定义了list和c$x$rs, 作为缩写，因为McCarthy也这么做。事实上，c$x$rs可以作为通常函数来定义。如果我们修改eval，list也可以这么做（定义为通常函数）。正如我们可以容易地让函数接受任意数目的函数。</p>

<p>McCarthy只用了5个原语操作符。他使用了cond和quote，但可能把它们作为元语言的一部分。他同样也没定义逻辑运算符and和not，但这不是个问题，因为有足够的版本将其定义为函数。</p>

<p>在eval的定义中，我们调用了象pair.和assoc这样的函数，但是调用用原语操作符定义的任何函数，都可以替代为对eval.的调用。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">assoc.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span> <span class="nv">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>可以写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">eval.</span> <span class="o">&#39;</span><span class="p">((</span><span class="nv">label</span> <span class="nv">assoc.</span>
</span><span class="line">                  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">                    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nb">caar</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cadar</span> <span class="nv">y</span><span class="p">))</span>
</span><span class="line">                          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))</span>
</span><span class="line">           <span class="p">(</span><span class="nb">car</span> <span class="nv">e</span><span class="p">)</span>
</span><span class="line">           <span class="nv">a</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;e</span> <span class="nv">e</span><span class="p">)</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">list</span> <span class="ss">&#39;a</span> <span class="nv">a</span><span class="p">)</span> <span class="nv">a</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在McCarthy的代码中有个小bug。第16行是(等价于) (evlis. (cdr e) a)， 而非(cdr e)，这将使得对一个命名函数的调用中参数被求值两遍。这暗示，当论文提交时，eval的这一描述还未曾在IBM 704机器语言中实现过。这也说明，对于任何长度的代码，如果没有运行过，确定其正确性是很困难的。</p>

<p>我在McCarthy的代码中还遇到另一个问题。在给出eval的定义后，他继续给出了高阶函数的例子，即把其它函数作为参数的函数。他定义maplist:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">label</span> <span class="nb">maplist</span>
</span><span class="line">         <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">f</span><span class="p">)</span>
</span><span class="line">           <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">null</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                 <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">f</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">maplist</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">f</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后用它来写一个简单的函数diff，做符号微分。但是diff向maplist传递了一个以x作为参数的函数，然后对它的引用被maplist中的参数x捕获。</p>

<ul>
  <li>作者注：目前Lisp程序员使用mapcar而非maplist。这个例子也澄清了一个神话：为什么maplist会在Common Lisp中。它是期初的映射函数，而mapcar是后来添加的。*</li>
</ul>

<p>这是动态范围之危险的一个极富说服力的证据，因为它，恰恰Lisp高阶函数的第一个例子就被搞坏了。有可能McCarthy在1960年并未完全意识到动态范围的含义。动态范围在Lisp的实现中保留了令人惊讶的很长的时间，直到Sussman和Steele在1975年开发了Scheme。语法范围没有将eval的实现搞得太复杂，但是更难以写出编译器。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/a-conversation-with-alan-kay/">译文：与艾伦·凯的对话</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-30T12:14:50+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>30</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:14 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="smalltalk">和Smalltalk创造者一起畅谈</h3>

<p>原标题： A Conversation with Alan Kay，Big talk with the creator of Smalltalk—and much more.</p>

<p>原文：<a href="http://queue.acm.org/detail.cfm?id=1039523">http://queue.acm.org/detail.cfm?id=1039523</a>, <a href="http://dl.acm.org/ft_gateway.cfm?id=1039523&amp;ftid=297449&amp;dwn=1"><img src="http://hack.the-lifematrix.net/images/common/icon_pdf.png" alt="" /></a></p>

<p>译者：lifematrix[<a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#115;&#116;&#101;&#118;&#101;&#110;&#108;&#105;&#117;&#099;&#120;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">&#115;&#116;&#101;&#118;&#101;&#110;&#108;&#105;&#117;&#099;&#120;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;</a>]	</p>

<p>ACM相关链接：<a href="http://queue.acm.org/listing.cfm? qc_type=interviews&amp;page_title=Interviews">访谈</a>,  <a href="http://queue.acm.org/listing.cfm?item_topic=Programming%20Languages&amp;qc_type=theme_list&amp;filter=Programming%20Languages&amp;page_title=Programming%20Languages&amp;order=desc">编程语言</a></p>

<hr />

<p>When you want to gain a historical perspective on personal computing and programming languages, why not turn to one of the industry’s preeminent pioneers? That would be Alan Kay, winner of last year’s Turing Award for leading the team that invented Smalltalk, as well as for his fundamental contributions to personal computing.</p>

<p>如你想获得有关个人计算和编程语言的历史性观点，为什么不问问业界的某位先驱呢？这可能就是[Alan Kay], 他因为领导团队发明Smalltalk, 以及他对个人计算的根本性贡献，荣获去年的图灵奖。</p>

<p>Kay was one of the founders of the Xerox Palo Alto Research Center (PARC), where he led one of several groups that together developed modern workstations (and the forerunners of the Macintosh), Smalltalk, the overlapping window interface, desktop publishing, the Ethernet, laser printing, and network client-servers.</p>

<p>Kay是施乐帕洛阿尔托研究中心(Xerox Palo Alto Research Center, PARC)的创始人之一，他在那里领导了几个小组中的一个，这些组共同开发了现代工作站(Machintosh的前身)，Smalltalk，重叠式窗口界面，桌面出版，以太网，激光打印，以及网络的客户-服务器。</p>

<p>Prior to his work at PARC, Kay earned a Ph.D. in 1969 from the University of Utah, where he designed a graphical object-oriented personal computer and was a member of the research team that developed pioneering 3-D graphics work for the Advanced Research Projects Agency (ARPA). Kay was also a “slight participant” in the original design of the ARPANet, which later became the Internet. He holds undergraduate degrees in mathematics and molecular biology from the University of Colorado. After leaving Xerox PARC, Kay went on to become chief scientist of Atari, a Fellow of Apple Computer, and vice president of research and development at The Walt Disney Company.</p>

<p>在他工作于PARC之前，Kay于1969年从犹他州立大学获得博士学位。在那里，他设计了一个图形化的面向对象的个人电脑，同时他也是一个研究小组的成员。这个组为高级研究项目管理局(ARPA)开发开创性的3-D图形装置。Kay也是ARPANet原始设计的“少量参与者“”，其后来演变成了互联网。他在科罗拉多州立大学获得数学和分子生物学的研究生学位。离开施乐PARC之后，Kay继续成为Atari的首席科学家，这是苹果电脑的同类，他也是沃特迪斯尼公司的研发副总裁。</p>

<p>Today he is Senior Fellow at Hewlett-Packard Labs and president of Viewpoints Research Institute, a nonprofit organization whose goal is to change how children are educated by creating a sample curriculum with supporting media for teaching math and science. This curriculum will use Squeak as its media, and will be highly interactive and constructive. Kay’s deep interests in children and education have been the catalysts for many of his ideas over the years.</p>

<p>今天，他是惠普公司的高等院士以及Viewpoint研究所的总裁，这是一个非盈利组织，其目标是通过创造带有支持媒体的样本课程来教授数学和科学，从而改变儿童接受教育的方式。这个课程将使用Squeak语言作为媒介，将具有高度交互性和建设性。Kay对儿童和教育的深度兴趣，是他多年来很多创意的催化剂。</p>

<p>In addition to winning the Turing Award, Kay recently received the Draper Prize from the National Academy of Engineering and the Kyoto Prize in Advanced Technology, awarded every four years by the Inamori Foundation.</p>

<p>除了图灵奖，Kay最近从美国国家工程院获得了Draper奖，以及高等技术的Kyoto奖(京都赏)，此奖由Inamori基金会每4年颁发一次。</p>

<p>Guiding our tour through personal computing history with Kay is Stuart Feldman of IBM Research, where he is vice president and on-demand business transformation area strategist. Since joining IBM in 1995, Feldman has also served as vice president for Internet technology and was head of computer science in the research division.</p>

<p>带领我们和Kay一起游览个人计算历史的是IBM研究院的Stuart Feldman，他是研究院的副总裁以及随需应变(on-demand)业务转化领域的战略家。Feldman也曾经作为Internet技术的副总裁，是研究事业部中计算机科学的领导人。</p>

<p>Feldman also spent 11 years at Bellcore, where he held several research management positions in software engineering and computing systems, and 10 years at Bell Labs, where he was a computer science researcher. Feldman was a member of the original Unix team and is best known as the creator of the Make configuration management system and as the author of the first Fortran-77 compiler. He has a Ph.D. in applied mathematics from the Massachusetts Institute of Technology. He is a member of the Queue Advisory Board.</p>

<p>Feldman也在Bellcore(Bell Communications Research)待了11年，在那里他做过多个软件工程和计算系统的研究管理职位，并在Bell实验室待了10年，那里他作为计算机科学研究员。Feldman是原始Unix团队的成员，以Make配置管理系统的创建者和第一个Fortran-77编译器的作者而著称。他从麻省理工学院取得应用数学的博士学位。他是Queue顾问委员会的成员。</p>

<hr />

<p><strong>STUART FELDMAN</strong> One of the topics that some of the younger people on our Queue editorial board keep asking about is the history of programming languages. The Queue board has a bimodal generation distribution, and those members who are in their 20s or 30s seem genuinely confused about where programming languages might actually come from. It’s my observation that we have one big language and one smaller language every decade—that appears to be all the field can afford. Smalltalk is one of those five- or 10-year events.</p>

<p><strong>STUART FELDMAN</strong> 一些更年轻的人在我们Queue编委会上不断问到的一个主题是编程语言的历史。Queue委员会的年龄分布是双峰模式，那些20或30岁的成员普遍对编程语言到底从何而来感到困惑。我的观察是，每十年就有一个主流语言(one big language)和一个较小众的语言，这看起来所有的领域（对编程语言的需要）都能对付。Smalltalk是那些5年或10年的事件之一。</p>

<p><strong>ALAN KAY</strong> In the late 1960s, Jean Sammet was able to track down and chronicle about 3,000 programming languages that were extant then. When things were simpler in a sense—but theoretically harder because the machines were slower, smaller, didn’t have hard drives most of the time, and had bad tools—people nonetheless rolled their own operating systems and programming languages whenever they felt like it. So there are zillions of them around.</p>

<p><strong>ALAN KAY</strong> 在1960年代晚期，Jean Sammet能追溯和记录当时存在大约3000种编程语言。当事情在某种意义上变简单了，但在理论上却更困难了。因为机器更慢更小，多数时没有硬盘驱动器，工具很糟糕。尽管如此，人们运行着他们自己的操作系统和编程语言，只要他们喜欢。因此，到处都有繁多的编程语言和操作系统。</p>

<p>For a <em>Scientific American</em> article 20 years ago, I came up with a facetious sunspot theory, just noting that there’s a major language or two every 101⁄2 years, and in between those periods are what you might call hybrid languages. These could be looked at as either an improvement on the old thing or almost a new thing. I chronicled Fortran as an improvement on an old thing or almost a new thing, and Algol and Lisp were the new thing.</p>

<p>对《科学美国人》20年前的一篇文章，我想出一个俏皮的支持理论，每隔10年半，将有一到两个主要的语言，而在这个期间的语言，你可称为混合语言。这些可看做对旧事物的改进，或者几乎是全新的事物。我将Fortran编目为旧事物的改进或者几乎一个新事物，而Algol和Lisp是新事物。</p>

<p>Then there was Simula, which the designers thought of as an extension of Algol. It was basically a preprocessor to Algol the way C++ was a preprocessor for C. It was a great concept and I was lucky enough to see it as almost a new thing. Smalltalk and Prolog happened in the early 1970s. The predecessor of Prolog was a wonderful thing that Carl Hewitt did in the late 1960s called Planner.</p>

<p>然后是Simula, 设计者们把它看做Algol的扩展。它根本上是Algol的一个预处理器，如同C++对于C是预处理器的方式。这是个伟大的概念，我足够幸运将它看做几乎全新的事物。Smalltalk和Prolog出现在1970年代早期。Prolog的预处理器非常棒，由Carl Hewitt在1960年代晚期完成，叫做Planner。</p>

<p>Perhaps it was commercialization in the 1980s that killed off the next expected new thing. Our plan and our hope was that the next generation of kids would come along and do something better than Smalltalk around 1984 or so. We all thought that the next level of programming language would be much more strategic and even policy-oriented and would have much more knowledge about what it was trying to do. But a variety of different things conspired together, and that next generation actually didn’t show up. One could actually argue—as I sometimes do—that the success of commercial personal computing and operating systems has actually led to a considerable retrogression in many, many respects.</p>

<p>大概是1980年代的商业化扼杀了期待的下一个新事物。我们的计划和希望是下一代的年轻人能一起来干，做一些比1984年前后Smalltalk更好的东西，等等。我们都认为，编程语言的下一层次本应更具战略性，甚至是面向策略的，本应包含更多所尝试去做之事的知识。但是，很多不同的事情凑在一起，让下一代编程语言事实上没有显现出来。事实上有人会认为 - 亦如我偶尔做的 - 商业化个人计算和操作系统的成功实际上导致了在很多很多方面的显著退步。</p>

<p>You could think of it as putting a low-pass filter on some of the good ideas from the ’60s and ’70s, as computing spread out much, much faster than educating unsophisticated people can happen. In the last 25 years or so, we actually got something like a pop culture, similar to what happened when television came on the scene and some of its inventors thought it would be a way of getting Shakespeare to the masses. But they forgot that you have to be more sophisticated and have more perspective to understand Shakespeare. What television was able to do was to capture people as they were.</p>

<p>你可以把它想成，随着计算向外传播远快于教育未开化之人的速度，而对一些来自60或70年代的良好想法放置了低通过滤器。在过去大约25年，我们事实上得到一些好像流行文化的东西，类似于当电视机出现时所发生的。一些发明者的初衷是，电视机是让莎士比亚戏剧走向大众的一个途径，但他们忽略了，为了理解莎士比亚，你必须更加精于世情并有多个视角。电视能够做的是捕捉人们本然的样子。</p>

<p>So I think the lack of a real computer science today, and the lack of real software engineering today, is partly due to this pop culture.</p>

<p>因此我想今天缺少真正的计算机科学，缺少真正的软件工程，部分归因于这一流行文化。</p>

<p><strong>SF</strong> So Smalltalk is to Shakespeare as Excel is to car crashes in the TV culture?</p>

<p><strong>SF</strong> 那么，Smalltalk对于莎士比亚，是否就如同Excel对于电视文化中的车祸？</p>

<p><strong>AK</strong> No, if you look at it really historically, Smalltalk counts as a minor Greek play that was miles ahead of what most other cultures were doing, but nowhere near what Shakespeare was able to do.</p>

<p><strong>AK</strong> 不，如果你真从历史角度去看它，Smalltalk可当做小型的希腊戏剧，比大部分其它文明要领先几英里，但还没有接近莎士比亚所能做的。</p>

<p>If you look at software today, through the lens of the history of engineering, it’s certainly engineering of a sort—but it’s the kind of engineering that people without the concept of the arch did. Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.</p>

<p>如果你从工程的历史透镜去看今天的软件，它的确是某类工程 - 但它是那些对拱形结构都没有概念的人所做的工程。绝大多数今天的软件，非常象用数百万砖块堆积的埃及金字塔，没有结构的一致性，但仅靠蛮力和成千上万的奴隶。</p>

<p><strong>SF</strong> The analogy is even better because there are the hidden chambers that nobody can understand.</p>

<p><strong>SF</strong> 这个类比甚至更绝妙，因为这样里面有，无人能知的暗室。</p>

<p><strong>AK</strong> I would compare the Smalltalk stuff that we did in the ’70s with something like a Gothic cathedral. We had two ideas, really. One of them we got from Lisp: late binding. The other one was the idea of objects. Those gave us something a little bit like the arch, so we were able to make complex, seemingly large structures out of very little material, but I wouldn’t put us much past the engineering of 1,000 years ago.</p>

<p><strong>AK</strong> 我将我们在70年代做的Smalltalk玩意儿，比作哥德式教堂。事实上，我们有两个想法。其一来自Lisp: 延迟绑定。另一个是对象的想法。这些给了我们一些有点象拱形结构的东西，因此我们能够从小的材料中，做出复杂的、看起来大型的结构，但是我不会将我们放到1000年前的工程。</p>

<p>If you look at [Doug] Engelbart’s demo [a live online hypermedia demonstration of the pioneering work that Engelbart’s group had been doing at Stanford Research Institute, presented at the 1968 Fall Joint Computer Conference], then you see many more ideas about how to boost the collective IQ of groups and help them to work together than you see in the commercial systems today. I think there’s this very long lag between what you might call the best practice in computing research over the years and what is able to leak out and be adapted in the much more expedient and deadline-conscious outside world.</p>

<p>如果你看看Englebart的演示，那么你会看见比今天商业系统中更多的创意，关于如何提升团体的共同智商并帮助他们一起工作。我想，在计算研究多年来你可能称之的最佳实践，与能够渗入并被更为应急和注重最终期限的外部世界所采纳的之间，有相当大的延滞。</p>

<p>It’s not that people are completely stupid, but if there’s a big idea and you have deadlines and you have expedience and you have competitors, very likely what you’ll do is take a low-pass filter on that idea and implement one part of it and miss what has to be done next. This happens over and over again. If you’re using early-binding languages as most people do, rather than late-binding languages, then you really start getting locked in to stuff that you’ve already done. You can’t reformulate things that easily.</p>

<p>这并不是说人们都彻头彻尾地愚蠢，但是如果有个大点子而你有最终期限，你有应急手段，还有竞争者，那么很有可能你将做的，就是对那个点子放置低通过滤器，然后实施其中一部分，漏掉下次必须做的。这一而再地发生。如果你使用绝大多数人使用的早期绑定语言(early-binding languages)，而非延迟绑定语言，那么事实上你刚开始就被你已经做的锁定住了。你难以重新规划它。</p>

<p>Let’s say the adoption of programming languages has very often been somewhat accidental, and the emphasis has very often been on how easy it is to implement the programming language rather than on its actual merits and features. For instance, Basic would never have surfaced because there was always a language better than Basic for that purpose. That language was Joss, which predated Basic and was beautiful. But Basic happened to be on a GE timesharing system that was done by Dartmouth, and when GE decided to franchise that, it started spreading Basic around just because it was there, not because it had any intrinsic merits whatsoever.</p>

<p>让我们来说说，编程语言的采纳经常有些偶然性，过去经常是强调实现一个编程语言多么容易，而非它实际的优点和特性。例如，Basic本不该浮出水面，因为对于那个目的已经有一个语言优于它。这个语言是Joss，早于Basic，非常漂亮。但是Basic碰巧在由Dartmouth完成的GE分时系统上，当GE决定经销这系统时，Basic就开始四处被传播，仅仅因为它就在那里，而非有任何内在优点。</p>

<p>This happens over and over again. The languages of Niklaus Wirth have spread wildly and widely because he has been one of the most conscientious documenters of languages and one of the earlier ones to do algorithmic languages using p-codes (pseudocodes)—the same kinds of things that we use. The idea of using those things has a common origin in the hardware of a machine called the Burroughs B5000 from the early 1960s, which the establishment hated.</p>

<p>这又一而再地发生。<a href="https://zh.wikipedia.org/wiki/尼克劳斯·维尔特">Niklaus Wirth</a>的语言野蛮而广泛地传播<em>(注：他发明了Algol W、Pascal、Modula等语言)</em>，是因为他是最勤勤恳恳的语言文档撰写者之一，最早使用p代码(伪代码)作为算法语言的人之一 – 和我们使用的是同一类。使用那些东西的想法有个共同的根源，是在来自1960年代早期称为Burroughs B5000的硬件机器，这是保守派所憎恶的。</p>

<p><strong>SF</strong> Partly because there wasn’t any public information on most of it.</p>

<p><strong>SF</strong> 部分原因是对绝大多数这样的事情，没有任何公开的信息。</p>

<p><strong>AK</strong> Let me beg to differ. I was there, and Burroughs actually hired college graduates to explain that machine to data-processing managers. There was an immense amount of information available. The problem was that the DP managers didn’t want to learn new ways of computing, or even how to compute. IBM realized that and Burroughs didn’t.</p>

<p><strong>AK</strong> 让我说点不同的。我在那里，Burroughs的确雇佣了大学毕业生去向数据处理经理解释那个机器。有大量的信息可用。问题是那个经理不想学习计算的新方式，或甚至如何计算。IBM认识到那点了，但Burroughs没有。</p>

<p><strong>SF</strong> If memory serves, I was fascinated by that machine at the time, but I was unable to get the detail that made me understand it.</p>

<p>如果资金许可，那时我会被这机器迷住的，但是我无法获得让我理解它的细节。</p>

<p><strong>AK</strong> In fact, the original machine had two CPUs, and it was described quite adequately in a 1961 paper by Bob Barton, who was the main designer. One of the great documents was called “The Descriptor” and laid it out in detail. The problem was that almost everything in this machine was quite different and what it was trying to achieve was quite different.</p>

<p><strong>AK</strong> 事实上，原始的机器有两个CPU，这已经在主要设计者Bob Barton于1961年写的一篇文章中非常充分地讨论了。其中一篇伟大的文献被称为“描述子”(Descriptor)，并详细设计了它。问题是这个机器几乎所有的东西都是不同的，而且它试图达到的目标也完全不同。</p>

<p>The reason that line lived on—even though the establishment didn’t like it—was precisely because it was almost impossible to crash it, and so the banking industry kept on buying this line of machines, starting with the B5000. Barton was one of my professors in college, and I had adapted some of the ideas on the first desktop machine that I did. Then we did a much better job of adapting the ideas at Xerox PARC (Palo Alto Research Center).</p>

<p>那条线存活的原因，即使保守派不喜欢它，恰恰是它几乎不可能崩溃，所以从B5000开始，银行业不断地购买这条线的机器。Barton是我大学时的教授之一，我在做第一个桌面机器时采用其中一些想法。然后我们在施乐PARC采纳这些想法做出了更加出色的工作。</p>

<p>Neither Intel nor Motorola nor any other chip company understands the first thing about why that architecture was a good idea.</p>

<p>无论是英特尔还是摩托罗那，或其它任何芯片公司，都不理解这个首要的事情，为什么那个架构是个好点子。</p>

<p>Just as an aside, to give you an interesting benchmark—on roughly the same system, roughly optimized the same way, a benchmark from 1979 at Xerox PARC runs only 50 times faster today. Moore’s law has given us somewhere between 40,000 and 60,000 times improvement in that time. So there’s approximately a factor of 1,000 in efficiency that has been lost by bad CPU architectures.</p>

<p>仅仅插一句，给你一个有趣的指标 - 对大致相同的机器，大致用相同的方式优化，根据施乐Xerox在1979的基准，今天的机器只快了50倍。在这个期间，摩尔定律给了我们大概40000到60000倍的提升。因此，由于糟糕的CPU架构设计，大约有因子为1000倍的效率损失。</p>

<p>The myth that it doesn’t matter what your processor architecture is—that Moore’s law will take care of you—is totally false.</p>

<p>不用在意处理器的架构，摩尔定律将照顾你。这个神话，是完全错误的。</p>

<p><strong>SF</strong> It also has something to do with why some languages succeed at certain times.</p>

<p><strong>SF</strong> 也看看为什么一些语言在特定时间会成功。</p>

<p><strong>AK</strong> Yes, actually both Lisp and Smalltalk were done in by the eight-bit microprocessor—it’s not because they’re eight-bit micros, it’s because the processor architectures were bad, and they just killed the dynamic languages. Today these languages run reasonably because even though the architectures are still bad, the level 2 caches are so large that some fraction of the things that need to work, work reasonably well inside the caches; so both Lisp and Smalltalk can do their things and are viable today. But both of them are quite obsolete, of course.</p>

<p>是的，事实上Lisp和Smalltalk都在8位微处理器上完成 - 这不是因为他们是8位的微指令，而是因为糟糕的处理器架构，它们刚好扼杀了动态语言。今天，这些语言合情合理地运行着，因为即使架构仍然糟糕，但是L2缓冲如此大，有些需要做的事情，在缓冲中能合情合理地良好运行；因此Lisp和Smalltalk可以做他们的事情，它们在今天是可行的语言。但是，当然，它们两个快要过时了。</p>

<p>The stuff that is in vogue today is only about “one-half” of those languages. Sun Microsystems had the right people to make Java into a first-class language, and I believe it was the Sun marketing people who rushed the thing out before it should have gotten out. They made it impossible for the Sun software people to do what needed to be done.</p>

<p>今天在流行的东西，只是那些语言的“一半”。Sun公司有正确的人将Java变成第一流的语言。我相信这是Sun的营销人员在其本该出现之前，赶制出来的。他们使得Sun的软件人员不可能去做需要做的事。</p>

<p><strong>SF</strong> What should Java have had in it to be a first-quality language, not just a commercial success?</p>

<p>为了成为第一流的语言，而非商业的成功，Java本身还需具备什么？</p>

<p><strong>AK</strong> Like I said, it’s a pop culture. A commercial hit record for teenagers doesn’t have to have any particular musical merits. I think a lot of the success of various programming languages is expeditious gap-filling. Perl is another example of filling a tiny, short-term need, and then being a real problem in the longer term. Basically, a lot of the problems that computing has had in the last 25 years comes from systems where the designers were trying to fix some short-term thing and didn’t think about whether the idea would scale if it were adopted. There should be a half-life on software so old software just melts away over 10 or 15 years.</p>

<p>如同我前面说的，这是个流行文化。给十多岁青少年听的流行唱片，不必要有特别的音乐价值。我认为各种编程语言的很大成功是应急式的填坑。Perl是另外一个例子，为了满足细微而短期的需求，却成为更长期内的一个实际麻烦。根本上讲，过去25年中计算方面的很多问题，都来自于这样的系统，设计者试图修复一些事情，并没有思考如果采纳的话，这个点子应具扩展性。软件本该只有一半的寿命<em>(注：过去25年产生的软件)</em>，因此旧软件刚好在10到15年间消逝掉。</p>

<p>It was a different culture in the ’60s and ’70s; the ARPA (Advanced Research Projects Agency) and PARC culture was basically a mathematical/scientific kind of culture and was interested in scaling, and of course, the Internet was an exercise in scaling. There are just two different worlds, and I don’t think it’s even that helpful for people from one world to complain about the other world — like people from a literary culture complaining about the majority of the world that doesn’t read for ideas. It’s futile.</p>

<p>在1960和70年代，有着不同的文化；高级研究项目管理局(ARPA)和帕洛阿尔托研究中心(PARC)的文化，根本上讲，是一种数学/科学性的文化，对扩展性感兴趣。当然，Inernet就是规模化的一个练习。恰恰有两个不同的世界。我不认为，一个世界的人抱怨另一个世界的人甚至有什么帮助，就好像来自一个文学文化的人们抱怨世界上大多数的人不能读懂意思。这是无用的。</p>

<p>I don’t spend time complaining about this stuff, because what happened in the last 20 years is quite normal, even though it was unfortunate. Once you have something that grows faster than education grows, you’re always going to get a pop culture. It’s well known that I tried to kill Smalltalk in the later ’70s. There were a few years when it was the most wonderful thing in the world. It answered needs in a more compact and beautiful way than anything that had been done before. But time moves on. As we learned more and got more ambitious about what we wanted to do, we realized that there are all kinds of things in Smalltalk that don’t scale the way they should—for instance, the reflection stuff that we had in there. It was one of the first languages to really be able to see itself, but now it is known how to do all levels of reflection much better—so we should implement that.</p>

<p>我不想花时间抱怨这个事，因为在过去20年发生的非常正常，即使这是不幸的。一旦你有些东西，它比教育增长得更快，你总会得到一个流行文化。众所周知，我试图在70年代晚期终结Smalltalk。它在一些年头是世界上最漂亮的东西。它用比之前做过的任何东西更为紧致和漂亮的方式去回应需要，但时间在往前走。随着我们学会更多，对我们想做的事更有抱负的时候，我们认识到在Smalltalk中所有种类的事物，不能以它们本该的方式去扩展–例如，发射。它是真正看到它自身的最早的语言之一，但是现在知道了如何更好地做所有层次的反射。因此，我们必须实现之。</p>

<p>We saw after a couple of years that this could be done much better. The object model we saw after a couple of years could be done much better, etc. So the problem is—I’ve said this about both Smalltalk and Lisp—they tend to eat their young. What I mean is that both Lisp and Smalltalk are really fabulous vehicles, because they have a meta-system. They have so many ways of dealing with problems that the early-binding languages don’t have, that it’s very, very difficult for people who like Lisp or Smalltalk to imagine anything else.</p>

<p>几年之后我们看到，这可以做得更好。我们几年之后看到的对象模型可以做得更好，等等。因此，问题是–我曾经说过关于Smalltalk和Lisp，它们常常吃掉它们的幼崽。我的意思是，Lisp和Smalltalk是真正绝妙的载具，因为它们有一个元系统。它们有那些早期绑定语言不具备的如此多的方式去处理问题，以至于对于喜欢Lisp或Smalltalk的人非常难以想象还有其它什么。</p>

<p>Now just to mention a couple of things about Java: it really doesn’t have a full meta-system. It has always had the problem—for a variety of reasons—of having two regimes, not one regime. It has things that aren’t objects, and it has things that it calls objects. It has real difficulty in being dynamic. It has a garbage collector. So what? Those have been around for a long time. But it’s not that great at adding to itself.</p>

<p>现在谈到Java的一些事情：它确实没有一个全面的元系统。它总是因为不同的原因，有一个问题：它存在两个体制，而非一个体制。它有一些不是对象的东西，它有一些称为对象的东西。它成为动态的有实际的困难。它有一个垃圾收集器。那又怎么样？这些已经四处都是很久了。只将垃圾收集器加到它里面，不算高明。</p>

<p>For many years, the development kits for Java were done in C++. That is a telling thing.</p>

<p>在很多年，Java的开发工具用C++完成。这是个有说服力的事情。</p>

<p>We looked at Java very closely in 1995 when we were starting on a major set of implementations, just because it’s a lot of work to do a viable language kernel. The thing we liked least about Java was the way it was implemented. It had this old idea, which has never worked, of having a set of paper specs, having to implement the VM (virtual machine) to the paper specs, and then having benchmarks that try to validate what you’ve just implemented — and that has never resulted in a completely compatible system.</p>

<p>我们在1995年仔细观察Java，当时我们正着手一个主要的实现集，仅仅因为做一个可行的核有很多事情要干。我们最不喜欢的事情，是Java实现的方式。它有这样的陈旧想法，从来没有奏效过，即：定义一组纸面上的规范，要求按照纸面规范去实现VM(虚拟机)，然后用标杆去试图验证你刚刚实现的。这个想法从来没有产生一个完全兼容的系统。</p>

<p>The technique that we had for Smalltalk was to write the VM in itself, so there’s a Smalltalk simulator of the VM that was essentially the only specification of the VM. You could debug and you could answer any question about what the VM would do by submitting stuff to it, and you made every change that you were going to make to the VM by changing the simulator. After you had gotten everything debugged the way you wanted, you pushed the button and it would generate, without human hands touching it, a mathematically correct version of C that would go on whatever platform you were trying to get onto.</p>

<p>我们用在Smalltalk上的技术是用它自己来写虚拟机，因此有一个VM的Smalltalk仿真器，它本质上就是VM的唯一规范。通过将材料提交给它，你可以调试，你可以回答任何问题，关于VM可以做什么。一旦你将所有事情都以你想的方式调试通过，你按一下按钮，不需要人去插手，它将生成一个数学上正确的C版本，可以在你想尝试的任何平台上去运行。</p>

<p>The result is that this system today, called Squeak, runs identically on more than two dozen platforms. Java does not do that. If you think about what the Internet means, it means you have to run identically on everything that is hooked to the Internet. So Java, to me, has always violated one of the prime things about software engineering in the world of the Internet.</p>

<p>这一成果就是，今天称为Squeak的这个系统，在超过20个平台上无差别地运行。Java做不到这点。如果你想想Internet意味着什么，它意味着你必须无差别地运行任何挂在Internet上的东西。因此，Java，对我来说，常常违反关于软件工程在Internet世界的一个初衷。</p>

<p>Once we realized that Java was likely not to be compatible from platform to platform, we basically said we’ll generate our own system that is absolutely compatible from platform to platform, and that’s what we did.</p>

<p>一旦我们认识到，Java可能从平台到平台不兼容，我们从根本上决定，我们将生成我们自己的系统，它在平台到平台之间是绝对兼容的。这就是我们做的。</p>

<p>Anybody can do that. If the pros at Sun had had a chance to fix Java, the world would be a much more pleasant place. This is not secret knowledge. It’s just secret to this pop culture.</p>

<p>任何人都能做到。假使Sun的正方有机会修正Java，世界将会是更为愉悦的地方。这里没有机密的知识。仅仅对这一流行文化是个秘密。</p>

<p><strong>SF</strong> If nothing else, Lisp was carefully defined in terms of Lisp.</p>

<p>如果没有其它的，Lisp是仔细以Lisp的方式定义的。</p>

<p><strong>AK</strong> Yes, that was the big revelation to me when I was in graduate school—when I finally understood that the half page of code on the bottom of page 13 of the Lisp 1.5 manual was Lisp in itself. These were “Maxwell’s Equations of Software!” This is the whole world of programming in a few lines that I can put my hand over.</p>

<p>是的，当我在研究生院时，这对我是个巨大的启示–当我最终理解Lisp 1.5版手册第13页下部的半页代码，是Lisp自己的时候。这就是“软件中的麦克斯韦方程”。整个的编程世界可以放在聊聊几代码中–可以写在我的掌心。</p>

<p>I realized that anytime I want to know what I’m doing, I can just write down the kernel of this thing in a half page and it’s not going to lose any power. In fact, it’s going to gain power by being able to reenter itself much more readily than most systems done the other way can possibly do.</p>

<p>我认识到，任何时候当我想知道我正在做的，我就将这件事的核心写在半页纸上，这没有丧失任何力量。事实上，通过能够更容易地重新进入事情，比大多数系统尽可能用其它方式所能做的，将会获得力量。</p>

<p>All of these ideas could be part of both software engineering and computer science, but I fear—as far as I can tell—that most undergraduate degrees in computer science these days are basically Java vocational training.</p>

<p>所有这些想法，可以是软件工程和计算机科学的一部分。但是我担心–就我的判断–计算机科学里的大多数本科学位，根本上讲，是Java的职业培训。</p>

<p>I’ve heard complaints from even mighty Stanford University with its illustrious faculty that basically the undergraduate computer science program is little more than Java certification.</p>

<p>我从甚至强大的、拥有杰出教师队伍的斯坦福大学那里听到的抱怨是，根本上讲，本科计算机科学课程，没有比Java认证多出什么。</p>

<p><strong>SF</strong> Well, I must admit I was surprised recently when I discovered in a group of very good developers I managed, almost none of them knew C well enough to write expert low-level stuff. All of them were really good Java jocks.</p>

<p><strong>SF</strong> 好的，我必须承认，最近我有些惊讶，当我发现我管理的一个优秀开发人员组成的团队，几乎没有人足够懂C，能写出专家级的底层工作。他们确实都是Java的好手。</p>

<p><strong>AK</strong> In the 1960s Ted Steele spent several years promoting an idea called UNCOL (universal computer-oriented language), and, to me, by a weird and interesting process—mainly because it’s easy to implement—C turned out to be UNCOL. I don’t think any human being should write in it, but it’s a great target for anybody who wants to do multiplatform things—especially if you pick the right subset.</p>

<p><strong>AK</strong> 在1960年代，Ted Steele花了好几年向我推广一个称为UNCOL(universal computer-oriented language，通用面向计算机语言)的想法，通过一个怪诞和有趣的过程，主要是因为它容易实施 - C原来是UNCOL。我不认为任何人必须用它写程序，但是对于任何想做多平台事情的人，它是一个伟大的目标，特别是如果你选择了正确的子集。</p>

<p>The problem with the Cs, as you probably know if you’ve fooled around in detail with them, is that they’re not quite kosher as far as their arithmetic is concerned. They are supposed to be, but they’re not quite up to the IEEE standards. You have to pick a subset of C and you have to have some side information to get to a mathematically perfect transform of your VM.</p>

<p>各种C的问题，正如你可能知道的，如果你已经在细节上虚度时，只要算法被关注，他们就不那么合适。他们假定是，但他们没有完全遵守IEEE标准。你不得不选取C的子集，你必须有一些侧面的信息来得到对你虚拟机(VM)在数学上的完美转化。</p>

<p><strong>SF</strong> To what do you attribute the long-term love of Smalltalk? There is a certain set of languages that I would assert people seem to love, not just use. I know many people who love C. I know very few who love C++, even though they may make their living on it.</p>

<p>你把对Smalltalk长期的热爱归因于什么？有确定的一组语言，我断言人们看起来热爱，而不仅仅是使用。我知道，很多人爱C。我知道很少有人爱C++，尽管他们靠其谋生。</p>

<p><strong>AK</strong> You have to be a different kind of person to love C++. It is a really interesting example of how a well-meant idea went wrong, because [C++ creator] Bjarne Stroustrup was not trying to do what he has been criticized for. His idea was that first, it might be useful if you did to C what Simula did to Algol, which is basically act as a preprocessor for a different kind of architectural template for programming. It was basically for super-good programmers who are supposed to subclass everything, including the storage allocator, before they did anything serious. The result, of course, was that most programmers did not subclass much. So the people I know who like C++ and have done good things in C++ have been serious iron-men who have basically taken it for what it is, which is a kind of macroprocessor. I grew up with macro systems in the early ’60s, and you have to do a lot of work to make them work for you—otherwise, they kill you.</p>

<p><strong>AK</strong> 为了爱C++，你必须成为不同的人。这的确是个有趣的例子，良好用意的想法被搞砸了，因为C++的创造者Bjarne Stroustrup没有试图做那些他被批评的事。他的想法是，首先，如果对C做那些Simula对Algol做的事<em>(注：预处理器</em>，那是可能有用的。其根本上是作为一个预处理器，针对一个不同类的编程架构模板。对于超级程序员，在他们做任何正儿八经的事之前，假定可以子类化任何事物，是最基本的，包括对存储分配器。因此，我所知道的那些喜欢C++，并用它做出漂亮工作的人，是严肃的钢铁侠。他们只使用C++原本做的事，作为一种预处理器。在60年代早期，伴随宏系统而成长，你必须做很多事情来让它们为你工作–否则，它们会杀了你。</p>

<p><strong>SF</strong> Well, C++, after all, was programmed as a macro processor, in essence.</p>

<p>好的，C++，毕竟，本质上，作为一个宏处理器来编写的。</p>

<p><strong>AK</strong> Yes, exactly. But so was Simula.</p>

<p>是的，确实是。但Simula也是这样。</p>

<p><strong>SF</strong> I put Smalltalk in this category of languages that have true devotees—people who genuinely like it or love it, not simply appreciate and use it.</p>

<p>我把Smalltalk放在有真正热爱者的一类语言，人们真正地喜欢或爱它，而非仅仅欣赏或使用它。</p>

<p><strong>AK</strong> In a history of Smalltalk I wrote for ACM, I characterized one way of looking at languages in this way: a lot of them are either the agglutination of features or they’re a crystallization of style. Languages such as APL, Lisp, and Smalltalk are what you might call style languages, where there’s a real center and imputed style to how you’re supposed to do everything. Other languages such as PL/I and, indeed, languages that try to be additive without consolidation have often been more successful. I think the style languages appeal to people who have a certain mathematical laziness to them. Laziness actually pays off later on, because if you wind up spending a little extra time seeing that “oh, yes, this language is going to allow me to do this really, really nicely, and in a more general way than I could do it over here,” usually that comes back to help you when you’ve had a new idea a year down the road. The agglutinative languages, on the other hand, tend to produce agglutinations and they are very, very difficult to untangle when you’ve had that new idea.</p>

<p>在我为ACM写的一个Smalltalk的历史中，我描述一种看待语言的方式：很多语言要么是特性的凝聚，要么是风格的具体化(结晶)。象APL，Lisp和Smalltalk是你所称的风格性语言，它有真正的中心，然后把风格灌输到你假设要做的任何事情上。其它的语言，比如PL/I，那些试图加和特性而不做整合的语言，的确经常更成功。我认为，风格性语言吸引那些有特定数学惰性的人。懒惰实际上在日后有回报的，因为如果你停下来花一点点额外的时间看看“哦，对的，这个语言将允许我的的确确漂亮地做这个事，并以更普遍的方式让我在这儿来做”。而且如果你已经有了一年之后的新想法，这通常会回来帮到你。凝聚性语言，相反，常常产生凝聚性，当你有新想法时，它们非常非常难以解开。</p>

<p>Also, I think the style languages tend to be late-binding languages. The agglutinative languages are usually early-binding. That makes a huge difference in the whole approach. The kinds of bugs you have to deal with, and when you have to deal with them, is completely different.</p>

<p>而且，我认为风格性语言常常是延迟绑定的语言。凝聚性语言通常是早期绑定的。这在整个实现途径上，产生了极大的不同。你必须面对的bug类型，你必须在何时处理它们，都完全不同。</p>

<p>Some people are completely religious about type systems and as a mathematician I love the idea of type systems, but nobody has ever come up with one that has enough scope. If you combine Simula and Lisp—Lisp didn’t have data structures, it had instances of objects—you would have a dynamic type system that would give you the range of expression you need.</p>

<p>一些人对类型系统有完全宗教式的虔诚。作为数学家，我喜爱类型系统的想法，但是没有人曾经拿出过有足够范围的类型系统。如果你将Simula和Lisp综合起来，Lisp没有数据结构，它有对象实例–你将有一个动态类型系统，这会给你你所需的表达式的范围。</p>

<p>It would allow you to think the kinds of thoughts you need to think without worrying about what type something is, because you have a much, much wider range of things. What you’re paying for is some of the checks that can be done at runtime, and, especially in the old days, you paid for it in some efficiencies. Now we get around the efficiency stuff the same way Barton did on the B5000: by just saying, “Screw it, we’re going to execute this important stuff as directly as we possibly can.” We’re not going to worry about whether we can compile it into a von Neumann computer or not, and we will make the microcode do whatever we need to get around these inefficiencies because a lot of the inefficiencies are just putting stuff on obsolete hardware architectures.</p>

<p>这会允许你思考，那些你需要思考的想法，而不需担心类型是什么，因为你有一个非常非常更为宽泛的事物。你要付出的代价是，要做些检查，这可在运行时完成，特别是在旧的时期，你能用有效的方式支付这些代价。现在，我们绕开了Barton在B5000上以相同方式做的有效性东西，仅仅通过说，“上紧螺丝，我们将尽可能直接地执行这个重要的事情”。我们将没去担心我们是否能将其编译到一个冯诺依曼计算机里，以及我们将让微代码执行任何我们需要去绕过这些无效的地方，因为很多无效性仅仅是将事情放在过时的硬件架构上。</p>

<p>I just think that’s a two-culture divide. I’ve seen many meetings where people are unable to communicate just because of the stylistic differences in approaches.</p>

<p>我只是想这是两种文化的分割。我已经看过很多会议中，人们不能沟通，仅仅因为处理风格的不同。</p>

<p><strong>SF</strong> I would characterize style languages as those with a very rigorous kernel that describes them intellectually. As Smalltalk went through a number of revolutions, to what extent did those change the core kernel, as opposed to improving the range of usefulness?</p>

<p>我认为风格性语言的特征是，具有非常严谨的内核，它智能地描述了语言。Smalltalk经历过一些革新，相对于改进实用性的范围，它们在多大程度是对中心核的改变？</p>

<p><strong>AK</strong> We’ll never know the exact answer to your question because during the development of the system, from when Xerox put it out to this day, all the changes happened in a single thread of development at Xerox PARC. To the outside world, Smalltalk has changed almost not at all. Basically, it’s just built on bigger and bigger libraries of different kinds.</p>

<p>对你的问题，很难有确切的答案，因为在开发系统的过程中，从施乐将它创造出来到今天，所有的改变发生在施乐PARC开发的单一线程上。对于外在的世界，Smalltalk几乎没有一点改变。根本上讲，它仅仅是构建在越来越庞大的不同种类的库上。</p>

<p>But the good thing about the changes in Smalltalk was that it never got diluted, and the scope of the practical things you could think about doing in Smalltalk expanded dramatically during the period at Xerox PARC.</p>

<p>但是，关于Smalltalk的改变，好事是它从来没有被稀释过。你能想到用Smalltalk的实际工作的范围，在施乐PARC的期间，急剧地扩展了。</p>

<p>Basically what happened is this vehicle became more and more a programmer’s vehicle and less and less a children’s vehicle—the version that got put out, Smalltalk ’80, I don’t think it was ever programmed by a child. I don’t think it could have been programmed by a child because it had lost some of its amenities, even as it gained pragmatic power.</p>

<p>根本上讲，所发生的是，这个载具越来越变成一个程序员的载具，越来越少地作为儿童的工具–它得以出生的版本， Smalltalk ‘80，我不认为它曾由儿童来编程。我不认为他本应该已由小孩来编程，因为它已经失去了一些便利性，即使它获得了实用的力量。</p>

<p>So the death of Smalltalk in a way came as soon as it got recognized by real programmers as being something useful; they made it into more of their own image, and it started losing its nice end-user features.</p>

<p>因此，Smalltalk的死亡会以这种方式来临，一旦它被实际的程序员认为是有些用；他们按自己的想象去改变它，结果它开始失去了它漂亮的最终用户接口。</p>

<p>But that’s OK. This project that we started in 1995 was to make Squeak as an implementation vehicle for another end-user system for children. That was done quite well and is being used by many, many thousands of children around the world. The other way of looking at this is to realize that <strong><em>computers are made to be programmed by human beings</em></strong>. Let’s just roll our own. Let’s not complain about Java, or even about Smalltalk.</p>

<p>但这挺好的。我们开始于1995年的项目是把Squeak作为一个实现载具，它针对另一个面向孩子的最终用户系统。这件事做得很棒，已经被很多很多世界各地成千上万的孩子使用。看待这事的另一个方式是，认识到<strong><em>计算机做出来，就是为了让人类编程的</em></strong>。就让我们孤军奋战吧。让我们不要抱怨Java，乃至Smalltalk。</p>

<p>In fact, let’s not even worry about Java. Let’s not complain about Microsoft. Let’s not worry about them because we know how to program computers, too, and in fact we know how to do it in a meta-way. We can set up an alternative point of view, and we’re not the only ones who do this, as you’re well aware.</p>

<p>事实上，让我们甚至不要抱怨Java。让我们不要抱怨微软。让我们不要抱怨他们，因为我们知道如何对计算机编程，事实上我们知道如何对之采用元的方式(in a meta-way)。我们可以建立一个替代的视角，我们不是唯一这样做的人，你对此也很清楚。</p>

<p>There are numerous examples on the Internet of people who have gone to one level or another by making their own point of view. Squeak is the most comprehensive because it spans the whole field. It doesn’t require any particular operating system to run because it’s self-sufficient and has a full set of tools and applications and so forth, but there are many interesting functional languages, particularly in Europe, that are of interest.</p>

<p>在互联网上有大量的例子，通过有他们自己的观点，他们达到这个或那个层次。Squeak是最丰富的，因为它扩展到整个领域。它不需要特定的操作系统去运行，因为它是自给自足的，并有完整的工具集和应用等。不过，在欧洲，有很多有趣的函数式语言，很有趣。</p>

<p>One of my favorite old languages is one called Lucid by Ed Ashcroft. It was a beautiful idea. He said, “Hey, look, we can regard a variable as a stream, as some sort of ordered thing of its values and time, and use Christopher Strachey’s idea that everything is wonderful about tail recursion and Lisp, except what it looks like.” When he looked at Lisp, he had a great insight: which was that tail-recursive loops and Lisp are so clean because you’re generating the right-hand side of all the assignment statements before you do any rebinding. So you’re automatically forced to use only old values. You cannot rebind, so there are no race conditions on anything.</p>

<p>我喜欢的一个老的语言，Ed Ashcroft称之为Lucid。这是一个很漂亮的点子。他说，“嘿，看，我们能把变量看做一个流，以它的值和时间为排序，然后用Christopher Strachey的想法，即每件事情都是关于尾部递归和Lisp，除过它看起来的样子”。当他看到Lisp，他有了伟大的洞见：那就是，尾部递归循环和Lisp是如此清晰，因此你在做任何重新绑定之前，你正在生成所有赋值语句的右侧。因此，<strong><em>你自动地被强制只使用旧的值。你不能重新绑定，因此这里没有对任何东西的竞争。</em></strong></p>

<p>You just write down all of those things, and then when you do the tail recursion, you rebind all of those variables with these new values. Strachey said, “I can write that down like a sequential program, as a bunch of simultaneous assignment statements, and a loop that makes it easier to think of.” That’s basically what Lucid did—there is no reason that you have to think recursively for things that are basically iteration, and you can make these iterations as clean as a functional language if you have a better theory about what values are.</p>

<p>你恰恰正在写下所有那些事情，然后当你做尾部递归时，你用这些新值重新绑定所有的那些变量。Strachey说“我能象一个顺序程序一样写下他们，就像一捆同时赋值的语句，以及一个让它容易思考的循环“。这根本上讲，就是Lucid做的，<strong>没有理由你必须用递归方式思考那些本质上是迭代的事物</strong>。如果你有一个更好地关于值是什么的理论，你就能让这些迭代象函数式语言一样干净。</p>

<p>This idea, by the way, was used in [Squeak contributor] Dave Reed’s fantastic thesis for coordinating object siblings where you have one logical object but many physical manifestations of the same object on different machines, and you have to make them track each other by transactions.</p>

<p>顺便说一下，这个想法，在Dave Reed为了协调对象兄弟的美妙命题中也用到，在那里你有一个逻辑的对象，但是在不同机器上有很多相同对象的物理显化，你必须用事务来让他们可跟踪彼此。</p>

<p>The way to get rid of these things (like Smalltalk) is to make something that is much, much more powerful as a computation model and much more expressive for the core programmer who is trying to write programs. In these late programming languages, you can disappear the old guy and just leave the new guy behind. So we are doing that at this moment.</p>

<p>去掉这些事情的方式是做出一些更加更加强大的东西，来作为一个计算模型，并为了那些尝试写程序的核心程序员，要更具表现力。在这些后期的编程语言，你能让旧的家伙消失，而只让新的家伙在幕后。因此，我们现在就在做这些。</p>

<p><strong>SF</strong> What do you think a programming language should achieve and for whom, and then what is the model that goes with that idea?</p>

<p>你认为一个编程语言必须达到什么，并为谁？然后什么是与这个想法相配的模型？</p>

<p><strong>AK</strong> Even if you’re designing for professional programmers, in the end your programming language is basically a user-interface design. You will get much better results regardless of what you’re trying to do if you think of it as a user-interface design. PARC is incorrectly credited with having invented the GUI. Of course, there were GUIs in the ’60s. But I think we did do one good thing that hadn’t been done before, and that was to realize the idea of change being eternal.</p>

<p>即使你正在为专业的程序员设计语言，最终，你的编程语言根本上讲是用户界面设计。如果你将它看做一个用户界面设计，无论你正在尝试做什么，你都会得到更好一些的结果。GUI的发明被错误地归功于PARC。当然，在60年代有很多GUI。但是，我想我们的确做了之前从未做的一件好事，</p>

<p><strong>SF</strong> You never walk in the same river, otherwise known as Strachey streams.</p>

<p><strong>SF</strong> 你不会踏入同一条河流，就如同Strachey流。</p>

<p><strong>AK</strong> The user interface, which is still the predominant approach today, is a user interface as the access to function. If the area is interesting, you eventually wind up with something that looks like the control panel of a nuclear reactor. So this is the agglutination of features.</p>

<p><strong>AK</strong> 用户界面，在今天仍然是主导性的途径，是访问功能的用户界面。如果这个领域有趣，你最终会完成某些东西，看起来像核反应堆的控制面板。因此，这是特性的凝聚。</p>

<p><strong>SF</strong> Yes, a button on every pixel.</p>

<p><strong>SF</strong> 是的，每个像素有个按钮。</p>

<p><strong>AK</strong> Corporate buyers often buy in terms of feature sets. But at PARC our idea was, since you never step in the same river twice, the number-one thing you want to make the user interface be is a learning environment—something that’s explorable in various ways, something that is going to change over the lifetime of the user using this environment. New things are going to come on, and what does it mean for those new things to happen?</p>

<p><strong>AK</strong> 公司采购者经常按照特性集去采购。但是在PARC，我们的想法是，<strong><em>既然你不可能再次踏入同一条河流，你对用户界面想做的第一件事，是让它成为一个学习的环境</em></strong>–可以用不同方式去探索的东西，能够在用户使用这个环境的生命周期中不断改变。新事物总会到来，对于这些会发生的新事物，它(用户界面)意味着什么。</p>

<p>This means improvements not only in the applications but also in the user interface itself. Some of those ideas were quite manifest in the original Macintosh, but are much less manifest in the Macs of today—and of course never really made it to Microsoft. That just wasn’t their way of thinking about things, and I think a programming language is the same way. Even if the user is an absolute expert, able to remember almost everything, I’m always interested in the difference between what you might call stark meaning and adjustable meaning.</p>

<p>这意味着改进不但在应用层面，也在用户界面自身。在早期的Macintosh中，如此的一些想法十分明显，但是在今天的Mac电脑中却非常少见了 - 当然对微软事实上从未有过。这不仅指他们思考事情的方式，我想编程语言也一样。即使用户是绝对的专家，能记住几乎所有事情，我也对简易含义与可调整含义之间的差别，总保持兴趣。</p>

<p>I did quite a bit of study on that over the years to understand the influence of having something that you can read. It’s known that our basic language mechanism for both reading and hearing has a fast and a slow process. The fast process has basically a surface phrasal-size nature, and then there’s a slower one. This is why jokes require pauses; the joke is actually a jump from one context to another, and the slower guy, who is dealing with the real meanings, has to catch up to it.</p>

<p>在过去的一些年头，我做了些研究去理解，你有可阅读之物的影响。众所周知，我们的基础语言机制，对于读或听，有一个快速和一个慢速过程。快速过程根本上讲，具有表面的、短语尺度的特性。然后有一个更慢的过程。这就是为什么笑话需要停顿；笑话事实上是从一个语境跳到另一个语境。反应慢的人，他是在理解实际的意思，不得不跟上这个跳跃。</p>

<p>There have been many, many studies of this. This argues that the surface form of a language, whatever it is, has to be adjustable in some form.</p>

<p>有很多很多这样的研究。这表明，语言的表面形式，无论它是什么，必须以某种形式可调整。</p>

<p><strong>SF</strong> As you probably know, recent research has looked at how different parts of the brain recognize and react to jokes. Physically, they are quite distinct.</p>

<p><strong>SF</strong> 你大概知道，近期的研究已经在关注，大脑的不同部位，如何认出笑话并对之反映。物理上看，它们非常独特。</p>

<p><strong>AK</strong> Yes. All creativity is an extended form of a joke. Most creativity is a transition from one context into another where things are more surprising. There’s an element of surprise, and especially in science, there is often laughter that goes along with the “Aha.” Art also has this element. Our job is to remind us that there are more contexts than the one that we’re in—the one that we think is reality.</p>

<p><strong>AK</strong> 是的。所有创造性是笑话的一种延伸形式。绝大多数的创造性是从一个环境到另一个的跃迁，在后者中事情更为出乎意料。有个惊讶的要素，特别是科学中，经常是大笑之后跟着一个”啊哈”。艺术也有这个要素。我们的工作是让我们忆起，在我们所处的–我们认为是现实的环境之外，还有更多的环境。</p>

<p>In the ’60s, one of the primary goals of the computer science community was to arrive at an extensible language. As far as I know, only three ever actually worked, and the first Smalltalk was one of those three. Another very interesting one was done by Ned Irons, who invented the term syntax-directed compiler and did one of the first ones in the ’60s. He did a wonderful extensible language called Imp.</p>

<p>在60年代，计算机科学社群的一个主要目标是发明一个可延展的语言。就我所知，只有三个实际上做到了，第一代的Smalltalk是三者之一。另一个有趣的语言是由Ned Irons做出，他发明了“术语语法导向”的编译器，然后在60年代做出了首批的其中之一。他做出了一个漂亮的可延展语言，称之为Imp。</p>

<p>One of the things that people realized from these extensible languages is that there is the unfortunate difficulty of making the meta-system easy to use. Smalltalk-72 was actually used by children. You’re always extending the language without realizing it when you are making ordinary classes. The result of this was that you didn’t have to go into a more esoteric place like a compiler compiler—Yacc or something like that—to add some extension to the language.</p>

<p>人们从这些可延展的语言中认识到，做出易于使用的元系统，很不幸，是困难的。Smalltalk-72的确由孩子使用。当你在做普通类时(ordinary classes)，你总是在扩展语言而没认识到。结果是，你不必进入到一个更为神秘的地方，比如编译器的编译器–Yacc或其它类似的–为了给语言添加扩展。</p>

<p>But the flip side of the coin was that even good programmers and language designers tended to do terrible extensions when they were in the heat of programming, because design is something that is best done slowly and carefully.</p>

<p>但是硬币的另一面是，甚至优秀的程序员和语言设计者，也常常做出可怕的扩展，因为最好慢慢地、仔细地做设计。</p>

<p><strong>SF</strong> And late-night extensible programming is unsupportable.</p>

<p><strong>SF</strong> 不支持宵夜式的可延展语言。</p>

<p><strong>AK</strong> Exactly. So Smalltalk actually went from something that was completely extensible to one where we picked a syntax that allowed for a variety of forms of what was fixed, and concentrated on the extensibility of meaning in it.</p>

<p><strong>AK</strong> 的确。因此，Smalltalk事实上来自那些可完全延展到的东西，而达到一个语言，在其中我们选择一个语法，允许各种固定下来的形式，然后我们专心于其中含义的可延展性。</p>

<p>This is not completely satisfactory. One of the things that I think should be done today is to have a fence that you have to hop to forcibly remind you that you’re now in a meta-area—that you are now tinkering with the currency system itself, you are not just speculating. But it should allow you to do it without any other overhead once you’ve crossed this fence, because when you want to do it, you want to do it.</p>

<p>这还没有完全满意。我考虑今天必须做的事情之一是，设置一个围栏，强制你必须跳过去，从而提醒你，你现在处于一个元领域–你现在正在摆弄货币系统本身，你不仅仅是在投机。但是，一旦你跨过了这道围栏，它将允许你这么做，没有任何其它的开销。因为，当你想做的时候，你就是想做它。</p>

<p>I could go on and on. I feel like my answers are quite trivial since nobody really knows how to design a good language, including me.</p>

<p>我会继续往前、往前走。我感觉，我的回答是非常微不足道的，既然没有人真的知道如何设计一个好的语言，包括我。</p>

<p><strong>SF</strong> What do you wish you had done differently in the Smalltalk era?</p>

<p>你希望，在Smalltalk时代，你有什么会做的不同？</p>

<p><strong>AK</strong> I had the world’s greatest group, and I should have made the world’s two greatest groups. I didn’t realize there are benefits to having real implementers and real users, and there are benefits to starting from scratch every few months. I hired finishers because I’m a good starter and a poor finisher, but it took me a long time to realize that I was interfering with them by trying to improve things.</p>

<p>我有世界上最伟大的团队，我本应该建立两个最伟大的团队。我没有认识到，同时拥有真实的实现者和真实的用户，其中的好处，以及每几个月从头开始的好处。我聘用了润饰者(完工者)，因为我是个好的启动者却是个糟糕的润饰者。但是，我花了很长时间才认识到，我为了试图改进事情，正在打扰他们。</p>

<p>I believe that the only kind of science computing can be is like the science of bridge building. Somebody has to build the bridges and other people have to tear them down and make better theories, and you have to keep on building bridges.</p>

<p>我相信，计算科学唯一的类别好似桥梁构建的科学。有些人必须造桥，而其他的人必须拆卸它们并作出更好的理论，而你不得不继续造桥。</p>

<p><strong>SF</strong> And every so often, you have to watch one fall into the drink.</p>

<p><strong>SF</strong> 时不时，你不得不看到有人沉迷于酒中。</p>

<p>© 2004 ACM 1542-7730/04/1200</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/concepts-in-lisp/">Concepts in LISP</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-01T12:07:42+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:07 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h3 id="functional-programming">Functional Programming</h3>

<p>The only thing a function can do is calculate something and return it as a result. </p>

<p>函数能做的唯一事情，是算出点东西，然后将它作为结果返回。</p>

<h3 id="forms">Forms</h3>

<p>The things which you type to the LISP interpreter are called forms; the LISP interpreter repeatedly reads a form, evaluates it, and prints the result. This procedure is called the read-eval-print loop.</p>

<p>你键入到Lisp中的东西，称为form。Lisp 反复地读取一个form，对它求值，然后打印结果。这个过程称为，“读取-求值-打印”循环，缩写为REPL。</p>

<p>In general, a form is either an atom (for example, a symbol, an integer, or a string) or a list. If the form is an atom, LISP evaluates it immediately. Symbols evaluate to their value; integers and strings evaluate to themselves. If the form is a list, LISP treats its first element as the name of a function; it evaluates the remaining elements recursively, and then calls the function with the values of the remaining elements as arguments.</p>

<p>通常，一个form要么是原子(例如，符号、整数或字符串)，或者是列表。原子，也称为正常form或自求值form(normal form or self-evaluating form)。符号求值为它们的值；整数和字符串求值为他们自己。如果form是列表，也称为复合form(compound form)。LISP将其第一个元素视为函数名；它迭代地对剩下的元素求值，然后将剩下元素的值作为参数来调用函数。</p>

<h4 id="special-form">Special Form</h4>

<p>A special form is a form with special syntax, special evaluation rules, or both, possibly manipulating the evaluation environment, control flow, or both. A special operator has access to the current lexical environment and the current dynamic environment. Each special operator defines the manner in which its subexpressions are treated—which are forms, which are special syntax, etc. </p>

<p>The set of special operator names is fixed in Common Lisp; no way is provided for the user to define a special operator. The next figure lists all of the Common Lisp symbols that have definitions as special operators.</p>

<p>(来源：<a href="http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm">http://www.lispworks.com/documentation/HyperSpec/Body/03_ababa.htm</a>)</p>

<p>特殊form是一个form, 带有特殊语法或特殊求值规则，或兼有。它可能操纵求值环境、控制流，或兼有。一个特殊的运算符访问当前的词法环境和当前的动态环境。每个特殊的运算符定义了，如何处理其子表达式的方式，哪些是form，哪些是特殊语法，等等。</p>

<p>在Common Lisp中，特殊运算名的集合是固定的。没有给用户提供定义特殊运算符的方式。如下列出了所有作为特殊运算符定义的Common Lisp符号。</p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th> </th>
      <th> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>block</td>
      <td>let*</td>
      <td>return-from</td>
    </tr>
    <tr>
      <td>catch</td>
      <td>load-time-value</td>
      <td>setq</td>
    </tr>
    <tr>
      <td>eval-when</td>
      <td>locally</td>
      <td>symbol-macrolet</td>
    </tr>
    <tr>
      <td>flet</td>
      <td>macrolet</td>
      <td>tagbody</td>
    </tr>
    <tr>
      <td>function</td>
      <td>multiple-value-call</td>
      <td>the</td>
    </tr>
    <tr>
      <td>go</td>
      <td>multiple-value-prog1</td>
      <td>throw</td>
    </tr>
    <tr>
      <td>if</td>
      <td>progn</td>
      <td>unwind-protect</td>
    </tr>
    <tr>
      <td>labels</td>
      <td>progv</td>
      <td> </td>
    </tr>
    <tr>
      <td>let</td>
      <td>quote</td>
      <td> </td>
    </tr>
  </tbody>
</table>

</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/3">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/index.html">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/04/how-to-make-mac-os-write-ntfs-volume/">Mac系统下如何让NTFS磁盘卷可写</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/04/notes-on-how-google-works-1/">《谷歌如何运作》笔记一：前言</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/rsa-and-implemenation-by-self-in-python/">RSA and Implemenation by Self in Python</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/chaos-communication-congress-a-very-german-hacking-conference/">混沌通讯会议：一场很德国的黑客大会</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/02/face-analysis/">Face Analysis</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Steven Liu <stevenliucx@gmail.com> -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
