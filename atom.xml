<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Life Matrix]]></title>
  <link href="http://hack.the-lifematrix.net/atom.xml" rel="self"/>
  <link href="http://hack.the-lifematrix.net/"/>
  <updated>2016-11-05T23:01:43+08:00</updated>
  <id>http://hack.the-lifematrix.net/</id>
  <author>
    <name><![CDATA[Steven Liu ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《谷歌是如何运营的》笔记二：创新]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/11/notes-on-how-goole-works-2/"/>
    <updated>2016-11-05T20:23:30+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/11/notes-on-how-goole-works-2</id>
    <content type="html"><![CDATA[<p>史蒂夫·乔布斯清晰地预见了这一前景。作为改变世界的创意精英，乔布斯无人能及。他集深厚的专业知识、艺术禀赋和经济头脑于一身，创造出让人欲罢不能的电脑产品。在满是书呆子和商人却稀缺艺术家的科技行业中融入<strong>美与科学</strong>的人，也是乔布斯。通过与乔布斯共同工作的经验以及对他的观察，我们对创意精英有了很多认识，是他让我们看到了个人魅力对企业文化的影响，也让我们看到了<strong>文化与成功之间的直接关系</strong>。</p>

<p>…</p>

<p>两家公司都会尽量避开传统的市场调查，靠自己的能力去揣摩消费者的需求，我们对自己的眼光都信心十足。除此之外，两家企业都将<strong>为消费者创造最佳体验</strong>奉为重中之重。</p>

<h2 id="section">创新是什么</h2>

<p>在我们看来，创新不只是创造新奇实用的想法，还包括实践。“新奇”往往会被当做“新颖”的近义词，因此我们有必要指出，<strong>创新的东西不仅需要新的功能，还需要出人意料</strong>。</p>

<p>如果你的产品只是满足了消费者提出的需求，那么你就不是创新，而只是做出回应。回应是好的，但毕竟不是创新。另外，用“实用”这个词来描述高大上的“创新”，实在有点黯然，因此我们在前面加上一个副词，<strong>把实用变成”非常实用”</strong>：创新的东西不仅要新颖、出人意料，还要非常实用。</p>

<p>在决定是否要实践某个想法的时候，Google[x]团队会用到一张简单的韦恩图：</p>

<p>&#8220;`
第一，这个想法必须涉及一个能够影响数亿人甚至几十亿人的巨大挑战或机遇。</p>

<p>第二，这个想法必须提供一种与市场上现存的解决方案截然不同的方法。我们不希望在已有的做事方法上改进，而是想另辟蹊径。</p>

<p>第三，将突破性解决方案变为现实的科技至少必须具备可行性，且在不久的将来可以实现。
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class=""><span class="line">
</span><span class="line">### 适宜创新的环境
</span><span class="line">
</span><span class="line">这是创新的先决条件。这样的环境（即市场空间），一般会出现在飞速发展且竞争激烈的市场中。（许多公司都把目光聚焦在无人驾驶汽车上，且其中绝大多数都是汽车公司！）
</span><span class="line">
</span><span class="line">
</span><span class="line">**不要把眼光放在无人问津的市场并在这里孤军奋战。你应当发掘创新的途径，跻身进入大型或有潜力发展壮大的市场上。**
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
这个理念看起来或许难以接受，毕竟，未被开发且无人竞争的崭新市场，许多实业家都想进入。但是，一个市场通常不会平白无故就乏人问津，而是因为市场规模无法支撑其事业的扩张。</p>

<p>不要忘了，谷歌在网络引擎市场中并不算抢占先机，而是后来居上。
&lt;div class=&#8217;bogus-wrapper&#8217;&gt;<notextile><figure class="code">&lt;div class=&#8221;highlight&#8221;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#8221;gutter&#8221;&gt;&lt;pre class=&#8221;line-numbers&#8221;&gt;<span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#8217;code&#8217;&gt;&lt;pre&gt;<code class=""><span class="line">
</span><span class="line">
</span><span class="line">### 科技
</span><span class="line">
</span><span class="line">科技是另一个值得思考的因素：你认为现在的科技会以怎样的方式进化发展？现在的科技有什么不同，你预期将来会发生怎样的变化？你的才能是否能让你在这种日新月异的环境中不断出新？
</span><span class="line">
</span><span class="line">## 首席执行官必须兼任首席创新官
</span></code>&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;</figure></notextile>&lt;/div&gt;
乌迪12岁的女儿在看过他在一次工程师全体大会上的发言后，曾经对他说：“你浪费了几百个工程师的时间，只为了告诉他们一定要创新。你觉得这样能创新吗？”这可能是刺激他离职的原因。
&#8220;`</p>

<p>“统一的指挥”和“创新”两个词不应出现在同一句子中。</p>

<p>作为企业管理者，我们自然喜欢管理。想要完成某项任务？安排专人负责就行了。但是，创新可不能靠传统MBA式的管理方法。与常规业务不同，创新不可把握、无法强制，也不能事先安排。</p>

<p><strong>有创意的人不需要别人来布置任务，而需要有人提供空间。</strong></p>

<p>换言之，创意的开发应该是一个有机的过程。一个个想法冒出来，好似在一片混沌之中产生的基因突变一般，经过漫长而曲折的过程后，终于实现了蜕变。而创意，就是这个过程的最终目的地。在这条路上，比较强大的构想不断吸引支持者，势能越来越大，而欠佳的构想则会被半路淘汰。</p>

<p><strong>实现这场进化不能靠特定的路径，无路可循才是其基本特点</strong>。你可以把这个过程看作“构想的物竞天择”。</p>

<p>所有的公司不仅要先营造一个让各种创意因素以新奇的方式自由碰撞的环境，还要提供时间和自由，让小部分创意进化和生存，并让余下的大部分凋零和消亡。</p>

<p>打造混沌的企业文化并不是新鲜理念。在刚成立的企业里，企业文化处于初始状态，公司上下游一种放手一搏的心态。这时，创新的混动状态非常容易形成。加入新公司的人渴望冒险，这也是公司吸引他们加入的原因之一。但一旦公司的人数超过500人，一些对风险持规避态度的人便会陆续加入。在这些人中不乏资质过人的创意精英，他们只是不会对挑战跃跃欲试罢了。并非每个人都是创新之人，这就是事实。因此，你培养的混动不仅要为创新者提供给创新空间，还需要为其他人提供参与和成长的沃土。</p>

<p><a href="http://www.ted.com/talks/derek_sivers_how_to_start_a_movement">Derek Sivers:How to start a movement</a>, 要点：
* 行动易于模仿
* 第一个追随者，将孤独的前行者转变为leader
* 要平等对待追随者。变成共同的运动</p>

<p>“第一追随者”原则：在发起一个行动时，吸引第一个追随者是至关重要的。“将一个孤独的疯子变成领袖的，是第一个追随者。”创新的混沌环境需要给这些创新人才 – 或者说在山边独舞的疯子 – 创造条件。但除此之外，这个环境还需要给那些参与创新项目的人 – 也就是从第二个到第二百个加入群舞的疯子 – 创造空间。</p>

<p>正因如此，你需要将创新融入企业，让每个部门和每个领域都收到感染。如果你只将创新局限为某个团队的特权，那么你或许能为这个团队吸引到创新人才，却无法吸引足够的“第一追随者”。</p>

<p>仙童半导体及英特公司的联合创始人罗伯特·诺伊斯曾说：“<strong>乐观是创新的一个必要条件</strong>。否则，你怎能放弃安逸而追求改变，或离开舒适的环境而选择冒险呢？”你所雇佣的人，不仅要能产生新构想的头脑，也要足够疯狂地相信这些构想有机会实现。你需要挖掘和吸引这些乐观的人才，并提供平台，让他们创造改变、大胆冒险。</p>

<h2 id="section-1">聚焦用户</h2>

<p>而在谷歌，为核心产品带来重大转变的新功能还有几周就要问世了，却还没有做过详细的财务分析呢。但是，这项功能无疑会对用户带来便利，我们心知肚明，发布才是最佳的商业决策。</p>

<p>谷歌明白，在互联网时代，用户的信赖与美元、欧元、英镑、日元或任何其他货币一样重要。要让企业获得持续的成功，出了依靠产品质量以外别无他法。因此，我们的产品战略，就是聚焦用户。就像拉里和谢尔盖在IPO中说的那样：“为终端用户服务是谷歌业务的核心，是我们的第一要务。”</p>

<p>但是，“聚焦用户”这句话只说了一半，完整的句子应该是：“聚焦用户，一切水到渠成。”意思是，我们会始终为用户做对的事情，也相信我们的创意精英能够想办法从中获利。这个过程需要时间，因此要坚持这样做需要信心。</p>

<p>…</p>

<p>一位摩托罗拉的高管告诉乔纳森，在摩托罗拉，“客户”所指的不是手机使用者，而是指公司真正的客户，也就是为Verizon通信以及AT&amp;T等手机运营商。这些运营商并没有实时聚焦用户。摩托罗拉的焦点也没有放在用户身上，而是对准了合作伙伴。</p>

<p>在谷歌，我们的用户就是使用我们产品的人，而我们的客户则是花钱投放广告以及购买我们技术使用权的公司。这两个群体之间很少会出现冲突。如果出现矛盾，我们还是会以用户利益为重。这是所有行业都必须遵从的做法。现在，用户比以往更加强大，也不会买劣质产品的帐了。</p>

<h2 id="section-2">往大处想</h2>

<p>较大的问题通常也较容易解决，因为挑战越大，越能吸引顶尖人才。巨大的挑战和资质过人、精于技术的人才之间存在着一种共生关系。也就是说，优秀人才能够解决问题，又能从中得到满足。</p>

<p><strong>把巨大的挑战交给不适合的人，就是在制造压力，而选对了人，你就是在播种快乐。</strong></p>

<p>处于这些因素，巨大的挑战往往是吸引以及留住创意精英的强大磁场。</p>

<h2 id="section-3">制定（近乎）遥不可及的目标</h2>

<ul>
  <li>将目标放大10倍</li>
  <li>OKR 不同于“低承诺、高实现”的管理方式</li>
</ul>

<h2 id="section-4">70/20/10 原则</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像识别和视觉识别的资源]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/09/resources-on-image-and-visual-search/"/>
    <updated>2016-09-06T14:19:29+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/09/resources-on-image-and-visual-search</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《谷歌是如何运营的》笔记一：文化]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/05/notes-on-how-google-works-1/"/>
    <updated>2016-05-05T11:50:04+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/05/notes-on-how-google-works-1</id>
    <content type="html"><![CDATA[<h2 id="section">文化：相信自己的口号</h2>

<p>2002年5月一个周五的下午，拉里·佩奇(注：Google创始人)在谷歌网络上闲逛。他键入搜索词条，想看看会搜出什么样的页面和广告，而得到的结果让他非常不满意。他键入一个搜索请求，但有的广告却与搜索词条完全不沾边。</p>

<p>如果你搜索的词条是“川崎H1B”，搜索结果中会包括许多律师帮助移民申请H-1B美国签证的广告，但没有一条是有关搜索词条所指的川崎老款摩托车的。如果你键入的词条是“法国洞穴绘画”，那么你会搜出标题为“在某某处购买法国洞穴绘画”的广告，广告中出现的网上零售商一眼就能看出不是拥有法国洞穴绘画的主儿（甚至连复制品都不会有）。</p>

<p>谷歌的关键词广告搜索引擎本应按照搜索词条筛选出最搭配的广告，谁知却偶尔会为我们的用户搜出如此无用的信息，这让拉里不寒而栗。</p>

<p>…</p>

<p>杰夫在信中详尽地分析了问题出现的原因，提供了一份解决方案，并给出了五人利用周末时间编写出的解决方案模型以及超链接，还附加了测试结果，证明新模型与当时通用的系统相比有哪些优越性。这份解决方案的细节繁冗且专业性强，但其大意就是：我们准备计算出“广告相关度数值”，以此来评估广告与搜索请求的相关性，然后根据得出的数值来决定广告是否出现，以及出现在页面的什么位置。<strong>广告的先后排列应以其相关性为判断标准，而不是只以广告商愿意支付的费用或每条广告所获的点击量为依据，这个核心理念成为谷歌Adwords引擎赖以生存的基础。由此，一项价值几十亿美元的业务应运而生</strong>。</p>

<p>这件事最重要的细节是什么？广告根本就不属于杰夫及其团队的管辖范畴。他们只是碰巧在那个周五的下午来到办公室，看到了拉里的留言而已。他们明白，既然谷歌的使命是“整合全球信息，使人人皆可使用并从中受益”，那么糟糕（也就是无益）的广告（即信息）就自然是个问题了。因此，即使牺牲周末时间，他们也决定解决这个问题。</p>

<p>这几位员工并不直接负责广告业务，即便广告业务出了问题也不会归咎到他们头上，但他们竟然贡献出周末时间，不仅解决了别人的问题，还在解决过程中为公司盈利。这个例子，将谷歌企业文化的力量彰显得淋漓尽致。杰夫及其同事对谷歌的当务之急深谙于心，也明白自己可以放手解决任何阻碍谷歌成功的严重问题。如果他们失败了，没有人会以任何方式斥责他们：如果他们成功了，也没有人（包括广告团队的成员）会对他们的成绩起嫉妒之心。实际上，并不是谷歌文化将这五位工程师在短短的周末变身拯救公司的“忍者”，而是一开始谷歌文化就吸引了这五位“忍者”加入公司。</p>

<p>在考虑一份工作时，许多人首先关注的是职位、职责、公司以往的业绩、行业的整体情况以及薪酬福利。接着往下数，我们或许会在“通勤用时”和“餐厅咖啡品质”这两项之间找到企业文化这一项。然而，<strong>创意精英却会将企业文化放在首位加以考虑。要办事有效，员工必须在乎工作环境。因此，在新加入一家企业或一项事业时，文化是最应重视的因素</strong>。</p>

<p>在企业成立之初就认真考虑并且确定你希望的企业文化，这才是明智之举。最好的做法就是询问构成企业核心队伍的创意精英，因为他们不仅了解企业秉承的信条，也与你一样信奉这些信条。创始人就是企业文化的源头，而创始人为实现大计而物色并信赖的团队，才是企业文化的最佳体现。所以，你要问一问你的团队：</p>

<ul>
  <li>我们重视什么？</li>
  <li>我们的信念是什么？</li>
  <li>我们想成为什么样的企业？</li>
  <li>我们希望企业在实际行动和制定决策时采取什么样的方式？</li>
</ul>

<p>然后，把他们的回答记录下来。毋庸置疑，答案中一定包含着创始人的价值理念，但同时也会掺入不同的视角和经验，为创始人的价值观锦上添花。</p>

<p>多数企业都没能重视这一点，它们往往在成功之后才意识到记录企业文化的必要性，因此这项任务就落在了人力资源或公共关系部门肩上。这些部门的人员大多不属于企业的创始团队，他们的任务只是编慕一份凸显企业精髓的使命宣言。他们写就的宣言中，往往堆砌着“顾客满意”、“股东权益最大化”以及“富有创新精神的员工”等陈词滥调。<strong>而一家企业是否成功，要看员工是否信服使命宣言中的说辞</strong>。</p>

<p>…</p>

<p>两位创始人并不想追求短期利益的最大化，也不关注公司股票的变现能力，因为他们知道，记录谷歌独特的价值观以备未来的员工和合作伙伴参考，才是决定企业长远利益的重要因素。</p>

<h2 id="section-1">拥挤出成绩</h2>

<p>占领地盘是人的天性，职场中也不例外。在多数公司里，办公室的面积、摆设物品的品质以及窗口的景致都是办公室主人成就与地位的象征。如果想要把机敏的员工变得牢骚满腹，用新的办公位置就能立马搞定。不少企业都会利用办公位置限制员工的自由发展。 …   在这样的环境中，所有特权都与职位挂钩，而不看员工的实际需求和具体业绩。</p>

<p><strong>办公室的设计本应本着激发活力、鼓励交流的理念，而不要一味制造阻隔、强调地位</strong>。方便的交流可以为创意精英提供灵感，把创意精英聚集在一起，你就能引爆他们的思想。因此，我们必须为他们提供一个拥挤的环境。</p>

<p>我们认为，办公状态应鼓励大家多多交流，让大家在喧闹拥挤的办公室里创所欲言、激情碰撞。在参与完团队活动后，员工可以到清净之地换换脑子。</p>

<h2 id="section-2">一起吃住，一起工作</h2>

<p>在互联网时代，产品经理的任务是与设计、策划以及研发人员通力合作，共同打造高质量的产品。这样的模式要求产品经理通过涉足一些传统概念中的管理工作来影响产品生命周期、制定产品营销结构图、为消费者说话，并把这些理念传递给自己的团队和管理层。最重要的是，创意精英式的产品经理还需要从技术入手，让产品质量更上一层楼。这就要求这些经理对消费者使用产品的方法有所了解（也要把握科技发展对消费者的使用方法带来的影响），也就是说，他们不仅要学会解读和分析数据，还要看懂科技潮流，预见这些潮流对他们所在的行业带来的影响。这就要求产品经理与工程技术人员（或是化学家、生物学家、设计师以及公司其他负责产品设计研发的创意精英）一同吃住、并肩工作。</p>

<h2 id="section-3">别听父母的：杂乱是种美德</h2>

<p>虽然办公室可以杂乱拥挤，但办公室要为员工提供工作所需的一切条件。那谷歌为例，谷歌是一家计算机公司，所以计算能力是我们的创意精英们最需要的。处于这个原因，谷歌向工程师们提供世界上最强大的数据中心和谷歌的整个软件平台。慷慨向员工提供工作中必须用到的资源，不失为一种根除职场办公资源相互攀比风气的方式。在奢华的办公设施和宽敞的办公室等无足轻重的资源上，我们能省就省，但对于这些关系重大的资源，我们则不惜倾力投入。</p>

<p>这种疯狂举动背后自由其道理。我们购买办公室，是因为我们希望员工在办公室办公，而不是在家里办公。正如乔纳森常说的，在家办公其实无异于一种会在整个公司内蔓延、让员工士气萎靡不振的瘟疫。已故的贝尔实验室前董事长默文·凯利就是本着鼓励员工相互沟通的理念来设计公司办公格局的。</p>

<h2 id="section-4">别听“河马”的话</h2>

<p>我们所说的职场中的“河马”，指的是“高新人士的意见”。从本质上来说，薪金的高低与决策能力完全无关，而只有在决策人使用个人经验作为有力凭据时，我们才能说经验的多寡对决策有所影响。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac系统下如何让NTFS磁盘卷可写]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/04/how-to-make-mac-os-write-ntfs-volume/"/>
    <updated>2016-04-14T10:41:12+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/04/how-to-make-mac-os-write-ntfs-volume</id>
    <content type="html"><![CDATA[<p>NTFS是微软Windows默认的磁盘格式。在Mac系统下，默认是只读的。比如你的移动硬盘或U盘，在Windows下按照默认格式(NTFS)去格式化，那么在Mac系统下，尽管能识别盘符，查看内容，却不可写入。</p>

<p>通常有三种方法：</p>

<ol>
  <li>将磁盘重新格式为FAT32, 在Windows和Mac下都可以读。对于有所数据的磁盘，不可取。</li>
  <li>采用第三方软件，提供NTFS写支持。但是在Mac升级后，经常会失效。</li>
  <li>修改配置文件，提供无缝支持。</li>
</ol>

<p>最好的是方法3，其实OSX Mountain Lion已经提供了对NTFS的支持，但默认情况下关闭着。开启的步骤是：</p>

<ul>
  <li>
    <p>卸载第三方NTFS软件，如Paragon, Tuxera 或 NTFS-3G</p>
  </li>
  <li>
    <p>修改文件 <em>/etc/fstab</em>,  可用命令 <code>sudo vi /etc/fstab</code>。 添加行:   </p>

    <p><code>
 LABEL=VOLUME_NAME none ntfs rw,auto,nobrowse
</code></p>

    <p>VOLUME_NAME是磁盘卷名，不能带引号。卷名可以用命令 <code>diskutil list</code> 或 <code>df -h</code> 查询。除过卷名，还可以用卷的UUID，查询的命令是  </p>

    <p><code>diskutil info /Volumes/VOLUME_NAME | grep UUID</code></p>
  </li>
  <li>
    <p>卸载磁盘，重新mount，即拔掉USB电缆，重新插一下。</p>
  </li>
</ul>

<p><strong>但是，我在Finder窗口中没看到磁盘啊！</strong></p>

<p>别着急，这种做法必须设置nobrowse，所以默认情况下，不会在Finder窗口显示。可以通过命令打开磁盘。</p>

<p><code>
open /Volumes/VOLUME_NAME
</code></p>

<p>如果想让磁盘出现在桌面上：</p>

<p><code>
sudo ln -s /Volumes/VOLUME_NAME ~/Desktop/VOLUME_NAME &amp;&amp; open ~/Desktop/VOLUME_NAME
</code></p>

<hr />

<p>参考了如下文章：</p>

<ul>
  <li><a href="https://prateekvjoshi.com/2013/04/21/ntfs-write-support-on-os-x-mountain-lion/">https://prateekvjoshi.com/2013/04/21/ntfs-write-support-on-os-x-mountain-lion/</a></li>
  <li><a href="http://osxdaily.com/2013/10/02/enable-ntfs-write-support-mac-os-x/">http://osxdaily.com/2013/10/02/enable-ntfs-write-support-mac-os-x/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《谷歌是如何运营的》笔记零：前言]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/04/notes-on-how-google-works-0/"/>
    <updated>2016-04-08T11:10:22+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/04/notes-on-how-google-works-0</id>
    <content type="html"><![CDATA[<h2 id="section">推荐序 – 赋能：创意时代的组织原则</h2>

<p>彼得 · 德鲁克，将过去200年组织创新分为三次革命：</p>

<p>第一次是<strong>工业革命(industrial revolution)</strong>，核心是机器取代体力，技术超越技能。</p>

<p>第二次是<strong>生产力革命(productivity revolution)</strong>，大致从1880年到第二次世界大战，核心泰勒制为代表的科学管理的普及，工作被知识化，强调的是标准化、可度量等概念。公司这种新组织正式随着科学管理思想的发展而兴起的。</p>

<p>第三次是<strong>管理革命(management revolution)</strong>，知识成为超越资本和劳动力的最重要的生产要素。和体力劳动相比，知识工作者是否努力工作很难被直接观察和测量。管理的重心转向激励，特别是动机的匹配(incentive alignment)。<u>期权激励</u>是这20年高科技企业大发展最主要的组织创新。</p>

<p>沿着这个思路，我们正处于第四次革命，即“<strong>创意革命”(creative revolution)</strong>。从互联网到移动互联网，再到物联网，从云计算到大数据，未来商业的一个基本特征已经清晰，那就是基于机器学习的人工智能将成为未来商业的基础。虽然对于人工智能的未来有着巨大的争议，特别是机器是否超越人脑，甚至是否反人类。但一个基本的共识是，在可见的未来，机械性的、可重复的脑力劳动，甚至较为复杂的分析任务，都会被机器智能取代。但人的直觉，对知识的综合升华能力，是机器暂时难以超越的。相对应的，未来社会最有价值的人，是以创造力、洞察力、对客户的感知力为核心特征的。他们就是本书所提到的“创意精英”。</p>

<p>而在创意革命的时代，创意者最主要的驱动力是创造带来的成就感和社会价值。自激励是他们的特征。这个时候他们最需要的不是激励，而是赋能，也就是提供他们能更高效创造的环境和工具。以科层制为特征、以管理为核心职能的公司，面临着前所未有的挑战。</p>

<p>赋能(empower)的原则如何体现呢？</p>

<p>第一，<strong>激励偏向是事成之后的利益分享</strong>，而赋能强调的，是激发创意人的兴趣和动力，给予挑战。唯有发自内心的志趣，才能激发持续的创造。命令不适用于他们。因此，组织的职能不再是分派任务和监工，而更多是让员工的专长、兴趣和客户的问题有更好的匹配，这往往要求更多的员工自主性、更高的流动性和更灵活的组织。我们甚至可以说，是员工使用了组织的公共服务，而不是公司雇佣了员工。二者的根本关系发生了颠倒。</p>

<p>第二，<strong>赋能比激励更依赖于文化</strong>。文化才能让志同道合的人走到一起。创意精英再也不能用传统的方法去考核、激励，公司的文化氛围本身就是奖励。本质上他们都是自驱动、自组织的，对文化的认同比较较真。为了享受适合自己的文化，创意精英愿意付出、拥护、共创。一个和他们的价值观、使命感吻合的文化才能让他们慕名而来，聚在一起，奋发进取，因而组织的核心职能将演变为文化与价值观的营造。</p>

<p>第三，激励聚焦在个人。而赋能特别强调组织本身的设计、人和人的互动。随着互联网的发展，组织内部人和人的联系也更紧密。新兴学科，例如复杂网络和社会物理学的研究，都指出人和人之间的互动机制的设计对于组织的有效性可能远大于对于个体的激励。谷歌那些声名远扬的免费服务，不仅仅是提供员工福利，提高员工的生产力，很大的一个目的是增进他们的互动。…… 创造是很难规划的。只有提供他们各自独立时无法得到的资源和环境（其中最重要的就是他们之间的充分互动），有更多自发碰撞的机会，才能创造更大的价值。…。这个传奇背后依然是一系列配套的机制设计，例如每周员工大会的透明沟通、员工的自主权、跨部门调动资源的能力等。所以，促进协同的机制设计，这是未来组织创新最重要的领域。</p>

<p>德鲁克在他最后一本书《21世纪的管理挑战》中提到，预测未来的最好方法是参与创造。</p>

<p>~~ 曾鸣</p>

<h2 id="section-1">序言： 谷歌的“痴心妄想”</h2>

<p>年少时，第一次考虑到自己的未来，我决定要么当个教授，要么就创造自己的公司。我觉得，这两种职业都可以给我足够的自主权，让我自由地从基本物理原则出发思考问题，而不必去迎合那些所谓的“世俗智慧”。</p>

<p>…</p>

<p>随着时间的推移，我意识到。实际上，想要点燃团队的熊熊野心是极其困难的。大多数人并没有接触过这种如登月般异想天开的思维方式，他们习惯用“不可能”来否定自己的想法，而不是从基本物理原则出发去探索可能性。正因如此，谷歌才会投入大量精力去物色善于独立思考的人，并设定远大目标。因为只有了合适的人才和足够远大的梦想，你的目标往往就可以实现。就算跌倒了，你也很可能从失败中跌倒宝贵的经验。</p>

<p>…</p>

<p>如果说历史可以照见未来，那么今天看似最冒险的赌注，放在几年之后看也就不会显得那么疯狂了。</p>

<p>~~ 拉里 · 佩奇</p>

<h2 id="section-2">谷歌是如何运营的</h2>

<h3 id="section-3">去和工程师谈谈</h3>

<p>两位创始人并没有接受任何商业方面的正式培训，也没有相关经验。其间，两人一直秉承着几条基本原则。其中首要的，就是聚焦用户(focus on the user)。两人觉得，如果谷歌能提供优质服务，那么资金问题就能迎刃而解。</p>

<p>…</p>

<p><strong>“员工即一切”</strong>。谢尔盖和拉里却在公司运营中实践了这句话。这种做法并非是为企业拉大旗，也不是出于利他主义。之所以这么做，是因为他们觉得，要让谷歌茁壮发展并实现看似遥不可及的雄心壮志，只能吸引和依靠最为顶尖的工程师。而且，两人认定非工程师不招。</p>

<p>…</p>

<p>因为拉里讨厌这种方式：
<br />
“你见过哪个团队的表现能超越既定目标？”
<br />
 呃，没有。
<br />
 “你的团队研发过比计划中更出色的产品吗？”
<br />
也没有。
<br />
“如果这样，计划还有什么意义？计划只是在拖我们的后腿罢了。一定有比计划更有效的方式，去和工程师谈谈吧。”</p>

<p>没错，拉里所说的工程师都是杰出的程序员和系统设计师，但除了技术方面的资深经验之外，很多人还具备敏锐的商业头脑，在创意上也是才思泉涌。</p>

<p>…</p>

<p>我们知道，对谷歌而言，一份正式而死板的计划，就像往身体里移植一个与身体相排斥的器官。</p>

<p>…</p>

<p>作为资深的商业管理者，在加入谷歌之时，我们以为自己之时在一个混乱的公司里实施“成人监督”。但是到2003年夏天，我们在谷歌的感受让我们意识到，这家公司的运营方式与多数公司不同：员工得到充分授权，公司所处的新兴行业日新月异。</p>

<p>对所处行业的了解告诉我们，<strong>要抵御微软的侵袭，我们就要一以贯之地保持产品的高质量。而我们同时也明白，要在产品品质上追求卓越，最佳的途径并非靠商业计划，而是要尽可能物色最顶尖的工程师，给他们空间让他们尽情发挥</strong>。</p>

<h3 id="section-4">芬兰计划</h3>

<p>这份计划全都是在讲谷歌应如何专注于用户，如何提供卓越的平台和优秀的产品。计划中阐明，谷歌应一如既往地提供并升级优质服务，同时还应让用户轻松享受到这些服务。其中倡导，谷歌应立足于用户，随着用户的增加，谷歌自然能吸引更多广告用户。计划中有几点策略谈到了谷歌应如何应对竞争对手对我们造成的威胁，但我们认为，<strong>对抗微软最好的方法，还是要靠杰出的产品</strong>。</p>

<h3 id="section-5">当神奇不再是神奇</h3>

<p>三股科技狂潮汇集在一起，让多数行业的大环境发生了乾坤大挪移。
<br />
第一，互联网让信息免费、资源不断、无处不在，也就是说，几乎所有信息都可以在网络上找到。
<br />
第二，移动设备和网络让全球范围内的资讯共享及持续通讯成为可能。
<br />
第三，云计算让人人都能以低廉的价格现付现购地使用强大的计算功能、无限的内存空间、精密的工具和各种应用程序。
<br />
时至今日，全球仍有很大一部分人口无法享受这些科技的泽惠，但是，这一切将发生改变，剩下的50亿人口上网的那一天已是指日可待。</p>

<h3 id="section-6">速度决定成败</h3>

<p>科技进步给消费者带来了不可小觑的影响，科技对商业的影响更是天翻地覆。用经济术语来说，如果某行业产品主要要素的成本曲线下降，那么该行业必将会出现剧变。而今，<strong>信息、连接和计算能力</strong>这三大生产要素都变得便宜了，那么与这些要素相关的成本曲线就难逃影响。</p>

<p>这样一来，破坏性剧变就不可避免了。当时许多企业(也就是互联网时代之前的企业)创建时是为了解决稀缺性：信息稀缺、配送资源稀缺、市场覆盖面不足、选择有限和货品匮乏。而今，这些资源都变得丰沛起来，降低甚至消除了行业进入的门槛，各行业的转变时机已经成熟。</p>

<p>最先出现转变的，是媒体行业。现在所有的媒体信息都可以转为电子数据，免费在世界各地传播。实际上，每个行业和领域或多或少都要依靠信息的推动，媒体、市场营销、零售、医疗、政府、教育、理财、交通、国防、能源等都是如此。能够在信息时代岿然不倒的行业，我们还真是一个也想不出来。</p>

<p>这种剧变的结果是，提供出类拔萃的产品是企业成功的关键，产品甚至比掌控信息、垄断渠道和强力营销更为重要（当然，这些因素仍然很重要）。这有几个原因：第一，消费者从未像现在这样拥有这么多信息和选择。以前，企业只要凭借强大的市场攻势或分销手段，就可以将劣质产品摇身变成畅销品。你只需生产出一款说得过去的产品，砸下大笔经费扼住营销渠道、限制消费者的选择，就可以坐等收成了。</p>

<p>…</p>

<p>消费者有了如此丰富的信息和选择，那些质量低劣的餐馆（无论是否连锁）就算拥有大笔营销经费也越来越难以站住脚跟了，而那些后起之秀却越来越容易凭借消费者的口口相传打出一片天地。</p>

<p>汽车、旅馆、玩具、服装以及消费者可以在网上搜索的任何产品或服务都是如此。数据货架空间几乎用之不竭（YouTube网站上足足有100多万个频道，亚马逊网站上仅商业领导力方面的书籍就达到了5万多种），这就为消费者提供了巨大的选择空间。除此之外，消费者还可以轻松对产品发表评论。因此，如果你的产品或服务欠佳，处境就危险了。</p>

<p>Excite@Home管理层的理念并不稀奇，许多管理者都认为，品牌和营销的力量可以帮助那些不尽如人意的产品站稳脚跟。听说过谷歌的Notebook吗？听过说Knol, iGoolge, Wave, Buzz, PigeonRank吗？这些都是谷歌的产品，虽然各有特点，但没有一款能够深入人心。究其原因，就是这些产品都不够优秀，死得其所。如果产品泛善可陈，其劣势是市场营销和公关营造的品牌力量完全不足以反转的。正如亚马逊创始人兼首席执行官杰夫 · 贝佐斯曾经说过的：“以前，人们花30%的时间打造优质服务，70%的时间大张旗鼓地宣传。但现在，情况正好相反。”</p>

<p>产品的卓越性能之所以至关重要，第二个原因是实现和失败的成本显著下降。这种现象在高科技行业尤为显著：几个工程师、研发者和设计者组成一个小团队，合力创造出新颖的科技产品，然后就可以通过网络免费在全球发行。构想并打造新产品、选定顾客群试用、判断产品的优点及缺陷、对产品进行调整、再次试用，不然就从失败中总结经验，放弃失败的产品、重新再来，以便提升用户体验。</p>

<p>多数企业现行管理模式的设计都跟时代的变化趋势完全不同。这些管理模式诞生于100多年之前，当时，失误所造成的成本损失很高，且只有企业最高管理者才能掌握全面的信息。这些管理者的首要目标就是降低成本，确保只有掌握大量信息的少数总裁级人物才有权制定决策。在这种传统的“指挥–控制”式企业结构中，信息自下往上流动，而决策有上往下传达。这种方法旨在放慢速度，也的确有效地减缓了速度。也就是说，当企业必须一致加速时，这种结构就会失灵，阻碍企业发展。</p>

<h3 id="section-7">创意精英</h3>

<p>令人欣慰的是，令产业格局翻天覆地的丰饶经济学也席卷职场，现今的职场与20世纪相比有天壤之别。如前所述，实验成本越来越低，失误所造成的损失（在处理得当的前提下）比以前大幅下降。除此之外，<strong>曾经稀缺的信息资源和计算资源现在非常丰沛，不必囤积</strong>。另外，无论你与同事在同一间办公室、一个大陆，还是身处地球的两端，彼此间的合作都变得畅通无阻。有了这些条件，你就可以将独立的人员、管理者甚至总裁凝聚在一起，干一份不可思议的大事业了。</p>

<p>简单地说，这些以信息为基础进行工作的人是靠头脑吃饭的。如今被称为“知识工作者”。</p>

<p>……</p>

<p>IBM、通用电气、通用汽车以及强生等企业都会为拥有管理潜能的顶尖人才铺设职业轨道，让这些管理之星每隔两年左右就可以调换一次岗位。但这种方法注重的是管理技能的培养，而忽视了技术方面的能力。这就造成在传统企业中，多数知识工作者，要么是技术达人、管理白痴，要么是管理管理专家、技术菜鸟。</p>

<p>如果我们把传统知识工作者与谷歌十几年来招徕的工程师等人才放在一起对比，就会发现谷歌的人才是一个截然不同的员工股群体。这些人不拘泥于特定的任务，也不受公司信息和计算能力的约束。他们不惧怕冒险，即便在冒险中失败，也不会受到惩罚或牵制。他们不被职位头衔或企业的组织结构羁绊手脚，甚至还有人鼓励他们将自己的构想付诸实现。如果出现不同意见，他们不会选择缄口不言。他们很容易失去耐心，经常变化职位。他们具有多领域的能力，经常会将前沿技术、商业头脑以及奇思妙想结合在一起。换句话说，至少从传统意义上来说，这些人已经不能算是知识工作者了。这是一个新的物种，<strong>我们称之为“创意精英”，他们，便是互联网取得成功的关键所在</strong>。</p>

<p>当今，提高产品研发速度及产品质量，已然成为企业最为注重的目标。自从产业革命之后，企业运营流程一直偏重于降低风险、规避失误。这样的流程，加之衍生出这种流程的整个管理模式，形成了一种压制创意精英的大环境。但是，决定当今企业成败的因素，就是要看企业是否持续推出高质量 的产品。要想实现这个目标，企业就必须吸引创意精英的加盟，并创造出让他们自由发挥的整体环境。</p>

<p>那么，到底哪种人才能算得上是创意精英呢？</p>

<p>所谓创意精英，不仅拥有过硬的专业知识，懂得如何使用专业工具，还需具备充足的实践经验。以谷歌所在行业为例，我们的创意精英大多是计算机科学家，或至少应该懂得计算机屏幕展现的魔法背后所遵循的系统结构及原则。在其他行业中，创意精英可以是医生、设计师、科学家、电影制作者、工程师、厨师或数学家。他们是专业上的行家里手，不仅能设计概念，还会建造模型。</p>

<p>创意精英，具有分析头脑。他们对数据运用自如，可以利用数据做出角色，同时也懂得数据的误导性。</p>

<p>创意精英，有商业头脑。他们知道专业技术、优质产品与商业成功是环环相扣的。也对这三个要素的价值了然于胸。</p>

<p>创意精英，具有竞争头脑。在工作中，他们的撒手锏源自创新，但也离不开实干的积累。他们追求卓越，干劲十足，即使在工作之余也不停止前进的脚步。</p>

<p>创意精英，拥有用户头脑。无论身处哪个行业，几乎没有人能比他们更懂得用户或消费者度产品的看法。我们把创意精英叫作“<strong>超级用户</strong>”。因为，他们对自己的兴趣并非浅尝辄止，而是近乎痴迷。他们充当自己的焦点小组和实现对象，身先士卒地试用产品。</p>

<p>创意精英，是新颖原创构想的源泉。他们用不同于你我的崭新视角看问题。有时候，他们甚至还能跳出自己的视角，因为他们懂得如何在必要时充当变换视角的“变色龙”。</p>

<p>创意精英，充满好奇心。他们总是在提问，绝不满足于守常不变。他们善于从各处发现问题，自信解决问题的人非己莫属。</p>

<p>创意精英，喜爱冒险。</p>

<p>创意精英，自动自发。他们不会坐等别人为他们指出方向，对于有悖于他们自己信念的指示，他们会选择充耳不闻。他们注重自己的理念，也会依据自己的理念主动行动。</p>

<p>创意精英，心态开放。他们可以自由地与他人合作，在评判构想和结论时，他们看重的是有点和价值而非出处。</p>

<p>创意精英一丝不苟，他们对细节掌握精确、如数家珍。这不是死记硬背的功劳，而是因为他们对这些知识熟谙于心。</p>

<p>创意精英，善于沟通。他们风趣幽默，无论面对的是一个人还是一群人。他们都气场十足，魅力四射。</p>

<p>并非所有的人都同时具有以上所有特质，实际上，同时具备上述所有优点的人凤毛麟角。但是，所有的创意精英都必须具备商业头脑、专业知识、创造力以及实践经验，这些都是基本特质。</p>

<p>关于创意精英，最令人欣慰的，就是这种人才无所不在。无论年龄大小，只要是那些有抱负并乐于（也有能力）利用科技去挑战更多可能的人，都是创意精英。这些人的共同特点是：认真努力、乐于挑战现状、敢于从不同的角度切入问题。正因如此，他们才有如此强大的影响力。</p>

<p>创意精英是一个极其难以管理的群体，因为无论你付出多少努力，都无法指挥这些人的想法。<strong>如果你无法管理创意精英的想法，就必须学会管理他们进行思考的环境，让他们乐于置身其中</strong>。</p>

<h3 id="section-8">谷歌的管理之道</h3>

<p>虽然谷歌当初邀我们加入的目的是让我们提供所谓的“承认监督”，但为了完成任务，我们俩不得不将有关管理的既有知识全盘推翻，将谷歌总部与我们朝夕相处的各位同仁当作自己最好的老师。</p>

<p>…</p>

<p>德高望重的思科公司首席执行官约翰·钱伯斯曾说过，在20世纪90年代初期，他经常与惠普公司首席执行官卢·普拉特会面，探讨战略和管理问题。有一次，钱伯斯不无赞叹地问普拉特，为什么要花如此多宝贵的时间帮助另一家公司的一位年轻高管。普拉特先生回答道：“这就是硅谷，我们就是来帮你的。”</p>

<p>…</p>

<p>同样，苹果公司已逝的创始人兼首席执行官史蒂夫·乔布斯，也秉承着同样的理念。生前，他常常为他的邻居拉里·佩奇出谋划策，他的表述更加生动。</p>

<p>我们两位作者都是以资深企业高管的身份加入谷歌的，对自己的才智与能力充满自信。但是经过十载的打磨，我们终于参透了篮球教练约翰·伍登(John Wooden) “<strong>学习知识，只有融会贯通，才算真正学到手</strong>”，这句话的含义。我们帮助谷歌创始人和同仁们打造了一家令人称奇的企业，收获了第一手的经验。可以说，我们坐在第一排，目睹了“魔术师”的魔法。这颠覆了我们对管理的理解。现在，世界各地不同行业大大小小的企业和组织涌入硅谷，希望吸收让硅谷大放异彩的灵感与活力。人们渴望改变，而这本书就是为改变而写的：<strong>秉承着硅谷前辈的精神，我们希望将“魔术师的秘密”转化为人人皆可利用的经验，与大家分享</strong>。</p>

<p>本书的框架旨在反映一个成功的企业、新兴企业或新创企业的发展阶段，这个过程构成了一个自我永续的良性循环，就像从山上滚下来的雪球，体积越来越大，势能越来越猛。我们会分步骤介绍吸引和激励创意精英的方式，每一步骤都会推动企业向前迈进。这些步骤互为基础、相辅相成，每一个步骤都永远向前，永不衰竭。</p>

<p>在书的开头，我们会谈到如何吸引最顶尖的创意精英。我们首先从企业文化谈起，因为<strong>企业文化与企业的成败息息相关</strong>。如果连你自己都不信服自己的企业口号，那么你的企业又能走多远呢？此后，<strong>我们会谈及战略，因为最吸引创意精英的，莫过于有着强大战略基础的构想</strong>。创意精英明白，商业计划远远没有支撑计划的支柱重要。之后，<strong>会谈到人才招聘，这是领导者最为重要的一项职责</strong>。延揽足够的俊才，让他们碰撞融合，必能激发出创意与成果。</p>

<p>团队招募完毕，企业开始成长，就到了制定艰难决策的时候。这时，我们会谈到如何才能达成共识。接下来的一章中，我们会谈到沟通，随着企业的发展，沟通会变得越来越重要（也越发困难）。之后，我们会转到创新上。要想取得长久的成功，保持产品的高质量是不二法门。而要想在产品质量上获胜，打造让人受到创意熏陶的环境是关键。在本书结尾，我们谈了对当今主流企业的一些看法，并探讨了如何才能敢于想象不可想之事。</p>

<h3 id="section-9">待建的金字塔</h3>

<p>这些经验来之不易，其中许多经验都是我们两位作者在冗长的会议、激烈的辩论以及惨痛的失误中学来的。同时，能在互联网风靡全球之际有幸加入一家由杰出的创始人领航的企业，我们深感三生有幸。</p>

<p>在这个新兴行业中，科技至高无上，员工被充分授权，面貌焕然一新。我们两人对这个行业绝非无所不知，但可以说有深入了解。我们认为我俩的这些认识或许可以为各种组织的领导者提供一些灵感，无论是大企业还是创新公司，无论是非营利组织、非政府组织还是政府组织。我们最大的心愿，是通过本书带给你一次愉快的阅读体验，同时给你提供创新所需的灵感和工具。</p>

<p>我们所说的“你”，指的就是创业者。“你”就是你。<strong>或许，你不认为自己是个创业者，但实际上，你就是</strong>。你心中有一个你确信将改变一切的构想，这个构想或许是一个模型，或许已经演变成了一款产品的雏形。你聪明、野心勃勃，在会议室、车库、办公室、咖啡厅、公寓或宿舍中，你或者与一小撮同仁埋头苦干，或者孤军奋战。即便是在学习、上班或是陪伴伴侣或孩子的时候，<strong>你依然会走神，去考虑你的宏大构想</strong>。你的创新事业就要启动，而我们，希望助你前进。</p>

<p>我们所说的“事业”，并非仅仅指硅谷随处可见的高科技新兴企业。当今，员工希望从企业中获得的满足感与以前不可同日而语，但这种需求却往往得不到满足。本书提供了一个绝佳的机会，书中谈及的原则和方法适用于任何想要创业或创新的人，无论你是白手起家还是想在一家既有企业中实现突破。书中内容并不局限于初创企业，也绝不囿于高科技企业。实际上，如果经验丰富的领导者能够充分利用运营中的组织的一切资源，便会促使组织爆发出远大于初创企业的影响力。… 。你只要知道，你所处的行业的变革一日千里，你不仅要具备投身于这场变革的冒险精神，还要乐于且有能力吸引最顶尖的创意精英，领导他们助你完成伟业。</p>

<p>说的是你吗？准备好了吗？互联网时代到处都是尚未起建的金字塔。还等什么呢？开始动手吧！</p>

<hr />

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[RSA and Implemenation by Self in Python]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/03/rsa-and-implemenation-by-self-in-python/"/>
    <updated>2016-03-22T11:25:20+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/03/rsa-and-implemenation-by-self-in-python</id>
    <content type="html"><![CDATA[<p><a href="http://sahandsaba.com">Sahand saba</a> 的文章 <a href="http://sahandsaba.com/cryptography-rsa-part-1.html">Basics of Cryptography Part I: RSA Encryption and Decryption</a>描述了RSA算法在Python的实践。本文是自己理解，以及实践的过程。</p>

<h2 id="rsa">什么是RSA算法</h2>

<p>RSA可以是世界上最重要的加密算法，每个以https://开头的网址，都是采用基于RSA的安全传输协议。可以说，没有RSA，也就没有可靠安全的网络传输。互联网和Web也不会取得如此巨大的发展。</p>

<p>RSA是一种非对称加密算法，也就是加密的秘钥与解密的秘钥不同。公钥可以对外公布，信息用公钥加密，只有掌握私钥的一方才可解密。这就防止因加密的秘钥被盗，导致泄密的可能性。</p>

<p>RSA的名字来自三位发明者名字的首字母： <a href="https://en.wikipedia.org/wiki/Ron_Rivest">Ron Rivest</a>,  <a href="https://en.wikipedia.org/wiki/Adi_Shamir">Adi Shamir</a>, <a href="https://en.wikipedia.org/wiki/Leonard_Adleman">Leonard Adleman</a>。</p>

<p>RSA的安全性是基于极大数之因子分解极为困难，在目前的计算量上基本不可能。</p>

<h3 id="section">秘钥产生</h3>

<ol>
  <li>找到两个不同的极大素数 $p$, $q$。</li>
  <li>计算 $n = pq$, $n$作为公钥和私钥的模。它的长度，以比特位表示，就是秘钥的长度。</li>
  <li>计算 $\phi(n)=\phi(p)\phi(q)=(p-1)(q-1)=n-(p+q-1)$, $\phi$称为欧拉总计函数(<a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler’s totient function</a>)。此处计算的值要隐蔽起来。</li>
  <li>选择一个整数$e$, 使得 $1&lt;e&lt;\phi(n)$, 且$e$与$\phi(n)$互质，也就是以及 $gcd(e, \phi(n))=1$。<a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">gcd</a>是两数的最大公约数。</li>
  <li>确定$d$， $d=e^{-1}(mod\ \phi(n))$。或者说求解 $d$，使得$d{\cdot} e{\equiv}1 (mod\ \phi(n))$</li>
  <li>销毁$p,q,\phi(n)$的计算记录。</li>
  <li>私钥是$(n, d)$, 公钥是$(n,e)$。</li>
</ol>

<h3 id="section-1">加密</h3>
<p>假设Bob要讲信息$M$传给Alice。他首先按照某种字符集编码规则(比如Unicode)，将$M$转化为数字$m$，并通过padding scheme，使得$0\leq m \leq n$ 且 $gcd(m,n)=1$。如果文本过长，可以分成几块，分别加密。然后利用Alice的公钥$e$，计算每一块的密文：</p>

<script type="math/tex; mode=display"> c \equiv m^e mod\ n</script>

<p>然后将$c$传给Alice。</p>

<h3 id="section-2">解密</h3>
<p>Alice利用私钥$d$，从密文$c$中恢复出$m$，</p>

<script type="math/tex; mode=display"> c^d \equiv (m^e)^d \equiv m\ mod\ n</script>

<p>如果得到$m$，就可根据编码规则恢复原文$M$。</p>

<h3 id="section-3">举例</h3>

<h4 id="section-4">秘钥生成</h4>

<ol>
  <li>选择两个不同的质数，比如 $p=47$, $q=73$</li>
  <li>计算$n$,   $n=pq=3431$</li>
  <li>计算欧拉总计函数，$\phi(n) = \phi(p)\phi(q)=(p-1)(q-1)=3312$</li>
  <li>寻找$e$, 使得$1&lt;e&lt;\phi(n)$且$e$与3312互质的数。可以选定质数，然后只需验证其不是$\phi(n)$的余数即可。我们选择$e = 37$。</li>
  <li>通过简单地搜索(顺序搜索即可)，得到 $d = 3133$，使得 $(37\cdot 3133) \equiv 1 \ mod(3312)$</li>
  <li>私钥是$(n=3431, d=3133)$，公钥是$(n=3431, e=37)$</li>
</ol>

<h4 id="section-5">加密与解密</h4>

<p>被加密的数字为$m$, 加密函数则为：</p>

<p>$ E(m) = m^{37} mod\ 3431 $</p>

<p>设 $m=67$, 带入得 $c=1016$。</p>

<p>得密文$c$，解密函数为:</p>

<p>$ D(c) = c^{3133} mod \ 3431$</p>

<p>将$c=1016$带入，得$m=67$</p>

<h3 id="section-6">正确性的证明</h3>

<p>有两个方法来证明RSA算法，费马小定律(<a href="https://en.wikipedia.org/wiki/Fermat%27s_little_theorem">Fermat’s little theorem</a>)或欧拉定律(<a href="https://en.wikipedia.org/wiki/Euler%27s_theorem">Euler’s theorem</a>)。虽然RSA算法的作者们用费马小定律来证明，但费马小定律是欧拉定律的特例，用后者证明更为简洁。</p>

<p>我们需要证明 $m^{ed} \equiv m \ mod \ n$，这里 $n=pq$是两个不同的素数的乘积。而$e, d$是两个正整数，满足$ed \equiv 1 \ mod\  \phi(n)$。</p>

<p>证明如下：</p>

<p>既然$ed$是正整数，它总可以写成 $ed = 1 + h \phi(n)$, $h$为某个非负整数。假设$m$与$n$互质，我们有：</p>

<script type="math/tex; mode=display"> m^{ed} \equiv m^{1+h \phi(n)} \equiv m (m^{\phi(n)})^h \equiv m(1)^h \equiv  m \ mod\ n</script>

<p>倒数第二个全等来自<a href="https://en.wikipedia.org/wiki/Euler%27s_theorem">欧拉定律</a>。</p>

<h2 id="section-7">算法的实践</h2>

<p>如下我们将用Python来实现RSA密码系统。正如我们看到的，每个实现的片段都和数学及计算机科学中充分研究的领域相关。</p>

<h3 id="section-8">秘钥产生和素数检测</h3>

<p>作为开始，生成秘钥需要先产生两个素数$p$, $q$。我们上面已经注意到如何$n=pq$过于小，则入侵者会轻易将其分解，从而得到$\phi(n)$，进而计算出$d = e^{-1} mod\ \phi(n)$。密码就被破解了。因此，我们需要$n$，也就是$p$、$q$足够大。</p>

<p>为了得到大素数$p$，首先要确定素数所需的bits数。这是决定密码体系强度的关键参数。我们可以先看看<a href="https://www.baidu.com/">百度</a>和淘宝(https://www.taobao.com/)在它们安全TLS连接中所使用密钥的强度。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OpenSSL&gt; s_client -connect baidu.com:443
</span><span class="line">[...]
</span><span class="line">New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
</span><span class="line">Server public key is 2048 bit</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">OpenSSL&gt; s_client -connect taobao.com:443
</span><span class="line">[...]
</span><span class="line">New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES128-GCM-SHA256
</span><span class="line">Server public key is 2048 bit</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>都是2048bit的强度。</p>

<p>为了产生一个$b$比特的素数$p$，我们首先产生b比特位的随机数，然后手工地为头和尾加上“1”，确保此数大于 $2^{b-1}$（我们不想意外选中$3$，那怕概率有多小）且是奇数。让$t$代表前面随机比特位代表的数字，我们从$i=0$开始一直往上，检查 $t+i$是否为素数。只要遇到一个素数，我们就令它等于$p$。在进行一些尝试后，放弃一些区间，通常会比较好。为了行之有效，我们需要考虑素数定律(<a href="http://en.wikipedia.org/wiki/Prime_number_theorem">Prime Number Theorem</a>)，令$\pi(n)$代表小于或等于$n$的素数的个数，则：</p>

<script type="math/tex; mode=display">\lim_{n=1}^{\infty} \frac{\pi(n)}{\ln(n)}=1</script>

<p>换言之，对于正整数$n$，大约有$ln(n)$个等于小于$n$的素数。$n$越大，这个估算越准确。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[混沌通讯会议：一场很德国的黑客大会]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/03/chaos-communication-congress-a-very-german-hacking-conference/"/>
    <updated>2016-03-02T00:00:00+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/03/chaos-communication-congress-a-very-german-hacking-conference</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://motherboard.vice.com/read/chaos-communication-congress-a-very-german-hacking-conference">Chaos Communication Congress: A Very German Hacking Conference</a></p>

<p>译者：lifematrix[<a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#115;&#116;&#101;&#118;&#101;&#110;&#108;&#105;&#117;&#099;&#120;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">&#115;&#116;&#101;&#118;&#101;&#110;&#108;&#105;&#117;&#099;&#120;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;</a>]</p>

<p><strong><em>本译文是对Hardened Linux社区的贡献，已发表在<a href="http://hardenedlinux.org/translation/2016/03/02/chaos-communication-congress-a-very-german-hacking-conference.html">社区的博客</a>。</em></strong></p>

<hr />

<p>哑剧艺术家懒洋洋地躺在铺着地毯的楼梯上，几百张桌子，上面凌乱地堆满笔记本电脑，延伸到不同的几个大厅。一个穿得整整齐齐的人，脸朝下趴在一间侧屋的床垫上，昨晚一整夜疯狂地敲击键盘，已让他心力憔悴。</p>

<p>德国各地几十个混沌计算机俱乐部分会(<a href="https://www.ccc.de/de/club/erfas">Chaos Computer Club (CCC) chapters</a>)的成员，以及来自世界各地的与会者，屈尊到汉堡，喝着黑客汽水(<em>译注：<a href="https://motherboard.vice.com/blog/how-a-german-soda-became-hackers-fuel-of-choice">club-mate</a>, 含马黛的苏打饮料，称为<a href="http://www.douban.com/subject/24871269/">黑客汽水</a></em>)，进行为期四天的hacking、辩论和演讲。</p>

<p>这就是混沌通讯会议，CCC的年度艺术、政治和安全大会，由一千多强大的志愿大军操办。</p>

<center>***</center>

<p>“没人从中赚到一分钱”，大会前，Linus Neumann - CCC的一位发言人在柏林的一家咖啡馆告诉我。无论是录制发言的人，还是那些确保传媒未经本人允许不可将镜头对准其人的向导，还是经过训练能响应紧急事件的应急人员，或者负责衣帽间并在人们进入会场时检查他们腕带的伙计们，都没拿报酬。而且他们经常自己买票参加活动，以作支持。</p>

<p>Tim Privlove, CCC的一位资深成员，早期会议的组织者，不认为这只是为之工作而不拿报酬。</p>

<p>“这实际上不是为了免费。我实际上认为，你不能这么来看它：因为它不是工作，” 在最近的大会上他一边喝着咖啡一边说。“这是他们的活动：他们拥有它。这根植到他们的DNA，如果没有它，他们难以活下去。”</p>

<p><img src="../images/ccc-hacking-conference/CCC-hallway.jpg" alt="" /></p>
<center><small>CCC hallway. Photo: Joseph Cox</small></center>

<p>多年来，要部分感谢这一志愿者面向，让CCC已设法筹集到可观数目的资金。</p>

<p>“我不是要说，我们特别有钱了，而是说从财务的角度，我们舒心了，” Neemann说。“我们能承受彻底搞砸整个事情的财务风险，不会破产。”</p>

<p>“这钱就在那儿，因为每个人都发挥自己的作用：因为每个人都做志愿者工作，” 他说。</p>

<p>志愿者的想法，实际上是将大会区别于其它黑客会议的地方。而且，这是全盘多方面的策略。</p>

<p>在大会自己仓库风格的夜店里，DJ, 艺术家，黑客，技术者，积极分子和其他人，聚会一起去分享和讨论他们时代的话题，直到深夜。</p>

<p>“很多人第一次走进来时，他们很惊讶地看到，这里比他们所想的，更为包容，更为广义，” Pritlove说。</p>

<p>但是，有些人在混沌通讯大会里不特别受欢迎。</p>

<p>“一个供职于德国军方的人参加了CCC，大概不想告诉任何人，他们可能不愿出现在台面上，” Neumann说。</p>

<p>在黑帽，美国的一个主要黑客大会上，国家安全局长Keith Alexander发表了<a href="https://www.youtube.com/watch?v=4Sg4AtcW0LU">2013年的主题演讲</a>。</p>

<p>这显然，从来不会发生在混沌通讯大会上。</p>

<p>“当我离开时，会有这一天，” CCC的主席，被称为“dodger”，告诉我。“我们尽可能避开那些为情报业或类似事情工作的人。”</p>

<p>但是，当对待军方以外或情报机关时，灰色地带出现了。如果CCC发布一个总名单反对邀请供职于那些领域的人，“那么我们就不会有任何揭弊者，”比如爱德华·斯诺登，dodger说。</p>

<p>“这很难办。”</p>

<p>反军方的心态可以追溯到大会的历史，一个政治事件导致它的创立。</p>

<center>***</center>

<p>1981年，<a href="https://en.wikipedia.org/wiki/Wau_Holland">一个黑客和无线电爱好者</a>，名为Wau Hollan，以及一小群有相似想法的人，聚集在左翼报纸<em>Die Tageszeitung</em>的办公室，讨论数据、计算机，以及这些可能给大众带来的影响。</p>

<p>“Wau Holland是对社会有远见的人，” Neumann说。甚至远在80年代早期，当大部分人还没有电脑时，互联网还也没有出现，Holland和其他人就看到了这些网络的未来，如此令人兴奋、也令人担忧。</p>

<p>三年后，1984年，CCC宣布了第一次混动通讯大会，一个在汉堡定期举办的聚会。“大会的第一次呈现，规模相当小，大概200人，” Pritlove说。</p>

<p>尽管规模不大不小，但是84年的大会包含了所有与今天大会涉及的相同内容。Workshop, 演讲，以及一群人连续几天一直在笔记本电脑上hacking。</p>

<p>“相同的话题，相同的态度，相同的人，” Pritlove说。</p>

<p>CCC随之创建了一个“eingetragener Verein (e. V.)” (<em>译注: <a href="https://en.wikipedia.org/wiki/Eingetragener_Verein">e. V.</a>是在德国和奥地利合法的志愿者社团，有法人身份</em>)，实质上是一个合法组织，允许团体有财务权。</p>

<p>有个正式的实体也给团队一些合法性，当开展工作时受法律保护：事实上，hacking到银行系统或者电信网络，会很容易被执法机关解释为犯罪或不法活动。以一个e.V.运作，降低了受到任何干涉的风险。</p>

<p>“这只是随后被采纳的一个法律解释，为了不被视为恐怖组织，” Pritlove开玩笑说。“这是替代方法。”</p>

<p>在大会开始的同年，Wau Holland和另一个CCC成员Steffan Wernery，搞了一次’抢银行’。他们利用Bildschirmtext (BTX)的缺陷，这是由<a href="https://en.wikipedia.org/wiki/Deutsche_Bundespost">德国联邦邮政</a>和电话网络运营的计算机网络，掐掉13万5千德国马克(大概7万5千美元)，存到CCC拥有的银行账户上。</p>

<h3 id="section">我认为德国是尊重黑客的安全岛</h3>

<p>起初在网络背后的政府机构<a href="http://www.spiegel.de/einestages/btx-hack-1984-angriff-der-ccc-hacker-gegen-die-bundespost-a-1002443.html">忽略了提出的问题</a>。因此CCC将hack的细节分享给德国最大的一家广播公司，在媒体一番炒作之后，问题被修复了。最后CCC将现金返还。</p>

<p>“从一开始[CCC]就在做媒体博弈，” Pritlove补充说，“黑客在德国的印象立即成了罗宾汉之类的侠盗。”</p>

<p>其它高姿态的hack也为这一形象做出贡献。为了反对在护照中使用生物计量数据，<a href="http://www.wired.com/2008/03/hackers-publish/">小组发布了德国当时内政部长Wolfgang Schauble的指纹</a>；与荷兰一个公民组织一起, CCC揭露了德国使用计算机之后<a href="http://www.ccc.de/en/updates/2007/wahlcomputer-spenden">电子投票系统的缺陷</a>；2011年，小组逆向工程了<a href="http://www.wired.co.uk/news/archive/2011-10/12/german-state-spying-software">国家执法部门所用的强大恶意软件的片段</a>。</p>

<p>然后就在最近，作为对84年BTX hack的响应，德国新闻组Tagesschau报道了研究者的发现，欧洲支付终端被<a href="https://motherboard.vice.com/read/european-card-terminals-are-plagued-with-serious-vulnerabilities">严重的缺陷所困恼</a>。这些缺陷让入侵者得以将资金转到德国境内任意一个银行账户。</p>

<p>“因此在德国，黑客的形象与世界其它地方特别是美国，完全不同。在美国，黑客普遍与犯罪活动联系起来，” Pritlove说。CCC经常被要求到<a href="https://www.youtube.com/watch?v=Q4Z5Y8SLvic">一些政府听证会</a>作证，提供监管、IT立法和数据保留方面的专家证据，而不是象美国媒体经常报道黑客的那样，被看做一小撮计算机犯罪分子。</p>

<p>“我认为德国是黑客受到尊敬的安全岛”, dodger，CCC主席说。</p>

<p>但也曾有一些时刻，德国的hacking场面和俱乐部，本可能全部被摧毁。</p>

<center>***</center>

<p>一个与CCC有联系的黑客小组，由Karl Koch这个人领导，由于侵入美国计算机并<a href="https://en.wikipedia.org/wiki/Karl_Koch_(hacker)">将操作系统源代码卖给了当时苏联情报组织-克格勃(KGB)</a>而被捕。1989年，发现Koch被烧死在策勒附近的森林里，离他出生的汉诺威城不远。</p>

<p>整个事件“威胁到要终结CCC，” Neumann说 - 严重损害他们所代表的黑客形象。</p>

<p><img src="http://hack.the-lifematrix.net/images/ccc-hacking-conference/CCC-hackerspace.jpg" alt="" /></p>
<center><small>CCC hackerspace. Photo: Joseph Cox</small></center>

<p>Pritlove解释说，大会在汉堡和柏林之间迁移了数次。1989年柏林墙倒塌，让首都成为一个“疯狂”的地方，聚会当时在柏林举办，Pritlove说，“在那儿，每个社会的小组织都莫名其妙地足够壮大而能维持。”</p>

<p>然后到了90年代后期，大会发展巨快，大概超过以往任何时候。Pritlove说，“终于hacking成为很酷的事情，每个年轻人都有自己的电脑。”</p>

<p>“’万维网’(world wide web)，’赛博空间’，每件事都完全让人兴奋，” 他补充到，“千禧年来临，未来终将在这里！”</p>

<p>在整个过程中，一个持续不断的政治脉络贯穿着CCC和大会的发展。从左翼报纸Die Tageszeitung的办公室，到柏林和汉堡的反资本主义占屋，直到今天一个<a href="http://www.theguardian.com/technology/2015/dec/29/hamburg-chaos-hacker-conference-refugee-keynote">索马里难民在大会主讲台发表主题演讲</a>，政治在塑造俱乐部及其行动中扮演了至关重要的角色。</p>

<p>其它的政治对话，包括年度国家<a href="https://events.ccc.de/congress/2015/Fahrplan/events/7307.html">洋葱会话</a>，对去年Tor匿名网络的概述，以及<a href="https://events.ccc.de/congress/2015/Fahrplan/events/7374.html">讨论监管系统对我们城市的影响</a>。</p>

<p>“我们在80年代告诉他们的，如今正在发生，” dogger说。</p>

<p>“就大会和政治，你不能将它们分开”， Pritlove说。这三人都同意，CCC的政治血统追溯起来要比其创立早得多：有人将它基本上看作后二战反应，Pritlove也提到，涌现于70年代<a href="https://en.wikipedia.org/wiki/Red_Army_Faction">激进左翼的政治运动</a>。</p>

<p>解决方法办法是“我们不需要阻止它。我们需要找到不同的途径，我们通过进入权力机构来开始征途。我们需要具有建设性。我们需要走入那些我们所批判的决策中，而非仅仅置身事外，然后一直扔燃烧弹，并杀人。”</p>

<p>进入权力机构的做法已经受到欢迎。2015年11月，德国内政部长<a href="http://www.faz.net/aktuell/wirtschaft/netzwirtschaft/it-gipfel-ich-braeuchte-von-ihnen-mal-eine-krisennummer-13921103.html">公开声明</a>，如果一个大规模的互联网相关或赛博事件发生，他将会求助于CCC。</p>

<h3 id="section-1">“如今整个活动就是一个操作系统”</h3>

<p>在00后中期以前，大会很大程度上是与世隔绝的事件。虽然它也吸引德国各地及欧洲的黑客，但在这之外的黑客们大部分并不关注。</p>

<p>因此，Pritlove告诉我，CCC开始接触到在美国的联系人，邀请他们来发表演讲。</p>

<p>“他们回去后，告诉其朋友们所有关于大会的情况。下一年，有20个人来，再下一年，有更多的人来，” Pritlove说。</p>

<p>美国人显然很吃惊。“在美国的黑客大会，到处是警察，商人，情报机构，充满了怀疑，” Pritlove继续说，“很多都是为了赚钱。”</p>

<p><img src="http://hack.the-lifematrix.net/images/ccc-hacking-conference/3D-printers.jpg" alt="" /></p>
<center><small>3D printers. Photo: Joseph Cox</small></center>

<p>但是，CCC的大会，“是完全的自由，[美国人]还处在乔治·布什时代(<em>译注：911事件的时期</em>)，对黑客充满了害怕、恐怖和压制。”</p>

<p>“两周后他们都回去了，他们在旧金山、华盛顿、纽约建立了黑客空间。一年后，美国各地都诞生了新的黑客空间”， Pritlove说。“我想，可以公平地说，<a href="http://www.wired.com/2007/08/us-hackers-moun/">点燃这些的火种</a>确实来自这里，来自这里的场景。”</p>

<p>军方与德国hacking场面的距离，在这里极不同于在美国那样密切。</p>

<p>“基本上，在美国任何IT安全领域的人，迟早都会成为国防部的某类承包商或者进入这一领域，否则不可能走太远。” Neumann说。“因为那里有资金，有趣的工作，你能做出好玩的东西。”</p>

<p>他也指出Roger Dingledine，Tor项目的联合创始人和研究总监，<a href="http://www.scrible.com/contentview/page/MKQ81904HKLO822Q14O5K2R8CGA42GA6:77893486/index.html?utm_source=tb_permalink&amp;utm_medium=permalink&amp;utm_campaign=tb_buttons&amp;_sti=1423988">他为好几份军方资助的合同工作</a>。(Tor项目如今试图让<a href="http://www.theverge.com/2015/11/24/9793232/tor-project-donate-crowdfund">资金多元化</a>，特别是减少对美国政府资金的依赖。)</p>

<p>在德国，相反，却没有这样的合同商、军工联合体，或任何与美国类似程度的情况。</p>

<p>这里没有“那么多钱，以及那么多军方的国家荣誉。” Neumann说。因此，在德国绽放的黑客很可能迈向其它方向：CCC，而非美国那样的路径。“我们有大多数的研究者”，Neumann补充说。</p>

<center>***</center>

<p>今年，大会接待了<a href="https://en.wikipedia.org/wiki/Chaos_Communication_Congress">超过一万三千名参会者</a>，已经变成由各种自制网络和基础设施组成了盘旋复杂的奇妙装置。</p>

<p>当参会者鱼贯进入会场时，扫描入场券以及付款台的计算机都其自己的软件。专门有个后勤系统用于在酒吧里管理黑客汽水瓶子的库存，并将空瓶子拿走。“丝绸之路”送递系统-由管道组成了网络在大楼各个房间里迂回穿行 -允许黑客在大会各个中心之间传送物件。</p>

<p>多通路、高带宽的上行链路给参会者提供了极其快速的网络连接；一个全功能的GSM移动电话网络允许每个人摆弄到深夜时能够联系上他们的朋友。</p>

<p>甚至视频摄制组，他们负责录制、实况直播以及用高清格式归档谈话，也使用他们自己的相机、装备，间或软件。</p>

<p>“我要说，这甚至超过了专业标准，因为你实在买不到这样的服务,” Pritlove说。“如今整个活动就是个操作系统。”</p>

<p>开源的属性自然反映在与会者自己对设备的选择上: 在“基础设施回顾”中，负责大会基干设施的小组做了<a href="https://www.youtube.com/watch?v=NwX-ylkxDOY">一小时的展示</a>，发言者宣布，Linux是迄今最受欢迎的操作系统族群，大会里大约四分之一的计算机都使用了Liunx。(“这是Linux胜利的时刻，”演讲者说，听众们接着就欢呼鼓掌。)</p>

<p>“的确有些公司可能举办这样的活动，” 在基础设施回顾中一位发言者说，他投放了一张有各种组织的幻灯片。今年，那些公司包括中国公司华为，德国电信(德国最大的互联网服务提供商)，其它就这十几个。</p>

<p>“我们遇到一点点问题；你不可能运作一个这样的会议而不需要从大公司借东西,” dodger说。“你需要获得硬件。你不能购买那些硬件，并持有它们；这不可能。”事实上，在这样规模的大会，要提供几千人的互通互联，大概没人拥有这些的硬件和基础设施来实现它，因此确实需要赞助者介入。</p>

<p>但这并不需象其它大会那样，通过提供装备，巨头公司们开始将他们的商标贴满了交易所，希望获得一些新客户。</p>

<p>“我们试图寻找合作伙伴借给我们硬件，我们也试图不要只有一个主赞助商。我们不允许在大会上打横幅或做广告，” dodger告诉我。相反，反法西斯和支持难民的旗帜淹没了会议大厅。“硬件赞助商将他们的Logo放在CCC网站上，没有Google索引等等。这就是他们的所得。”</p>

<p>CCC与大型机构的联系，通常是因为有个成员为其中之一工作，Neumann说。</p>

<p>“当然我们有人在NXP供职,” 他对我说，提到一个大型的<a href="http://www.nxp.com/applications/smart-connected-solutions:SMART-CONNECTED-SOLUTIONS">计算机网络公司</a>。“如果我们想与NXP安全分部的负责人交谈，我有他的号码，我直接给他打电话。” 这些关系已经在过去30年里发展起来了，也是人们通常职业生活的一部分。“</p>

<p><img src="http://hack.the-lifematrix.net/images/ccc-hacking-conference/pinball.jpg" alt="" /></p>
<center><small>Pinball. Photo: Joseph Cox</small></center>

<p>但是，大会真正的脊梁不是数字化的基础设施或计算机硬件，而是无偿在会议中工作的志愿大军。</p>

<p>“你需要大约1000人来照顾所有杂七杂八的事，” Neumann告诉我。</p>

<p>大部分这样的志愿者，被称为天使：是让系统甚至在密集的使用下，稳定运行四天的个人。(第一天刚到大会的20分钟里，一位天使要我把一些外套衣架从一个房间挪到另一个。自然地，我施以援手，尽管只微薄之力)。</p>

<p>志愿者文化是大会如此亲密地嫁接到德国的众多原因之一。但是，它也与一个国家独特的历史和政治传统相关联。</p>

<p>Neumann说象大会这样的事物，也许能在德国之外存在，但可能有困难：让一千多人齐心协力连续数天或数周工作，所需的后勤挑战，想象在其它地方并非易事。</p>

<p>当问到Pritlove大会是否能存在德国之外时，他一声长叹。</p>

<p>“这是很德国的事”，他说。“我不知道。”</p>

<p>Topics: hacking, Chaos Communication Congress, CCC, germany, black hat, politics, white hat, Club Mate, volunteerism, features</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Face Analysis]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/02/face-analysis/"/>
    <updated>2016-02-25T11:49:52+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/02/face-analysis</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CIFAR-10 on Tensorflow]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/02/cifar10-on-tensorflow/"/>
    <updated>2016-02-18T16:39:12+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/02/cifar10-on-tensorflow</id>
    <content type="html"><![CDATA[<h2 id="cifar-10-">CIFAR-10 数据集</h2>

<p><a href="http://www.cs.toronto.edu/~kriz/cifar.html">CIFAR-10和CIFAR-100</a>是对象识别的基准数据集。它们是从<a href="http://groups.csail.mit.edu/vision/TinyImages/">8000万微型图片数据集</a>选取的子集。CIFAR-10中包含60000张32x32的彩色图片，分为10类，即每类有6000张。其中50000张作为训练集，另10000张为训练集。</p>

<p>这10类分别是：airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck，示例如下：</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/cifar10_sample.png" alt="" /></p>

<p>这类是互斥的，也即：每个图片唯一属于某类。</p>

<p>而CIFAR-100数据集和CIFAR-10类似，但是分为100个类。这100个类又属于20个父类。</p>

<h2 id="tensorflow">Tensorflow</h2>

<p><a href="www.tensorflow.org">Tensorflow</a>是google去年年底刚刚公开的深度学习计算框架。虽然在一些比较中(<a href="http://fastml.com/what-you-wanted-to-know-about-tensorflow/">fastml</a>, <a href="https://github.com/soumith/convnet-benchmarks/issues/66">soumith</a>, <a href="http://chenrudan.github.io/blog/2015/11/18/comparethreeopenlib.html">陈汝丹</a>)，tensorflow的计算速度比caffe等要慢很大。但是tensorflow的优势，如其<a href="http://download.tensorflow.org/paper/whitepaper2015.pdf">白皮书</a>所言，在于其架构。它提供了跨域异构计算资源(从移动设备、单机到多GPU集群…)的一致性计算平台，其抽象能力和扩展性极其优越，极大降低开发、运行和维护的成本。Google对计算架构的理解和设计有超乎寻常的远见，比如Google的三驾马车GFS、Map-Reduce、BigTable开启了大数据计算框架之先河。所以tensorflow计算慢的问题，相信其设计者应该意识到的，今后或许有改进。总之，值得对tensorflow做些探索和学习。</p>

<p>虽然tensforflow的文档还不够丰富，但它的确提供了采用cifar-10数据集的<a href="https://www.tensorflow.org/versions/r0.7/tutorials/deep_cnn/index.html">示例程序</a>。也许，为了充分说明tensorflow的各种特色：并发性、多GPU处理等，所以，这个代码结构对于初学者过于复杂，而且模型的构造淹没在很多代码细节中，不够清晰。因此，笔者决定自己探索实现一个程序。</p>

<h2 id="section">基本模型</h2>

<p>UC Berkeley <a href="http://caffe.berkeleyvision.org">Caffe</a>计算框架中，用配置文件的方式来定义模型，独立于代码，因此模型的定义很清晰也易于调整。本文就选择了其中的<a href="https://github.com/BVLC/caffe/blob/master/examples/cifar10/cifar10_quick.prototxt">快速示例</a>，作为基本模型，再逐步调优。</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/cifar10_model_basic.png" alt="" width="400px" /></p>

<p>由于训练集数据不算大(几百兆)，可以一次性全部读入内存，以下测试时给出的运行时间，就不包含读取图片的时间。</p>

<p>基本模型的运行情况(batchsize=100)：</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/time_basic.png" alt="" /></p>

<p>最大正确校验正确率：73.08%，在epoch=30, 训练100分钟时达到。之后更多的训练没有提高正确率。</p>

<h3 id="random-crop">Random Crop</h3>

<p>深度网络的参数巨大，很容易出现过拟合。通过人为扩大训练集数据(<a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">ImageNet</a>)，是避免过拟合的有效策略。先尝试简单的方法，在32x32的图片中，随机裁剪出28x28的图片，进行训练。这也就是将训练集扩大了4x4=16倍。</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/time_randomcrop.png" alt="" /></p>

<p>最大正确校验正确率：74.58%，在epoch=56, 训练137分钟时达到。之后更多的训练没有提高正确率。</p>

<p>正确性叫基本模型提高了1.5个百分点，效果明显。</p>

<h3 id="dropout">Dropout</h3>

<p>Dropout也是一种变相的调整策略，避免过拟合(<a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">ImageNet</a>)。要注意的是，在训练是采用dropout(keep_prob=0.5), 但是在validation时则不选用(keep_prob=1.0)。</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/time_dropout.png" alt="" /></p>

<p>最大正确校验正确率：76.22%，在epoch=103, 训练260分钟时达到。之后更多的训练没有提高正确率。
又提高了1.64%个百分点。可见有明显的效果。</p>

<p>在<a href="https://www.kaggle.com/c/cifar-10">Kaggle的cifar10竞赛</a>中得分为：74.59%。</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/kaggle_dropout.png" alt="" /></p>

<h3 id="section-1">内存使用分析</h3>

<p>受<a href="http://cs231n.github.io/convolutional-networks/">此文</a>对<a href="http://www.robots.ox.ac.uk/%7Evgg/research/very_deep/">VGGNet</a>分析的启发，也对本例的简单模型做类似分析。注意，由于采用了crop，则较前图的基本模型，图片输入为28*28像素。后面的数据维度也相应调整。</p>

<table>
  <thead>
    <tr>
      <th>Layer</th>
      <th>Data Shape</th>
      <th>Data Memory</th>
      <th>Weights</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Input Layer</td>
      <td>28*28@3</td>
      <td>9K</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Conv-1 (5x5@32)</td>
      <td>28*28@32</td>
      <td>98K</td>
      <td>5<em>5</em>3*32+32 = 2,432</td>
    </tr>
    <tr>
      <td>MaxPool-1</td>
      <td>14*14@32</td>
      <td>25K</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Conv-2 (5x5@32)</td>
      <td>14*14@32</td>
      <td>25K</td>
      <td>5<em>5</em>32*32+32 = 25,632</td>
    </tr>
    <tr>
      <td>AvgPool-2</td>
      <td>7*7@32</td>
      <td>6K</td>
      <td>0</td>
    </tr>
    <tr>
      <td>Conv-3 (5x5@64)</td>
      <td>7*7@64</td>
      <td>12K</td>
      <td>5<em>5</em>32*64 = 51,200</td>
    </tr>
    <tr>
      <td>Relu-3</td>
      <td>7*7@64</td>
      <td>12K</td>
      <td>0</td>
    </tr>
    <tr>
      <td>AvgPool-3</td>
      <td>4*4@64</td>
      <td>4K</td>
      <td>0</td>
    </tr>
    <tr>
      <td>FC Layer-4</td>
      <td>64</td>
      <td> </td>
      <td>1024*64 + 64 = 65,600</td>
    </tr>
    <tr>
      <td>FC Layer-5</td>
      <td>10</td>
      <td> </td>
      <td>64*10 + 10 = 640</td>
    </tr>
  </tbody>
</table>

<p>*注：每个数字用float32存储，占4个字节。卷积网络的一个特点就是，数据类型的精度对训练结果影响不大。参见: <a href="http://arxiv.org/abs/1502.02551">Deep Learning with Limited Numerical Precision</a>, <a href="https://www.cs.toronto.edu/~kriz/learning-features-2009-TR.pdf">Learning Multiple Layers of Features from Tiny Images</a></p>

<p>每个实例的数据，需要内存191K。共有142K(145,504)个参数，需要内存142K*4=568K。</p>

<p>假设GPU内存有4G，一次性处理的最大batchsize:
 (4G - 568K) / 191K = 21956</p>

<h3 id="section-2">时间分析</h3>

<p>花了4个小时才训练出最优的模型，一方面是算法问题，也与tensorflow固有的较低的计算速度有关。</p>

<h3 id="batchsize">Batchsize</h3>

<p>如果batchsize=1000, 明显看出学习速度明显下降。花费近8个小时，训练的最好模型的校验正确率为72.10%。</p>

<p><img src="http://hack.the-lifematrix.net/images/cifar10-tf/batchsize1000.png" alt="" /></p>

<p>如果batchsize=200, 学习速率也有些慢。花费4个小时，达到最高的校验正确率75.82%。但学习过程似乎不够稳定。
<img src="http://hack.the-lifematrix.net/images/cifar10-tf/batchsize200.png" alt="" /></p>

<p>或许要调整一下学习率</p>

<h2 id="section-3">更深的网络</h2>

<p>上述基本网络只用了3个卷积层，达到75%的正确率，换言之25%的错误率。结果不是很出色，<a href="https://github.com/nagadomi/kaggle-cifar10-torch7">Torch 7 ConvNet</a> 取得了7%的错误率。决定在tensorflow下实验此模型。结果，请见后文。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《指数型组织》中提到的网站]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/01/value-websites-in-book-exponential-organization/"/>
    <updated>2016-01-18T10:36:22+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/01/value-websites-in-book-exponential-organization</id>
    <content type="html"><![CDATA[<p>《指数型组织》讲述了伴随信息技术的发展，一种新的组织形式开始浮现。这种组织指数化技术，利用较少的资源投入，实现了业务的指数级增长。比如Google, Facebook, 包括中国的微信等，都是范例。此书也提供了大量与指数化技术相关的工具、案例、社群等，极富参考价值。在本书引用了大量的案例，以及相关的工具。如下进行了整理。</p>

<h3 id="httpsingularityuorg"><a href="http://singularityu.org">奇点大学</a></h3>

<p>关注那些搭着摩尔定律的快车以指数级增长的领域，包括无限计算能力、传感器、网络、人工智能、机器人学、数字制造、合成生物学、数字医学和纳米材料。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/singularity-university.jpg" alt="http://singularityu.org" /></p>

<h3 id="vicarioushttpwwwvicariouscom"><a href="http://www.vicarious.com">Vicarious</a></h3>

<p>深度学习方面的创业公司，Jeff Bezos(Amazon CEO), Mark Zuckerberg(Facebook 创始人)等的投资。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/vicarious.jpg" alt="http://www.vicarious.com" /></p>

<h2 id="section">设计众包</h2>

<h3 id="designshttp99designscom"><a href="http://99designs.com/">99Designs</a></h3>

<p>在线设计的众包公司。设计种类包括：Logo, Web&amp;移动APP， 商业广告，衣服(T-shirt…)，包装，书籍和杂志。不满意可以退款。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/99designs.png" alt="http://99designs.com" /></p>

<h3 id="quirkyhttpswwwquirkycom"><a href="https://www.quirky.com">Quirky</a></h3>

<p>社区公司，通过社区协作快速、低成本地实现各种创意发明，不同于传统的产品开发流程。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/quirky.png" alt="https://www.quirky.com" /></p>

<h3 id="section-1">其它</h3>

<p>IdeaScale, eYeka, Spigit, InnoCentive, SolutionXchange, Crowdtap, Brightidea.</p>

<h2 id="section-2">人力众包</h2>

<h3 id="taskrabbithttpsapitaskrabbitcom"><a href="https://api.taskrabbit.com">Taskrabbit</a></h3>

<p>Taskrabbit是线上和移动端的市场，允许人们将小的外包给附近的人。它的缘起是因为创始人Leah Busque没有时间去买狗粮。其理念是“邻里帮助邻里”(neighbors help neighbors)。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/taskrabbit.png" alt="https://api.taskrabbit.com" /></p>

<h3 id="elanceupworkhttpswwwelancecom"><a href="https://www.elance.com">Elance/Upwork</a></h3>

<p>在线员工平台，自由职业者的人才市场。Elance已经合并到UpWork。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/elance.png" alt="https://www.elance.com" /></p>

<h3 id="gigwalkhttpwwwgigwalkcom"><a href="http://www.gigwalk.com">Gigwalk</a></h3>

<p>移动众包平台，分布式工作管理。在任何时间、地点，将对的工作分配给对的人。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/gigwalk.png" alt="http://www.gigwalk.com" /></p>

<h2 id="section-3">众筹</h2>

<h3 id="indiegogohttpswwwindiegogocom"><a href="https://www.indiegogo.com">Indiegogo</a></h3>

<p>全世界规模最大的众筹和融资网站</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/indiegogo.png" alt="https://www.indiegogo.com" /></p>

<h3 id="kickstarterhttpswwwkickstartercom"><a href="https://www.kickstarter.com">Kickstarter</a></h3>

<p>社区公司，面对公众为各种创意筹集小额资金。覆盖各种创意：服装、艺术、漫画、舞蹈、游戏、美食…</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/kickstarter.png" alt="https://www.kickstarter.com" /></p>

<h2 id="section-4">团队协作/项目管理工具</h2>

<h3 id="yammerhttpswwwyammercom"><a href="https://www.yammer.com">Yammer</a></h3>

<p>企业社交网络
<img src="http://hack.the-lifematrix.net/images/exo/yammer.png" alt="https://www.yammer.com" /></p>

<h3 id="asanahttpsasanacom"><a href="https://asana.com">Asana</a></h3>

<p>网络和移动应用，改善团队交流和协作。
<img src="http://hack.the-lifematrix.net/images/exo/asana.png" alt="https://asana.com" /></p>

<h3 id="trellohttpstrellocom"><a href="https://trello.com">Trello</a></h3>

<p>Trello是一款项目管理工具，让协作更加容易和有趣。主要采用“列表的列表”方式，借鉴丰田的看板管理。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/trello.png" alt="https://trello.com" /></p>

<h3 id="konahttpswwwkonacom"><a href="https://www.kona.com">kona</a></h3>

<p>项目管理工具，提供文件共享。
<img src="http://hack.the-lifematrix.net/images/exo/kona.png" alt="https://www.kona.com" /></p>

<h3 id="redboothhttpsredboothcom"><a href="https://redbooth.com">Redbooth</a></h3>

<p>项目管理工具，可与印象笔记商业版结合。
<img src="http://hack.the-lifematrix.net/images/exo/redbooth.png" alt="https://redbooth.com" /></p>

<h2 id="section-5">社会协作</h2>

<h3 id="wazehttpswwwwazecomzh"><a href="https://www.waze.com/zh">Waze/位智</a></h3>

<p>社区化交通信息分享</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/waze.png" alt="https://www.waze.com/zh" /></p>

<h3 id="yelp">Yelp</h3>

<h3 id="foursquare">Foursquare</h3>

<h3 id="donor-choose">Donor Choose</h3>

<h2 id="section-6">无人机</h2>
<p>### <a href="http://diydrones.com">DIY DRONES</a></p>

<p>无人机社区</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/diydrones.png" alt="http://diydrones.com" /></p>

<h2 id="d">3D打印</h2>

<h3 id="d-systemshttpwww3dsystemscom"><a href="http://www.3dsystems.com">3D Systems</a></h3>

<p><img src="http://hack.the-lifematrix.net/images/exo/3dsystems.png" alt="http://www.3dsystems.com" /></p>

<h3 id="makielabshttpsmymakiecom"><a href="https://mymakie.com">Makielabs</a></h3>

<p>世界第一家利用3D打印的玩具制造者。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/makielabs.png" alt="https://mymakie.com" /></p>

<h2 id="section-7">机器人</h2>

<h3 id="irobothttpwwwirobotcom"><a href="http://www.irobot.com">iRobot</a></h3>

<p>一家机器人公司，设计和制造军用、商用、医疗和民用机器人，并以家用自动吸尘机器人Roomba最为著名。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/iRobot.png" alt="http://www.irobot.com" /></p>

<h2 id="section-8">其它指数型公司</h2>
<p>### Spotify
<a href="https://www.spotify.com/">https://www.spotify.com/</a></p>

<p>一家音乐串流公司。</p>

<p><img src="http://hack.the-lifematrix.net/images/exo/spotify.jpg" alt="" /></p>

<h3 id="valve">Valve</h3>
<p>去中心化</p>

<h2 id="books">Books</h2>

<p>*《超级天使投资：捕捉未来商业机会的行动指南》 (Angel Investing: The Gust Guide to Making Money and Having Fun Investing in Startups)</p>

<p>*至关重要的关系(The startup of You)</p>

<p>*《每周工作四小时》(4-Hour Workweek)</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ssh登录避免输入密码]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/01/ssh-login-without-password/"/>
    <updated>2016-01-15T11:43:30+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/01/ssh-login-without-password</id>
    <content type="html"><![CDATA[<p>ssh远程登录采用密码认证的方式，存在泄漏可能，而且比较麻烦。可以通过公私钥的方式，实现安全的无密码登录。</p>

<h3 id="section">本地主机</h3>
<ol>
  <li>生成本地的密码</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ssh-keygen -t rsa</span></code></pre></td></tr></table></div></figure></notextile></div>

<ol>
  <li>修改密码文件的属性</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line"> chmod 700 ~/.ssh  
</span><span class="line"> chmod 600 ~/.ssh/id_rsa </span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">远程主机</h3>

<ol>
  <li>
    <p>将本地的公钥添加到远程主机用户 <strong>$HOME/.ssh/authorized_keys</strong> 文件中</p>
  </li>
  <li>
    <p>如果是root用户登录，查看远程主机的ssh设置</p>
  </li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo vi /etc/ssh/sshd_config</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>确认 <strong>PermitRootLogin without-password</strong>，这样只允许公钥方式登录，也可以是<strong>yes</strong>。</p>

<ol>
  <li>重启ssh服务</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">sudo service ssh reload</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>以上在 Ubuntu 14.04.3 LTS 适用。其它Linux变体类似。</p>

<h3 id="section-2">参考</h3>

<p><a href="http://in4ray.blogspot.sg/2012/05/root-login-to-amazon-ec2-linux-instance.html">http://in4ray.blogspot.sg/2012/05/root-login-to-amazon-ec2-linux-instance.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为git设置sock代理]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2016/01/git-sock-proxy/"/>
    <updated>2016-01-15T11:01:42+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2016/01/git-sock-proxy</id>
    <content type="html"><![CDATA[<p>访问<a href="github.com">github</a>, <a href="http://bitbucket.org">bitbucket</a> 或 <a href="https://chromium.googlesource.com">google git</a> 等源码库会被阻塞，配置VPN经常不稳定。我喜欢用sock proxy，简洁快速。</p>

<h2 id="sshsocks-proxy">通过SSH隧道建立SOCKS Proxy</h2>

<p>假设本地的绑定端口是<strong>1080</strong>，用户user已经可以不用密码登陆远程主机remote.host。执行命令：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">ssh -nN -D 1089 user@remote.host</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>-D 指绑定端口为1080。</p>

<p>-N 指出不要执行远程命令，只做端口转发。</p>

<p>-n 将从/dev/null中读入，这在后台执行时有用。</p>

<p><em>上述参数在MAC OS下有效，其它Linux变种应也类似，man ssh 确认一下</em></p>

<h2 id="git">配置git</h2>

<p>配置http，及https代理</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git config --global http.proxy socks5://localhost:1080</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git config --global https.proxy socks5://localhost:1080</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="section">参考</h2>

<p>上述方法参考：</p>

<ul>
  <li>
    <p><a href="http://cms-sw.github.io/tutorial-proxy.html">http://cms-sw.github.io/tutorial-proxy.html</a></p>
  </li>
  <li>
    <p><a href="http://stackoverflow.com/questions/15227130/using-a-socks-proxy-with-git-for-the-http-transport">http://stackoverflow.com/questions/15227130/using-a-socks-proxy-with-git-for-the-http-transport</a></p>
  </li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[电子商务的下一步？]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/10/the-revolution-of-commerce/"/>
    <updated>2015-10-28T17:07:29+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/10/the-revolution-of-commerce</id>
    <content type="html"><![CDATA[<h3 id="section">进化的观点</h3>

<p>在商业和技术界，任何目前看来是革命或创新的东西，如果站在历史的角度，也只是进化历程中某阶段性的成就。采用“进化”的观点，是因为无论作为个人还是群体，其经验和认知总有局限性，我们只了解这个世界的局部真相，只能在我们认知的范围内做出尽可能优化的判断、决策以及随后的行动。随着经验的积累和认知的扩大，能看到更大范围的真相，我们会对从前的认知进行修正，这样一步步趋于优化。</p>

<p>比如商业形式的进化，从最早的自给自足的“小农经济”，到物物交换的简单形式。然后货币出现，以货币作为度量标准，商品有了交换的“价格”。接着，有了专门制造商品的手艺人和小工业者，慢慢多个合伙人组成商业机构，接着出现股份公司，而后是有限责任公司…。现在，由于资本市场的成熟，还有股票期权，员工持股。最近还有众筹等。</p>

<p>电子商务，伴随互联网技术的兴起，已经成为很多人的购物方式和生活方式。同时也成就了象阿里巴巴、京东、亚马逊等这样的巨型公司。但是，目前电子商务的模式会一直延续吗？下一步或者进化的方向是什么？</p>

<h3 id="section-1">商业的实质</h3>

<p>为什么会出现商业？亚当斯密斯在《国富论》中已经给出了清晰的解释。因为每个人无法独自满足自己所有的需求，或者每个人不可能擅长做所有的事情。这样，通过交换，每个人都能从别处获得自己不能提供的、或更好的东西。每个人专注自己擅长的事情，这样效率最高，然后拿自己的产品或服务与别人交换，如此增加了社会的共同财富，达到整个社会更大的繁荣和丰盛。</p>

<p>那么高效的商业体系，要做到三个基本点：</p>

<ul>
  <li>
    <p>创造
供应者能够创造出满足需要、打动人心的产品<em>(注：服务简称产品，以下同)</em>。</p>
  </li>
  <li>
    <p>分享
产品以合适的方式让消费者或潜在用户了解到，产生购买的愿望。</p>
  </li>
  <li>
    <p>交换
有便捷的方式完整支付、配送和售后服务支持。</p>
  </li>
</ul>

<h3 id="section-2">目前电子商务已解决和未解决的</h3>

<p>目前，电子商务更多解决的是“交换”问题。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[由TEX想到的]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/10/talk-about-tex/"/>
    <updated>2015-10-15T11:02:49+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/10/talk-about-tex</id>
    <content type="html"><![CDATA[<p>IT技术的飞速发展、不断升级换代，一方面的确给这个行业带来极大的活力和机会，但也给业者带来知识老化和智力投资过时的困惑。</p>

<p>但是，我们的确看到有很多成功的软件产品，它们跨越了技术快速发展的短周期，而在相当长的时间跨度下，保持产品的稳定和不断演进，并与新技术共舞，不断完善自己，变得更为完美。例如TEX，计算机科学家Donald Knuth于1970年代研发出的数学排版软件。他的初衷是发现自己撰写的论文在数学期刊印刷出来后，不够美观，而且当时没有很好的计算机排版软件，于是就自己着手研究开发。TEX及其扩展LaTex，至今仍被广泛地应用在专业期刊和书籍的出版，并作为插件被几乎被所有包含数学公式的网页和文档所采用。</p>

<p>作者自己十多年数学研究生时，使用LaTex撰写学位论文。当时积累有关LaTex的知识和经验，现在仍然可以用到。所以倍感亲切，知识没有老化和浪费。</p>

<p>《黑客与画家》的作者Paul Graham，在介绍为什么学习Lisp时，讲到通过定义针对应用域的语言，来达到高复用性，并将TEX作为典范。TEX提供了易学、清晰、可读性高的排版语言，让作者在撰写的过程中，就完成了排版，避免了反复沟通和校对的过程。</p>

<p>Knuth 在文章<a href="http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.bams/1183544082">Mathematical Typography</a>中讲到了他的思路。</p>

<pre><code>数学书籍和期刊没有它们以往看起来那样好看。这不是因为它们的内容不
够好，而是因为过去且良好排版的传统过于昂贵。幸运地是，现在看来数
学本身可以用来解决这个问题。

方案的第一步是设计方法来清晰地表达数学手稿，让它们能容易地被机器
操作。这样的语言，如果恰当设计，作者及其打字员能很快学习，而且这
个手稿能为印刷机直接产生高质量的印版，几乎不需要人工介入。

方案的第二步是利用经典数学来设计字体和符号的形状。例如，它能够给出
字母“a"准确形状的严格定义，使得通过改变单一定义中的少数几个参数，
能够得到无限多的风格(黑体、扩展、衬线、斜体等等)。当类似的方法用到
其它字母和符号时，我们得到了字体的数学定义，一个可以在今天和未来的
计算机里使用的定义。这个策略的显著特征就是，新的符号能轻而易举地添
加进来，并能自动地和原有的保持一致。
</code></pre>

<p>Knuth的系统，在开发中得到了斯坦福的同事和学生的帮助，包含三个组成部分：</p>

<ol>
  <li>TEX 排版引擎</li>
  <li>METAFONT 字体设计系统</li>
  <li>计算机的现代书体(Computer Modern Typefaces)</li>
</ol>

<p>Knuth后来将TEX的代码公开，如今<a href="https://latex-project.org/lppl/">LaTex项目</a>是最成功的自由软件之一。</p>

<h3 id="section">系统组成</h3>
<p>#### TEX 排版引擎</p>

<p>排版语言的关键，是如何将二维的公式用一维的操作序列来表示，从而可以传输给计算机去处理。Knuth在文中列出了三种可能的方案，而最终选择了Type T，这就是我们熟知的TeX排版语言。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/three-approaches.png" alt="" /></p>

<p>此语言有几个优点：</p>

<ul>
  <li>采用自由体的语法，对空白字符没有特殊要求。这样会避免很多人为的语法错误，在传输和跨系统兼容上也比较好。目前的HTML，XML也采用这种方式。</li>
  <li>能够处理普通文本，以及嵌入其中的数学公式。这样适用性广。</li>
  <li>助记符含义清晰、符合英文习惯，易于学习，比如\sqrt, \theta, \over</li>
  <li>保留字很少，主要是特殊的符号\,{},^,_</li>
</ul>

<p>TEX排版的主要想法是读入排版语言写成的手稿文本，构造出盒子(boxes)。一种字体的一个字符，或者一个黑色的长方形块，是最小的盒子，就象原子一样，而水平或垂直方向的一系列盒子(一行或一列)，就象是“分子”。这样的一行，组成的盒子，进而构成一本书中典型的一页。</p>

<p>水平或垂直方向的一组盒子，用称作“胶水”的“弹性灰浆”分隔开。两个盒子之间的胶水，用三个分量来表达$(x,y,z)$，都是指长度：</p>

<ul>
  <li>$x$, 空白分量，是这些盒子之间理想或正常的空白</li>
  <li>$y$, 延展分量，允许的额外空白的量</li>
  <li>$z$, 收缩分量，如果需要可以安全移去的空白</li>
</ul>

<p>在一个单词内的字母$x=y=z=0$，表示前后字母紧挨着。单词之间的间距，可以令$x$等于字母e的宽度，$y=x$, $z=x/2$，代表间距可以延展或收缩。</p>

<p>排版的一个重要任务，是确定一段文字要分成几行，称为断行(line division)。通常的断行，是一行接着一行处理。断完一行后，前行的结果与段落后面的部分没有关系。一个更好的方式是，将整个段落作为整体来考虑。Knuth的文章，设定了badness，相当于优化算法中的损失函数。断行的问题就转化为：</p>

<pre><code>给定一段文字以及允许断行的所有位置，寻找一组断点，
让badness的平方和最小化。
</code></pre>

<p>如果一个段落有$n$个可以断行的点，就会有$2^n$个可能的方式去断行。这个计算复杂度很好。所幸的是，有一个技术能将$2^n$复杂度降低到$n^2$，这就是动态规划(dynamic programming)的数学方法。</p>

<h4 id="metafont-">METAFONT 字体设计系统</h4>

<p>在设计字体时，一种策略是将现有的字体拍照下来，再数字化。但Knuth觉得，他当时没有合适的照相机等设备来做这些。不过，更关键的是，他觉得“拷贝”的方法没有切中问题核心。他说到一个轶事，最早传到东方的计算尺在侧面有个小污点，结果日本早期造的计算尺在相同的位置都有一个无用的黑点。所以要”拷贝实质而非形式”(We should copy the substanc rather than the form)。他认为正确的问题，不是去问“如何拷贝那些已经设计好的字体”，而是问“<strong><em>过去伟大的字体设计家如果现在还活着，他们会如何为新设备(注：指计算机)设计字体？</em></strong>”。</p>

<p>Knuth研究了字体设计的历史。发现在15世纪开始，即文艺复兴时期，出现了用尺规作图的几何方式来设计字体。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/ruler-compass-construction.png" alt="" /></p>

<p>但后来的历史表明，这种几何方法设计的字体比较丑陋，而且主要用于大写字母。不过，在往后的几百年，出现了一些新的进展，也给数学化字体设计提供了基础。</p>

<p>Knuth采用3次样条函数的方式描述曲线，以及模拟书法家写字的过程，对笔和墨水的宽度加以描述。所以，META有别于轮廓字体，更不同于点阵字体。它描述了笔的中心经过的曲线，以及伴随笔的移动，所允许的笔的形状。这个方法的主要优势是，可以产生无限多内在一致的相关字体族。如下图，通过调整参数就可以产生各种字体(罗马、粗体、无衬线、无衬线粗体、打印体…)。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/fonts-family.png" alt="" /></p>

<p>METAFONTS 还要解决从连续到离散的问题，字体需要在屏幕上显示，或者要以离散格栅的形式显示，以便照排印刷。一个直接的方法是，先按照无限的精度画出字母，再按实际的分辨率，将每个足够黑的正方形取整为一个黑色的像素。但是，以字母m为例，这会造成，本来同宽的三竖，数字化后粗细不一、间距不等。所以，实际的做法是，先将”笔“数字化，并设计更为平滑的”取整“方法。</p>

<p>下图是字体参数相同但分辨率不同，在格栅上的显示。</p>

<p><img src="http://hack.the-lifematrix.net/images/what-learn-from-tex/different-resolution.png" alt="" /></p>

<h2 id="section-1">思考</h2>

<p>一个技术如果一直没有被取代，有两种可能。一是技术过于老化，但是人们没能找到革新的方法，只好忍受它。二是它已经很好地解决了所在领域的问题，在长期内很好地服务领域用户，这被称为“杀手级”的产品。显然，TEX属于后者。</p>

<p>Knuth从自己实际工作的痛点出发，对相关问题进行研究，并创造性地运用数学的工具来对问题进行描述，得到非常完美的解决方案。这不得不让人敬佩。这才是真正的计算机科学家。最后，小结一下TEX给我们的启发。</p>

<ul>
  <li>从实际的痛点出发，痛点代表真实的需求</li>
  <li>系统化、完整化地解决问题</li>
  <li>数学是建模、信息处理以及算法设计的强大宝库</li>
  <li>好的系统：核心的稳定和外围的扩展</li>
  <li>通过设计域特定语言(DSL)来达到极大的复用度和灵活性</li>
  <li>必须考虑跨平台</li>
  <li>建立用户群，不断接收用户反馈，完善和升级产品</li>
  <li>必要时，将软件开源或发布为自由软件，以获得更多的社区参与力量，保持项目的生命力</li>
</ul>

<p>关于最后一点，LaTex现在已经成为自由软件，由社区去维护，保持了巨大的活力。某种程度上，它已经成为全世界的智慧资产。如果开发的系统达到这个程度，也是很欣慰的。好的自由软件，比如Linux，都会达到这一步。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么学习Lisp?]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/10/why-learn-lisp/"/>
    <updated>2015-10-08T10:38:18+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/10/why-learn-lisp</id>
    <content type="html"><![CDATA[<p><em>本文的主要内容来自Paul Graham的<a href="http://www.paulgraham.com/acl.html">《ANSI Common Lisp》</a>，以及作者自己的思考。</em></p>

<h2 id="section">计算和编程语言</h2>

<p>人类的进化，总是试图将智能带进物质，让物质按照人的期望去做事。其一是实用性目的，能替代人的重复性工作或难以做到的工作，让人的生活水准提高，或步入更高的创造层次。其二是人性固有的好奇心，求知的渴求和成就感的满足。将智能带入物质，是个不断进化的过程。从最初的机械式自动化设备，比如钟表、抽水马桶、纺织机械等，到现在的计算机。进化的越高端，智能越能直接通过物质去表达。</p>

<p>智能也包括很多层次，最基础和最低端，是逻辑。计算机的出现，得以让逻辑直接物质上去表达。计算机提供指令，完成基本的逻辑和数字运算。编程语言，是人与计算机沟通的方式。编程语言抽象层次越高，越接近人的思维。抽象层次越低，越接近机器指令。利用编程语言，编写较高层次的逻辑，就是软件。计算机，让人类可以在逻辑层次而非物理层面去创造，这就是所谓的软件–逻辑产品。</p>

<p>人类思维的本质，喜欢内在的秩序，如果事物过于纷乱，无法找到规律或秩序，人就会难以驾驭它。当然某些混乱，并不意味着失控，而是更大更高秩序的展现。如果有太多复杂和详细的逻辑要表达，人就会难以理解，以至于出现思维的失误，具体到软件上，就是BUG。</p>

<p>例如，如果汇编语言来编写WORD这样的软件，其工作量将增加几十倍。如果我们将软件团队的所有成员，看成一个更大的大脑。那么，这个大脑在处理复杂逻辑上，有其极限。达到临界点时，增加人手，会让沟通成本增加，反而降低效率。为了处理复杂的逻辑，或编写更为庞大精巧的软件，就必须在较高的层次去思考、设计和编码。这就是编程语言的重要性。<strong>编程语言决定了对问题的思考方式</strong>。</p>

<p>一旦人不需要直接去创造物理产品，而着力创造逻辑产品的时候，人的思维就会从物理的束缚中解脱出来，达到更大的自由度。所以软件的开发、升级、创新，会呈现出越来越大的活力。每个生活领域、每个商业分支等，都会有很多逻辑可以用软件来表达，由此人类生活的各个方面都会有软件渗透进去，编程语言会起到更大的作用。</p>

<p>所以，编程语言自身的进化和发展，代表了人类对逻辑的表达能力的提升。从汇编、到C、到java，抽象度在提高，软件可以编写地更为复杂、巨大。</p>

<p>一个好的语言，要具备这几点：</p>

<ul>
  <li>表达力</li>
  <li>核的精炼</li>
  <li>扩展的丰富</li>
  <li>性能</li>
  <li>开发效率</li>
</ul>

<p>表达力指语言的抽象能力，对事物的概括能力。精炼的核，保证了语言本质的简洁，容易理解和掌握。扩展的丰富，代表了语言的适应力和不断进化的能力。性能，指语言的实现在物理机器上运行的效率。开发效率，包括写代码的速度、错误率等。</p>

<p>通过Graham的介绍，Lisp就是这样优秀的语言。</p>

<h2 id="lisp-">Lisp 的特点</h2>

<p>John McCarthy在1960年代左右发明了Lisp语言。继Fortran之后，Lisp是仍在使用的最古老的语言。更值得注意的是，Lisp仍然处于编程语言技术的前沿。懂Lisp的程序员会告诉你，Lisp的有些东西把它和别的语言区分开。</p>

<p>Lisp语言的独特性，部分源于它被设计为<strong>可进化</strong>的语言。你可以利用Lisp来定义新的操作符。当新的抽象变得流行时(例如，面向对象编程)，它总是能在Lisp轻易实现。就像DNA，这样的语言不会过时。</p>

<h3 id="section-1">新的工具</h3>

<h4 id="section-2">语法闭包</h4>

<p>学习Lisp是因为它能让你做在其它语言中做不了的事情。如果你只想让语言做一些简单的事，比如写一个函数，返回小于$n$的所有数之和，那么Lisp和C差别不大。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="Lisp"><span class="line"><span class="c1">; Lisp</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">sum</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
</span><span class="line">  <span class="p">(</span><span class="k">let</span> <span class="p">((</span><span class="nv">s</span> <span class="mi">0</span><span class="p">))</span>
</span><span class="line">    <span class="p">(</span><span class="nb">dotimes</span> <span class="p">(</span><span class="nv">i</span> <span class="nv">n</span> <span class="nv">s</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nb">incf</span> <span class="nv">s</span> <span class="nv">i</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="C"><span class="line"><span class="cm">/* C */</span>
</span><span class="line"><span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span><span class="line">	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class="line">	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
</span><span class="line">		<span class="n">s</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
</span><span class="line">	<span class="k">return</span> <span class="n">s</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你想写一个函数，它接收参数$n$，返回一个将任何数加$n$的函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="Lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">addn</span> <span class="p">(</span><span class="nv">n</span><span class="p">)</span>
</span><span class="line">  <span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="nv">n</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>那么C就做不到了。</p>

<p>你可能会想，为什么没有人曾经这么想呢？<em>编程语言叫你不要去想那么语言提供不了的东西</em>。为了在语言之中写程序，你必须在语言之中思考。比如，很多人开始用Basic写程序，就不会去想递归，因为在Basic中就没有递归这回事。他只能考虑迭代算法。</p>

<p>上面的例子，叫词法闭包(lexical closures)，Lisp程序员一直在使用，但是在其它语言中却看不到。</p>

<h4 id="section-3">同象性</h4>

<p>Lisp另一个更有价值的特点是，其代码和数据具有相同的结构，亦或代码用数据结构的形式表达。这意味着，程序员通过操作数据，就可以形成新的代码。也就是，可以能编写程序的程序。这在Lisp中，通过宏来实现。</p>

<p>通过宏、闭包和运行时类型，Lisp超越了面向对象编程。</p>

<h3 id="section-4">新的技术</h3>

<p>Lisp所带有的新事物 – 自动内存管理，明显的类型化，闭包等等，都会让编程更容易。这些组合在一起，就形成临界质量，让新的编程方式成为可能。</p>

<p>Lisp设计为可以扩展的：它允许你自己定义新的运算符。扩展Lisp并不比用它写程序更困难。事实上，这很容易(而且如此有用)，以至于成为Lisp编程的标准实践。正如你可以写程序向下通向语言，你也可以构建语言向上通向你的程序。你自底向上工作，正如自顶向下。</p>

<p>几乎任何程序都能从裁剪语言适应它的需要中获益，但是程序越复杂，自底向上的编程就越有价值。一个自底向上的程序，可以写成一系列的层，每一个作为上一层的一种编程语言。TEX是最早以这种方式写出的程序。你可以在任何语言中以自底向上的方式写程序，但Lisp是这种方式最为自然的工具。</p>

<p>自底向上编程自然地产生了可扩展的软件。如果你采用了自底向上的编程原理一直到你程序的最顶层，那么这一层就会成为给用户的编程语言<em>(注：如果最上层是自然语言，那就意味着软件可以和用户对话了，哈哈)</em>。因为扩展性的想法如此根植于Lisp之中，使得它成为编写可扩展软件的理想语言。1980年代最成功的软件中有三个，都提供Lisp作为扩展语言：Gnu Emacs, Autocad 和 Interleaf。</p>

<p>自底向上工作，也是获得可复用软件的最佳途径。编写可复用软件的核心是，将普遍和特殊分开。自底向上编程本质上就创造了这样一种分离。不是将你的精力全部放在单一的、庞大的应用上，你将你的部分精力用于构造语言，部分（成比例的相应小一些）用于在其上编写应用。对这个应用特殊的地方，将集中在最顶层。其下的层将形成一个语言，来写这样的应用。什么能够比编程语言更具复用性的？</p>

<p>Lisp 不但允许你编写更为精巧的程序，也能让你更快地编写。Lisp程序常常短小 – 语言给你了更大的概念，所以不必用那么多。正如Frederick Brooks指出的，写程序花的时间绝大多数取决于它的长度。但就这个事实，写Lisp程序需要的时间更少。这个效果被Lisp的动态特征放大了：在Lisp中，编辑-编译-测试的循环是如此简短，以至于编程是实时的。</p>

<p>更高的抽象和交互式环境能改变组织开发软件的方式。<strong>快速原型</strong>术语描述了开始于Lisp的一种编程方式：在Lisp中，你能花比写规约更少的时间来写原型。而且，这个原型是如此抽象，相比用英语写下来的规约，它是更好的规约。Lisp允许你从原型到生产性软件的平滑过渡。当Common Lisp程序在编写时留意速度，并用现代编译器编译，它们能运行地像用任何其他高层次编写的程序一样快。</p>

<h3 id="section-5">新的策略</h3>

<p>Lisp使得一种新的编程策略成为可能。这一策略将在未来更常看到。随着编程环境更加强大，语言变得更为抽象，Lisp风格的编程将逐渐取代旧有的计划-实施模式(plan-implement model)。</p>

<p>在旧的模式中，Bug从不假设会发生。详尽的规约，提前煞费苦心地做出来，被假定能保证程序可以完美地运行。这在理论上听起来很好。不幸地是，规约也是由人书写且实施的。实际上，计划-实施模式的效果并不那么好。</p>

<p><em>(注：规约也是人写的，也会出错，而且因为是文字性的，其错误更不易排查，只能通过同行不断评审来保证。换句话说，自然语言本就不适合描述逻辑。需求可能需要用文字来描述。规约，或者软件功能特征的定义，可以用原型的方式来表达。当然，有些特性的逻辑层次较深，不是操作原型一下子就能看到。这是辅以文字说明是必要的。也就是增加原型说明的文档。)</em></p>

<p>作为OS/360项目的经理，Fredericks Brooks 对传统策略很熟悉，对其结果也很了如指掌：</p>

<pre><code>任何OS/360的用户都知道，它本应该更好些...而且，交付延迟了，
它使用了比计划更多的内存，成本比预计高了几倍，直到多个发行版之后才运行良好
</code></pre>

<p>这就是对那个时代最成功之一的软件系统的描述。</p>

<p>旧模式的问题是忽略了人性的弱点。在旧模式中，你打赌规约中没有包含任何严重的缺陷，实现它们只是简单地翻译成代码。经验显示这是个糟糕的赌注。更安全的打赌是，规约会被误导，代码中满是bug。</p>

<p>这恰就是新的编程模型所假定的。与其希望人们不犯错，不如努力让出错的成本降低。错误的成本是修正它需要的时间。如果有强大的语言和良好的编程环境，成本就会极大降低。由此，编程风格就较少地取决于计划，更多依赖于探索(exploration)。</p>

<p>计划是必要的恶：它是对风险的反应。一件事危险越大，事先计划就越重要。强大的工具降低了风险，因此也降低了对计划的需要。然后，你程序的设计就能从可能是最有价值的可用信息源中获益 – 实施它的经验。</p>

<p>自从1960年代，Lisp风格就在这个方向上进化。你能在Lisp中如此之快地写出原型，以至于你能经历几次设计和实现的迭代，而在旧的模型中，你才刚刚写完规约。你不用过于担心设计缺陷，因为你能马上发现它们。而且你不用担心有太多的bug。<strong>当你用函数风格编程时，bug只会有局部影响(When you program in functional style, bugs can only have local effects)</strong>。当你使用非常抽象的语言，有些bug(例如悬空指针，dangling pointers)将不再可能。剩下的也会很容易发现，因为你的程序更为简短。当你有个交互环境，你能立即修正bug，而不用忍受编辑、编译和测试的漫长周期。</p>

<p>Lisp风格进化了这种方式，因为它奏效。听起来很奇怪，较少的计划意味着更好的设计。技术的历史充满了类似的案例。绘画中一个相似的改变，发生在15世纪。在油画流行之前，画家们使用一种介质，称为蛋清颜料(tempera)，它不能被掺杂或涂掉重画。出错的成本很高，这常常让画家变得保守。然后出现了油画，这在风格上是极大的变化。油彩允许二次思考(Oil “allows for second thoughts”)。这提供了决定性优势去处理诸如人物肖像这样有难度的题材。</p>

<p>新的介质并没有让画家的日子轻松一些。它让崭新的、更有进取心的绘画方式变为可能。Janson写到：</p>

<pre><code>没有油彩，佛兰芒画师们对视觉现实的征服将受到很大限制。因此，也从技术角度看，
他们值得被成为“现代绘画之父”。因为，从那时起，油彩就成为画家的基本颜料。
</code></pre>

<p>就材料而言，蛋清颜料并不比油彩差。但是油彩的灵活性给了想象力更大的空间 – 这是决定性因素。</p>

<p>编程如今也在经历类似的变化。新的媒介被成为“面向对象的动态语言”，简言之，Lisp。这并不是说我们所有的软件在几年里都会用Lisp去编写。从蛋清颜料到油彩的变迁，没有在一夜之间完成。开始，油彩只是在领先的艺术中心流行，经常会与蛋清颜料组合使用。我们现在就处于这个阶段。Lisp用在大学、研究实验室和少数前沿的公司。同时，从Lisp中借用的想法越来越多地出现在主流：交互式编程环境、垃圾回收、运行时类型等，不一而足。</p>

<p>更强大的工具正在将风险从探索中拿掉。对于程序员来说，这是好消息，这意味着我们能着手更为进取心的目标。油画的使用已经说明了这一效果。紧随它的采用，绘画史上的黄金时代来临了。已经有信号出来，类似的事情将发生在编程中。</p>

<h2 id="lisp">Lisp于当下</h2>

<p>Paul Graham 的书写于1996年，20年过去了，Lisp并没有成为编程语言的主流。不过, 他所阐述的Lisp的优点的确都大量被其它编程语言采用。</p>

<p>1990年代Web的出现将编程带入新的时代。之前更多的是单机运行的系统。在Web环境下，代码更新到服务器端就意味着发布，所以不经编译的解释性语言会加快测试-修正-发布的循环。而且，Web的前端要求内容与逻辑的集成，PHP这种将代码嵌入HTML中的解释性语言就大为流行(也包括Asp.net, JSP等)。其它的解释性语言如Perl, Python, Ruby也在不同社区蓬勃发展。</p>

<p>垃圾回收或自动内存管理，已经被Java和.Net等广泛采用。</p>

<p>那么Lisp为什么没有成为主流，为大多数程序员所接受呢？作者的分析是：</p>

<ul>
  <li>
    <p>Lisp的学习曲线比较陡，不是快速上手的语言。Lisp的编程思维，与通常的过程化编程有很大的不同。过程化编程，更多地表达的是一种平铺式的线性逻辑。用过程化思维编程，代码量大且代码复用率低，但是当开发者素质不高时，这种方法反而便于任务的分解和沟通，达到快速开发。而Lisp则需要极高的抽象能力，对开发者水平要求很高，相互间要在高层次上沟通。所以Lisp适合于比较有生命力的、复用度高、逻辑复杂的产品类开发，一次开发，长期使用。而传统的过程化语言，适合于短平快的项目型开发。</p>
  </li>
  <li>
    <p>Lisp的优势，不在于直接用它去编写某个应用领域的程序。而是通过宏、闭包等工具，构建新的语言，这种语言有较高的抽象度，能更直接地描述应用领域中的问题。这样之后的编程量和错误率，都会大为减少(换言之，抽象度越高、代码量越小的程序，编写地越快而且错误率越低)。虽然这个思路是正确而有效的，但缺乏有经验的开发者这样去做。</p>
  </li>
  <li>
    <p>Lisp在国内的计算机科学教育中缺少足够的重视。很多技术人员只追踪流行的技术，而缺少技术本质的了解。就象<a href="http://hack.the-lifematrix.net/blog/2015/06/a-conversation-with-alan-kay/">Alan Kay所说</a>，很多计算机的本科教育成了Java培训。</p>
  </li>
  <li>
    <p>采用Lisp编程，由于需要人的素质高，不适于短平快的项目。所以在注重速度的互联网时代，很难被商业公司选择。</p>
  </li>
</ul>

<p>技术总在发展。Lisp虽然没有成为主流，但它的基因和生命力还在。在未来，Lisp能否扩大它的影响力？笔者认为是可能的。</p>

<ul>
  <li>
    <p>Web快速发展，产生了很多快速开发的方法，但都属于过渡性技术。比如HTML，javascript，PHP。如何让Web页面更具交互性，如何将内容和逻辑合理地分离，如何适应移动端的Web应用开发，以及Web应用与本地应用的结合，都会对技术提出更高的要求。我们已经到了需要清晰、规范、合理的Web开发模式的时候，HTML5和CSS3都是这方面的尝试。但是，仍感觉是过度性的，尤其CSS3。</p>
  </li>
  <li>
    <p>未来需要一些高质量的平台或框架类的产品，尤其是针对问题域提供高度抽象的语言，Lisp会有用武之地。</p>
  </li>
  <li>
    <p>随着Lisp的传播，当更多高水平开发者认识到Lisp的价值，会用Lisp开发出来一些“杀手级”产品。</p>
  </li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Art of Interpreter: Part One]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-part-1/"/>
    <updated>2015-08-24T14:50:59+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-part-1</id>
    <content type="html"><![CDATA[<h3 id="section">第一部分：变量范围</h3>
<p>Part One
Variable Scoping Disciplines</p>

<h4 id="procedures-as-data">Procedures as Data</h4>

<p>The simple LISP described in Part Zero can be a pleasant medium for
encoding rather complex algorithms, including those of symbolic
mathematics. Often lists are used for representing such structures as the
set of coefficients of a polynomial or coordinates of a space vector. Many
problems require one to perform an operation on each element of a list and
produce a new list of the results. For example, it may be useful to make a list of the squares of each of the elements in a vector. We would write this as follows:</p>

<p>在第零部分描述的简单LISP，可以作为令人愉快的媒介，去编码相当复杂的算法，包括那些符号数学。列表经常用于表示比如多项式系数或者空间向量的坐标等这样的结构。许多问题需要人去执行对列表每个元素的操作，并产生一个作为结果的新列表。例如，产生向量中每个元素平方的列表，可能是有用的。我们这么写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SOUARELIST</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">SQUARE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">SOUARELIST</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We find ourselves writing this pattern over and over again:</p>

<p>我们发现我们自己一再地写这样的模式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">fLIST</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">f</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">fLlST</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where f is a function defined on the elements of our list. It would be
nice to be able to define an entity of the programming language which would
capture this abstract pattern. The “obvious” solution is to write the variable function as a functional variable which can be accepted as an argument:</p>

<p>这f是一个定义在列表元素上的函数。如果能够定义一个编程语言的实体可以捕捉这一抽象模式，会是极好的。“明显的”解决方法是写一个可变的函数作为函数化变量，它可以作为一个参数被接受。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">F</span> <span class="nv">L</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">L</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">F</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                         <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">F</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">L</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(MAPCAR is the traditional name of this abstraction.) Using this we could
say:</p>

<p>(MAPCAR是这一抽象的传统名字) 利用此，我们可以写出：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">SQUARE</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Unfortunately, this will not work in our recursion equations interpreter.
Why not?</p>

<p>不幸的是，这不能在我们的递归方程解释器中运行。为什么不行？</p>

<p>The essence of the problem is that our interpreter segregates procedures from other kinds of objects. We refer to F as a procedure but it was passed in as a variable. Procedures are only looked up in the PROCEDURES symbol table, but variables are bound in ENV. Moreover, in the call to MAPCAR, SQUARE is used as a variable, which is looked up in ENV, but its definition is only available in PROCEDURES.</p>

<p>问题的关键是，我们的解释器将过程从其它类型的对象分离开。我们将F引用为一个过程，但是它作为变量传递。过程只在PROCEDURES符号表中查找，但是变量在绑定在ENV里。而且，对MAPCAR的调用，SQUARE被当做变量来使用，它将在ENV中查找，但是它的定义只存在于PROCEDURES。</p>

<p>Let’s merge the two symbol tables… How could that hurt?
让我们将两个符号表合并起来… 这有如何损害？</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER-LOOP-1</span> <span class="nv">ENV</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span> <span class="nv">ENV</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="ss">&#39;DEFINE</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))</span>
</span><span class="line">                                    <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CDADR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FORM</span><span class="p">)))</span>
</span><span class="line">                                    <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                              <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))))</span>
</span><span class="line">                <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">ENV</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="nv">ENV</span><span class="p">))))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For DRIVER—LOOP see Figure 1.
For EVAL see Figure 5.
For BIND see Figure 3.</em></p>

<center>
Figure 4
<br />
Modified Driver Loop for Treating Procedures as Objects
</center>

<p>We will eliminate PROCEDURES, and use ENV to contain both procedures
and other objects. The driver loop requires no particular changes (see
Figure 4), except for eliminating the argument 1) in the calls to EVAL. We
will change the name PROCEDURES to ENV throughout as well, but of course that
isn’t logically necessary, because our language is referentially
transparent. (snicker!) {Note EVALQUOTE}</p>

<p>我们去掉了PROCEDURES，然后使用ENV包含过程和其它对象。在调用EVAL时，driver loop 没有要求特别的改变(看图4，除过去掉参数1)。我们也将改变PROCEDURES的名字为ENV，但是当然在逻辑上是不必要的，因为我们的语言是引用透明的。(窃笑!) {Note EVALQUOTE}</p>

<p>(We have introduced a funny object &amp;PROCEDURES which we use to flag
procedural objects. In the previous interpreter it was impossible for the
user to request application of an object which was not either a primitive
operator or a procedure produced by a DEFINE form. Now that procedures
mingle freely with other data objects, it is desirable to be able to
distinguish them, e.g. for error checking in APPLY. We also have some
deeper motivations having to do with avoiding the confusion of a procedure
with its textual representation, but we do not want to deal with this issue
yet.)</p>

<p>(我们已经引入了一个有趣的对象&amp;PROCEDURES，我们用来标记过程兑现。在前面的解释器中，对用户来说，不可能请求应用一个对象，它既不是原语操作符，也不是由DEFINE form生成的一个过程。既然过程可以自由地与其它数据对象混合，能够将它们区分开，是可取的，例如对于APPLY中的错误检查。我们也有一些更深的动机不得不避免过程与它的文本表达之间的混淆，但是我们还不想处理这个议题。)</p>

<p>To fix up the evaluator, we eliminate all occurrences of PROCEDURES.
In EVAL, where the name of a procedure in a combination is looked up, we
change it to perform the lookup in ENV. Finally, there is a problem in
APPLY: if the call to EVAL to evaluate the body is simply</p>

<p>为了修补求值器，我们去掉所有PROCEDURES的出现。在EVAL中，在组合里面查找过程的名字，我们改变它，以便在ENV中执行查找。最后，在APPLY中有个问题：如果为了对求值主题而对EVAL的调用，简单地是：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="o">&#39;</span><span class="p">()))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>then the new ENV given to EVAL does not have the procedure definitions in
it. Moreover, APPLY does not even have access to an environment which
contains the procedure definitions (because its parameter PROCEDURES was
deleted)! We can easily fix this. When APPLY is called from EVAL, ENV can be passed along (as PROCEDURES used to be), and the call to EVAL from APPLY
can be changed to</p>

<p>那么传递给EVAL的新的ENV，不能在它其中包含过程定义。而且，APPLY甚至不能访问包含过程定义的环境(因为它的参数PROCEDURES被删除了)。我们能容易地修正这个。当从EVAL中调用APPLY时，ENV能单独地给传递，然后从APPLY中对EVAL的调用，能够被改为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In this way the environment passed to EVAL will contain the new variable
bindings added to the old environment containing the procedure definitions.
(See Figure 5.) This is indeed a good characteristic: if the name of a
defined procedure is used as a local variable (procedural or otherwise), the new binding takes precedence locally, temporarily superseding the global definition.</p>

<p>在这个方式下，新的变量绑定将添加到包含过程定义的旧环境中，作为传递给EVAL的环境(见图5)。这的确是一个好的特征：如果一个被定义的过程的名字，被作为局部变量使用(过程的或其它)，那么新的绑定将采用局部优先，临时地替换全局的定义。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="ss">&#39;&amp;PROCEDURE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="nv">CLAUSES</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVLIS</span> <span class="nv">ARGLIST</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CON</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE and BIND see Figure 3.</em></p>

<center>
Figure 5
<br />
Evaluator for Treating Procedures as Objects
</center>

<p>Another good thing about this version of the interpreter is that
the gross non-modularity of the scattered occurrences of PROCEDURES has
disappeared. The problem has not been solved, of course, but we certainly
feel relieved that the particular manifestation has been removed!</p>

<p>这个版本解释器的另一个好处是，散落出现的PROCEDURES的显而易见的非模块性消失了。当然，问题还没有解决，但是我们确实感觉到轻松一些，特别的表现已经被移除了。</p>

<p>By the way, we also eliminated the explicit tests for T and NIL in
EVAL, assuming that we can simply put their initial values in the initial
environment provided by DRIVER.</p>

<p>顺便，我们也去掉了EVAL中对T和NIL显式地测试，假设我们能简单第将他们的初始值放在DRIVER提供的初始环境中。</p>

<p>An interesting property of this interpreter is that free variables
now have been given a meaning, though we originally did not intend this.
Indeed, in the original recursion equations interpreter, there were free
variables in a sense: all procedural variables were free (but they could
be used only in operator position in a combination). In our new interpreter, thanks to the merging of the procedural and variable environments, we may have not only bound procedure names, but also free variable names, for after all the two kinds of names are now one.</p>

<p>这个解释器的一个有趣的属性是，自由变量已经被给出一个含义，尽管我们开始不是有意为之。事实上，在原始的递归方程解释器，存在自由变量有点意思：所有的过程变量是自由的(但是它们只能在组合的操作符位置被使用)。在我们新的解释器，感谢过程和变量环境的合并，我们不但有绑定的过程名，也有自由变量的名字，因为毕竟现在这两类名字合一了。</p>

<p>This interpreter differs in only small details from the one in LISP
1.5 [LISP 1.5M]. Both have dynamically scoped free variables (we will
elaborate on this point later). We might note that the reference to VALUE
in EVAL when computing the first argument for APPLY can be replaced by a
reference to EVAL; this does the same thing if a variable appears in the
operator position of a combination, and allows the additional general
ability to use any expression to compute the procedure. This difference in
fact appears in the LISP 1.5 interpreter. There are other slight
differences, such as the representation of primitive operators and the
handling of procedures which are not primitive or user—defined. Aside from
these, the greatest difference between our interpreter and LISP 1.5’s is
the use of lambda notation. This we will meet in the next section.</p>

<p>这个解释器只和LISP 1.5 [LISP 1.5M]中的解释器有细小的差别。两者都有动态范围的自由变量(我们将在后面详述这点)。我们可能注意到，当为APPLY计算第一个参数时，在EVAL中对VALUE的引用，可以被到EVAL的引用代替；如果一个变量出现在组合的操作符位置，这是做相同的事，并且允许附加的普遍能力去使用任何表达式来计算过程。这个差异事实上出现在LISP 1.5解释器里。这有轻微的不同，比如对原语操作符的表示以及对不是原语或用户定义的过程的处理。除此之外，我们的解释器与LISP 1.5的最大区别是对lambda 记号的使用。我们将在下一节讨论。</p>

<h4 id="section-1">局部过程</h4>
<p>Local Procedures</p>

<p>We now have the ability to define and use the MAPCAR procedure.
After some more experience in programming, however, we find that, having
abstracted the common pattern from our loops, that the remaining part (the
functional argument) tends to be different for each invocation of MAPCAR.
Unfortunately, our language for all practical purposes requires that we use
a name to refer to the functional arguments, because the only way we have
to denote new procedures is to DEFINE names for them. We soon tire of
thinking up new unique names for trivial procedures:</p>

<p>我们现在有能力定义和使用MAPCAR过程。但是，有过一些编程经验之后，我们发现，在从我们的循环提取的共通模式之后，对每个MAPCAR的调用，剩下的部分常常不同。不幸的是，我们的语言针对所有实际目的，要求我们使用一个名字去引用函数化参数，因为我们表示一个新过程的唯一方式，是为它们定义名字。我们很快对无关紧要的过程想一个新的唯一的名字感到厌倦。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FOOBAR-43</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="p">(</span><span class="nb">+</span> <span class="nv">X</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">))</span>
</span><span class="line">
</span><span class="line"><span class="o">...</span> <span class="p">(</span><span class="nv">MAPCAR</span> <span class="nv">FOOBAR-43</span> <span class="nv">L</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>We run the risk of name conflicts; also, it would be nice to be able to
write the procedure definition at the single point of use.</p>

<p>我们承担名字冲突的风险；而且，能够在唯一使用点去写过程的定义，是极好的。</p>

<p>More abstractly, given that procedures have become referenceable
objects in the language, it would be nice to have a notation for them as
objects, or rather in way to write an S-expression in code that would
evaluate to a procedure. LISP [LISP 1M] adapted such a notation from the
λ-calculus of Alonzo Church [Church]:</p>

<p>更抽象地，如果过程在语言中变成可引用的对象，那么有一个把他们当做对象的记号，是不错的，而非在代码中写一个对过程求值的S-表达式。LISP [LISP 1M] 从Alonzo Church那里采纳了这样的记号[Church]：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">variables</span><span class="p">)</span> <span class="nv">&lt;body&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Comparing this with the DEFINE notation, we see that it has the same parts:
a keyword so that it can be recognized; a list of parameters; and a body.
The only difference is the omission of an irrelevant name. It is just the
right thing.</p>

<p>将它与DEFINE记号比较，我们看到，它有相同的部分：一个关键字，从而它能被识别；一个参数列表；和一个主题。唯一的区别是省略了无关紧要的名字。它恰恰是正确的事。</p>

<p>Given this, we can simply write</p>

<p>如果有这个，我们能简单地写：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">X</span><span class="p">))</span> <span class="nv">L</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>rather than having to define SQUARE as a separate procedure. An additional
benefit is that this notation makes it very easy for a compiler to examine
this code and produce an efficient iterative implementation, because all
the relevant code is present locally (assuming the compiler knows about
MAPCAR).</p>

<p>而非必须将SQUARE定义为单独的过程。一个附加的好处是，这个记号让编译器很容易检验这个代码，并产生有效的迭代实现，因为所有相关的代码都在局部提供了(假设编译器知道MAPCAR)。</p>

<p>Installing this notation requires only a two-line change in EVAL (see Figure 6).</p>

<p>加上这一记号仅需EVAL有两行代码的改变。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">ExP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;LAMBDA</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CONS</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">ENV</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE see Figure 3.</em>
<em>For APPLY, EVCOND, and EVLIS see Figure 5.</em></p>

<center>
Figure 6
<br />
Evaluator for LAMBDA-notation (Dynamically Scoped)
</center>

<p>(The reader might have noticed that all EVAL does for a LAMBDA-
expression is replace the word LAMBDA with the word &amp;PROCEDURE, and that we
could avoid that work by uniformly using LAMBDA instead of &amp; PROCEDURE as the
flag for an procedural object. Given then that EVAL on a LAMBDA-expression
is an identity operation, we can eliminate the handling of LAMBDA in EVAL
merely by requiring the user to write ‘(LAMBDA …) instead of (LAMBDA .).
Although the implementors of most LISPs have in fact done just this ever
since LISP 1, it is a very bad idea. EVAL is supposed to process
expressions and produce their values, and the fact that it might be
implemented as an identity operation is no business of the user. The
confusion between a procedural object and an expression having that object
as its value will lead to serious trouble. (Imagine confusing 15 with
(+ 7 8), and trying to take the car of the former instead of the latter, or
trying to add 3 to the latter instead of the former!) The quoted LAMBDA-
expression engineering trick discourages the implementation of a
referentially transparent LISP. In Part Four we will see the extreme
difficulties for a LISP compiler (or other program-understander) caused by
the blatant destruction of referential transparency. {Note QUOTE Shafts
the Compiler})</p>

<p>(读者可能注意到EVAL对一个LAMBDA表达式所做的所有事，就是将词LAMBDA替换为词&amp;PROCEDURE，我们能避免这个工作，通过统一使用LAMBDA而非&amp;PROCEDURE作为一个过程对象的标记。然后如果EVAL在LAMBDA表达式上是一个恒等操作，我们能去掉对EVAL中对LAMBDA的处理，仅仅通过要求用户写’(LAMBDA …) 而非 (LAMBDA .)。虽然自从LISP1，绝大多数LISP的实现器事实上恰恰这么做的，但这是个坏主意。EVAL被假定去处理表达式并产生它们的值，它可能以恒等操作来实现的事实不是用户的事情。过程对象和一个带有那个对象作为其值的表达式，会混淆，这将导致严重的麻烦。(想象混淆 15 和 (+ 7 8)，试试对前者而非后者取car，或者给后者而非前者加3! ) 被引用的LAMBDA表达式工程技巧，阻碍了实现一个引用透明的LISP。在第4部分，我们将看到由于对引用透明性明显的破坏，导致的LISP编译器的极端困难。{Note QUOTE Shafts
the Compiler})</p>

<p>The ability to use free variables and local procedures gives us
additional freedom to express interesting procedures. For example, we can
define a procedure SCALE which multiplies a vector of arbitrary length by a
scalar. If the vector is represented as a list of components, then we can
use MAPCAR and a local procedure with a free variable:</p>

<p>使用自由变量和局部过程的能力，给我们额外的自由去表达有趣的过程。例如，我们能定义一个过程SCALE，它能让任意长度的向量乘以一个标量。如果向量被表达为分量的列表，那么我们使用MAPCAR和一个带有自由变量的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SCALE</span> <span class="nv">S</span> <span class="nv">V</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">S</span><span class="p">))</span>
</span><span class="line">                <span class="nv">V</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Everything would be just peachy keen, except for one small glitch.
Suppose that the programmer who wrote SCALE for some reason chose the name L
rather than S to represent the scalar:</p>

<p>所有事情都看起来是极好的，除过一个小差池。假使写SCALE的程序员由于某些原因，选择了名字L而非去表达标量。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SCALE</span> <span class="nv">L</span> <span class="nv">V</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">MAPCAR</span> <span class="p">(</span><span class="nv">LAMBDA</span> <span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">X</span> <span class="nv">L</span><span class="p">))</span>
</span><span class="line">                <span class="nv">V</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Although the version with S works, the version with L does not work. This
happens because MAPCAR also uses the name L for one of its arguments (that
is, a “local” variable). The reference to L in the LAMBDA-expression in
SCALE refers to the L bound in MAPCAR and not to the one bound by SCALE. In
general, free variable references in one procedure refer to the bindings of
variables in other procedures higher up in the chain of calls. This
discipline is called dynamic scoping of variables, because the connection
between binding and reference is established dynamically, changing as
different procedures are executed.</p>

<p>虽然带S的版本能运行，但是带L的版本却不行。这是因为MAPCAR使用名字L作为它的参数 (也就是，一个局部变量)。在SCALE中的LAMBDA表达式中对L的引用，引用了绑定在MAPCA中的L，而不是由SCALE绑定的那个。普遍地讲，在一个过程中自由变量的引用指向了在调用链中更高层次的其它过程。这个纪律称为变量的动态绑定，因为绑定和引用之间的连接是动态建立的，随着所执行过程的不同而变化。</p>

<p>That the behavior of the SCALAR program depends on the choice of
names for its local variables is a violation of referential transparency.
The modularity of the MAPCAR abstraction has been destroyed, because no one
can use that abstraction without understanding the details of its
implementation. This is the famous “FUNARG problem” [Moses] [LISP
History].</p>

<p>SCALAR程序的行为依赖于它局部变量名称的选择，这一行为，是对引用透明性的侵犯。MAPCAR抽象的模块化被破坏了，因为如果不了解其实现的细节，没有人能使用此抽象。这是著名的”FUNARG 问题“[Moses] [LISP
History]。</p>

<p>If we are to avoid such conflicts between different uses of the same name, we must arrange our language so that the choice of names locally cannot have global repercussions. More specifically, we must have the ability to bind a variable in such a way that it will have a truly local meaning (though in general we might not want all variables to be strictly local -— we will consider later the possibility of having several types of variables).</p>

<p>如果我们要避免相同名称的不同使用之间的冲突，我们必须组织我们的语言使得在局部选择的名字不具有全局的余波。更明确第，我们必须能够这样绑定一个变量，使得它有真正的局部含义 （尽管通常我们不可能想让所有变量都是严格局部的 – 我们将随后考虑有这几种变量类型的可能性)。</p>

<h4 id="section-2">词法范围</h4>
<p>Lexical Scoping</p>

<p>We now construct an interpreter in which all variables have
strictly local usage. This discipline is called lexical scoping of
variables, and has been used in many programming languages, including Algol
60 [Naur]. The term “lexical” refers to the fact that all references to a
local variable binding are textually apparent in the program. The term
static binding is also used, indicating that the connection between binding
and reference is unchanging at run time.</p>

<p>我们现在构造一个解释器，在其中所有的变量都是严格局部使用的。这个纪律被称为变量的词法范围，而且已经被用在很多语言，包括Algol 60  [Naur]。术语”词法”指代这样的事实，所有对一个局部变量绑定的引用，都在程序中文笔可见。术语静态绑定也被使用了，指示绑定和引用在运行时是不改变的。</p>

<p>The difficulty in SCALE is that the body of the LAMBDA-expression
(* X L) is evaluated using the ENV which was available to EVAL (and so passed
to APPLY) when it was working on the body of MAPCAR. But we want the (* x L)
to be evaluated using the ENV which was available when the body of SCALE was
being evaluated. Somehow we must arrange for this environment to be available for evaluating(* X L).</p>

<p>在SCALE中的困难是，LAMBDA表达式 (* X L) 通过使用ENV被求值。当EVAL对MAPCAR的主体工作时，ENV对EVAL是可用的(因此被传递给APPLY)。但是我们想使用ENV对(* X L)求值时，ENV在SCALE的主体被求值时是可用的。我们必须安排这个环境从而对求值(* X L)是可用的。</p>

<p>The correct environment was available at the time the LAMBDA-
expression was evaluated to produce a &amp;PROCEDURE—object. Why not just tack
the environment at that point onto the end of the &amp;PROCEDURE-object so that
it can be used when the procedure is applied?</p>

<p>当前的环境在LAMBDA表达式被求值而产生&amp;PROCEDURE对象是可用的。为什么不在&amp;PROCEDURE对象终止的店商跟踪环境，从而环境能在过程应用时被用到？</p>

<p>This is in fact the right thing to do. The object we want to give
to MAPCAR must be not just the text describing the computation to be
performed, but also the meanings of the free variables referenced in that
text. Only the combination of the two can correctly specify the
computation which reflects the complete meaning of the abstract function to
be mapped. This is the first place where we find it crucial to distinguish
the three ideas: (1) The program — the text describing a procedure, e.g.
in the form of an S-expression; (2) The procedure which is executed by the
computer; and (3) The mathematical function or other conceptual operation
computed by the execution of the procedure.</p>

<p>这就是事实上要做的正确事情。我们想给MAPCAR的对象必须不仅是描述计算的问题，而且要有引用在文本中的自由变量的含义。只有组合这二者才能正确地指定计算，它可以反映所映射函数的完全含义。这就是我们发现区分三个想法如此重要的第一个地方：(1) 程序 - 描述过程的问题，例如，以S表达式的形式；(2) 被计算机执行的过程; 以及 (3) 执行过程所要计算的数学函数或其它概念性计算。</p>

<p>To install lexical scoping in our interpreter, we must change the treatment of LAMBDA—expressions in EVAL to make the current environment ENV part of the &amp;PROCEDURE-object. We say that the procedure is closed in the current environment, and the &amp;PROCEDURE-object is therefore called a closure of the procedure, or a closed procedure. We must also change APPLY to bind the new variable—value associations onto the environment in the &amp;PROCEDURE-object, rather than onto that passed by EVAL. When we have done this, we see that in fact the environment passed by ENV is not used, so we can eliminate the parameter ENV from the definition of APPLY, and change the invocation of APPLY that occurs in EVAL. Thus, while the handling of LAMBDA-expressions has become more complicated, the handling of ENV has been correspondingly simplified. (See Figure 7.)</p>

<p>为了在我们的解释器中安装词法范围，我们必须改变EVAL中对LAMBDA表达式的处理，让当前环境是&amp;PROCEDURE-object对象的一部分。我们说过程在当前环境被关闭，&amp;PROCEDURE 对象因此被称为过程的闭包，或者一个闭合的过程。我们也必须改变APPLY，以便将新的对象-值联合绑定到&amp;PROCEDURE对象的环境中，而非到由EVAL传递的那个对象。当我们这么做之后，我们看见事实上，由ENV传递的对象没有被用到，因此我们能将参数ENV从APPLY的的定义去掉，并改变发生在EVAL中对APPLY的调用。因此，尽管处理LAMBDA-表达式变得更复杂了，但是对ENV的处理却相应地简单了。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;LAMBDA</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">LIST</span> <span class="ss">&#39;&amp;PROCEDURE</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="ss">&#39;&amp;PROCEDURE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="p">(</span><span class="nv">CADDDR</span> <span class="nv">FUN</span><span class="p">))))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><em>For VALUE and BIND see Figure 3.
For EVCOND and EVLIS see Figure 5.</em></p>

<center>
Figure 7
<br />
Evaluator for Lexically Scoped LAMBDA—notation
</center>

<p>Had we previously adopted the trick described in the preceding
section, wherein the user was required to write ‘UAMMm H.) rather than
(LAMBDA…), it would have been more difficult to adjust the interpreter to
accommodate lexical scoping — it would have involved a large change rather</p>

<p>. than a small tweak. (The change from dynamic scoping to lexical scoping</p>

<p>does involve a gross change of programming style, and this is undoubtedly
why, once dynamic scoping had historically become the standard discipline,
the quotation problem was never cleared up. We will see later that dynamic
Steele and Sussman 22 The Art of the Inter rater</p>

<p>scoping is a valuable technique for producing modularity, but we see no
virtue at all in the confusion produced by quoted LMm0A-expressions. While
quoted LAMBUA-expressions do produce dynamic scoping, the support of dynamic
scoping does not depend on the quotation of LMmnA—expressions.)</p>

<p>while lexical scoping solves our problems of referential
transparency, we will see later that we must in turn pay a large price for</p>

<p>it —— but it is not a price of run—time efficiency (contrary to popular
belief)!</p>

<p>Let’s see what we have bought. One thing we can do is generalize
MAPCAR. After yet more programming experience we find that we write many
MANMR-like procedures. For example, we might need a kind of HMWAR where
the function F always returns a list, and we want to produce not a list of
the lists, but the concatenation of the lists. We might also want to take
the sum or the product of all the numbers in a list, or the sum of the cars
of all elements in a list. The general pattern-is that we 1ook.at each
element of a list, do something to it, and then somehow combine the results
of all these elementwise operations. Another application might be to check
for duplicates in a list; for each element we want to see whether another
copy follows it in the list. We further generalize the pattern to look at
successive trailing segments of the list; we can always take the car to
Steele and Sussman A 23 The Art of the Inter reter
<strong>__</strong><strong>__</strong>,<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><em>JL</em>___</p>

<p>get a single element.
we could simply add more procedural parameters to MMAR:</p>

<p>(DEFINE (MAP F OP 10 L)
(COND ((NuLL L) 10)
(T (oP (F L)
(MAP F OP ID (CDR L))))))
Using this, we can make a copy of the list L:
(MAP CAR CONS ‘() L)
we can simulate (MMARF Ln
(MAP (LAMBDA (X) (F (CAR x))) cows ‘() L)</p>

<p>Indeed, we can write:</p>

<p>(DEFINE (MAPCAR F L) ‘
(MAP (LAMBDA (X) (F (CAR  CONS ‘() L))</p>

<p>We can sum the elements of L:
(MAP CAR + 0 L)</p>

<p>we can take the product of the elements of L:</p>

<p>(MAP CAR A 1 L)</p>

<p>we can count the pairs of duplicate elements of L:</p>

<p>(MAP (LAMBDA (x) x)
(LAMBDA (Y N) (coup ((MEMBER (CAR Y) (con Y))
(+ N 1))</p>

<p>(T N)))
0</p>

<p>L)</p>

<p>If we have occasion to take the sum over lots of lists in different</p>

<p>places, we might want to package the operation “sum over list“ —- we get
awfully tired of writing “CAR4-0”. we can write:</p>

<p>(DEFINE (MAPGEN r OP ID)
(LAMBDA (L) (MAP F op 10 L)))</p>

<p>The result of (MMmENcAP+-o) we might call sun-— it is a procedure of one
argument which will sum the elements of a list. The reason we wrote a
procedure to construct sum, rather than just writing:
Steele and Sussman 24 ‘ The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong>~<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__<em>£</em></strong>_</p>

<p>(DEFINE (sum L)
(MAP CAR + o L))</p>

<p>is that MANHN serves as a generalized constructor of such procedures, thus
capturing an interesting abstraction-— we might call the result of (MAPGEN
CAR « 1), for example. PRONET, and so on. L</p>

<p>What is interesting about this is that we can write procedures
which construct other procedures. This is not to be confused with the
ability to construct S-expression representations. of procedures; that
ability is shared by all of the interpreters we have examined. The ability
to construct procedures was not available in the dynamically scoped
interpreter. In solving the violation of referential transparency we seem
to have stumbled across a source of additional abstractive power. While
the MAP example may seem strained, this example is quite natural: given a
numerical function, to produce a new function which numerically
approximates the derivative of the first.</p>

<p>(DEFINE (DERIVATIVE F AX)
(LAMBDA (x)
(/ (— (F (+ X AX))
(F X))
AXH)</p>

<p>Notice that this is not a symbolic process dealing with the representation
of F. The DEMVAHVE procedure knows nothing about the internal structure of
F. All it does is construct a new procedure which uses F only by invoking
it. The program tmaxvnnvz captures (in approximation) the abstraction of</p>

<p>“derivative” as a mapping from the space of numerical (and reasonably well-
behaved!) functions to itself.</p>

<p>The ability to define procedures which construct other procedures
is powerful. we,can use it to construct procedures which behave like data</p>

<p>objects. For example, since the only constraints which cons must (so far)
obey are the algebraic identities:</p>

<p>(CAR-(CONS a 3)) = a and (con (cons a ﬁ)) = 3</p>

<p>the value of (emu a G) can be thought of as a procedure which produces a or</p>

<p>8 on demand (cf. [Hewitt and Smith] [Fischer]). We can write this as
follows: i</p>

<p>(DEFINE (cows A o)
(LAMBDA (M)
(COND ((= M o) A)
((= M 1) D))))</p>

<p>(DEFINE (CAR X) (X 0))</p>

<p>(DEFINE (COR X) (X 1))
Steele and Sussman 25 The Art of the Inter reter
<strong>__</strong><strong>__H</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__<em>£</em></strong>_</p>

<p>Here we have envisioned the value of unusa G) as a vector of two elements,
with zero—origin indexing. However, this definition of cows makes use of
the primitive operator =. we can define the “primitive operators“ cons,
CAR, and can without using another primitive operator at all! Following
[Church], we write:</p>

<p>(DEFINE (cows A 0)
(LAMBQA (M) (M A D)))</p>

<p>(DEFINE (CAR X)
(X (LAMBDA (A D) A)))</p>

<p>(DEFINE (CUR X)
(X (LAMBDA (A D) D)))</p>

<p>Rather than using 0 and 1 (i.e. data objects) as selectors, we instead use
(LAMBOA (A 0) A) and (LAMBDA(A D) 0) (i.e. procedures).</p>

<p>we can think of the LMmnA-expression which appears as the body of
the definition of DERWATWE or of ams as a prototype for new procedures.
when DERIVATIVE or cows is called, this prototype is instantiated as a
closure, with certain variables free to the prototype bound to the
arguments given to the constructor.</p>

<p>At this point it looks like we have solved all our problems. We
started with a referentially transparent but expressively weak language.
We augmented it with procedural objects and a notation for them in order to
capture certain notions of abstraction and modularity. In doing this we
lost the referential transparency. we have now regained it, and in the
process uncovered even more powerful abstraction capabilities.</p>

<p>Top Levels versus Referential Transparency</p>

<p>“The Three Laws of Thermodynamics:
1. You can’t win.
2. You can’t break even.
3. You can’t get out of the game.”
— Unknown</p>

<p>There is no free lunch. We have ignored a necessary change to the
top level driver loop. we have changed the format of avmmemme-objects.
onxvkk-LooP—1 constructs &amp;PRmxnuR£—objects; it must be rewritten to
accommodate the change. We must include an environment in each such
object. The obvious fix is shown in Figure 8.
Steele and Sussman 26 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>£</strong>___</p>

<p>(DEFINE (DRIVER—LO0P-1 ENV FORM)
(COND ((ATOM FORM)
(DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
((EO (CAR FORM) ‘DEFINE)
(DRIVER-LOOP (BIND (LIST (CAADR FORM))
(LIST (LIST ‘&amp;PROCEDURE
(CDADR FORM)
(CADDR FORM)
ENV))
ENV)</p>

<p>(PRINT (CAADR FORM))))
(T (DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))))</p>

<p>For onxvewioov see Figure 1.
For BIND see Figure 3.
For EVAL see Figure 7.</p>

<p>Figure 8
Modified Driver Loop for Lexically Scoped LAMBDA-notation</p>

<p>It doesn’t work. This patch does put the finishing touch on the
preservation of referential transparency. It does it so well, that each
new definition can only refer to previously defined names! We have lost
the ability to make forward references. we can’t redefine a procedure
which had a bug in it and expect old references to use the new definition.
In fact, we cannot use DEFHE to make a recursive procedure. {Note Y-
operator} The avmmsmme-object for each defined procedure contains an
environment having only the previously defined procedures.</p>

<p>We are finally confronted with the fact that we have been seeking
the impossible._ We have tried to attain complete referential transparency
(in the expectation that modularity would be enhanced), while trying also
to retain the notion of an incremental, interactive top—level loop for
reading definitions. But the very existence of such a top level inherently
constitutes a violation of referential transparency. A piece of code can
be read in which refers to an as yet undefined identifier (the name of a
procedure, for example), and then later a definition for that identifier
read in (thereby altering the meaning of the reference).</p>

<p>If we stubbornly insist on maintaining absolute referential
transparency in our language, we are forced to eliminate the incremental
top level loop. A program must be constructed monolithically. We must
read in all our procedure definitions at once, close them all together, and
then take one or more shots at running them. (This is the way many Algol
implementations work; development of large systems can be very difficult
if parts cannot be separately constructed and compiled.) We are forced to
give up interactive debugging, because we cannot redefine erroneous</p>

<p>procedures easily. We are forced to give up incremental compilation of
separate modules.
.St’ee1e and Sussman 27 The Art of the Inter rater</p>

<p>we have thrown the baby out with the bath water. The very purpose
of referential transparency is to permit programs to be divided into parts
so that each part can be separately specified without a description of its
implementation. The desirable result is that pieces can be separately
written and debugged. {Note Debugging}</p>

<p>On the other hand, if we give up absolute referential transparency,
we can fix the top level_ loop. The basic problem is that we really want
procedures defined at top l.eve.l to be able to refer to procedures defined
later. The problem with pure lexical scoping is that the apnocaouke-objects
are created too early, when the desired environment is not yet available.
we must arrange for them to be constructed at a later time. We could
simply use the environment in use by the caller at the time of invocation
(reverting to dynamic scoping). But dynamic scoping would lose a great
deal of referential transparency and abstractive power. Procedures must
not be allowed to refer to variables internal to other procedures, but only
to top—1eve1 variables existing at the time they are called. Therefore
only the future top-level environment is to be included in the &amp;PROCEDURE-
object when it is eventually constructed. In this way free variable
references will be dynamic only with respect to the top-level environment.</p>

<p>Considering our dynamically-scoped interpreter above (see Figure
5). we would be led toimodify APPLY again, to combine the best properties
of the dynamically and lexically scoped interpreters. Indeed, the two
kinds of function can easily coexist. We borrow the code involving the
passing of PROCEDURES (including the DRIVER-LOOP, modified to initialize euv to
PROCEDURES) from the recursion-equations interpreter (Figures 1 and 2), the
code for using this top—level environment from the dynamically—scoped
interpreter (Figure 5), and the code for constructing 8-PROCEDURE-Objects for
LAMaoA-expressions from the lexically-scoped interpreter (Figure 7).. The
result appears in Figure 9. ‘
Steele and Sussman ‘ 26 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>J1</strong>___</p>

<p>(DEFINE (EVAL EXP ENv PROCEDURES)
(coND ((ATOM EXP)
(COND ((NUMBERP EXP) EXP)
(T (VALUE EXP ENv))))</p>

<p>((Eo (CAR EXP) ‘QUOTE)</p>

<p>(CADR ExP))
((Eo (cAR EXP) ‘LAMBDA)</p>

<p>(LIST ‘&amp;PROCEDURE (CADR EXP) (CADDR EXP) ENV))
((Eo (CAR EXP) ‘COND)</p>

<p>(EvcoND (CUR EXP) ENv PRocEDuREs))</p>

<p>(T (APPLY (EvAL (CAR EXP) ENv PROCEDURES)</p>

<p>(EvLIs (CUR EXP) ENV PROCEDURES)
PRocEDuREs))))</p>

<p>(DEFINE (APPLY FUN ARGS PRocEDuREs)
(COND ((PRlMOP FUN) (PRIMOP—APPLY run ARGS))
((Eo (CAR run) ‘&amp;PROCEDURE)
(EVAL (cADDR FUN)
(BIND (CADR FUN) ARGS (CADDDR FUN))
PROCEDURES))
(T (EVAL (cADR FUN)
(BIND (cAR FUN) ARGS PRocEouREs)
PRocEDuREs))))</p>

<p>(DEFINE (DRIVER-LooP-I PROCEDURES FORM)
(coND ((AToN FORM)
(DRIVER-LooP PROCEDURES
(PRINT (EVAL FORM PROCEDURES PRocEDuREs))))
((Eo (cAR FORM) ‘DEFlNE)
(DRIVER-LOOP (BIND (LIST (cAADR FORM))
(LIST (LIsT (CDAUR FORM) (CADDR FORM)))
PROCEDURES)
(PRINT (cAADR FORM))))
(T (DRIVER-LooP PROCEDURES
(PRINT (EVAL FORM PROCEDURES PRocEDuREs))))))</p>

<p>For DRIVER-LooP see Figure 1.
For VALUE and BIND see Figure 3.
For EvcoND and EvLIs see Figure 2.</p>

<p>Figure 9
An Evaluator for Local Lexical Scoping
and Dynamic Top-Level References</p>

<p>Ugh bletch, PmmEmmEs is back! Also, there are two kinds of user-
defined procedural objects floating around. There happens to be another
way to fix the top level, which yields additional flavor. We note that
Steele and Sussman 29 The Art of the Inter reter</p>

<p>during any one processing cycle of EVAL/APPLY, PROCEDURES remains constant.
We can thus choose to associate the top level environment with a top-level
procedure at a time earlier than invocation time in APPLY. we also note
that LOOKUPI will have its hands on the top-level environment anyway just
before it locates the definition of a top-level procedure. Exploiting this
idea yields an alternate solution. {Note LABELS}</p>

<p>In the new driver (see Figure 10) loop we no longer use BIND to
augment the top-level environment whenever a new definition is made. We
instead have all of the top-level definitions in one frame of the
environment. when a new definition is to be made we extract the list of
names and the list of values for the old definitions from the old
environment and make a new top—leve1 environment with the lists of names
and values separately augmented.</p>

<p>Instead of creating aprzocwune-objects, this driver loop creates
&amp;LABELED-Objects, which have the same format except that they contain no
environment. A a.LAB£LEo—object is purely internal and can never be seen by
a user program. when LOOKUPI encounters such an object as the value of a
variable, it immediately creates the corresponding apnoceounrobject, using
the environment a-t hand, which turns out to be the top-level environment.
Stee1e and Sussman 30 The Art of the Inter reter
<strong>__<em>.</em></strong><strong>__</strong><strong>i</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__.</strong><strong>__</strong><strong>__</strong><strong>__JL</strong>__</p>

<p>(DEFINE (DRIVER—LO0P-1 ENV roan)
(cono ((ATOM FORM)
(DRIVER-LOOP ENV (PRINT (EVAL FORM ENV))))
((50 (CAR FORM) ‘DEFlNE)
(DRIVER-LOOP (LIST (cons (cons (CAADR FORM) (CAAR ENV))
(cons (LIST ‘&amp;LABELEO
(CDADR roan)
(CADUR FORM))
(CDAR ENV))))
(PRINT (CAADR FORM))))
(T (DRIVER-LOOP ENV (PRINT (EVAL roan euv))))))</p>

<p>(DEFINE (LOOKUP1 NAME VARS VALS ENV)
(couo ((NULL VARS)
(LOOKUP NAME (con ENV)))
((50 NAME (CAR VARS)) 4
(COND ((ATOM (CAR VALS)) VALS)</p>

<p>((50 (CAAR VALS) ‘&amp;LABELED)
(LIST ‘&amp;PROCEDURE (CADAR VALS) (CADDAR VALS) euv))
(T VALS)))</p>

<p>(T (LOOKUPI NAME (CDR VARS) (COR VALS) ENV))))</p>

<p>_ For DRIVERJDOP see Figure 1.
For LOOKUP see Figure 3.
For EVAL see Figure 7.</p>

<p>Figure 10
An Alternative Solution for Local Lexical Scoping
and Dynamic Top-Level References
(Modified Top—Leve1 Driver Loop and Environment Lookup)
Steele and Sussman 31 The Art of the Inter reter
<strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__</strong><strong>__JL</strong>__</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Art of Interpreter: Part Zero]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-part-0/"/>
    <updated>2015-08-18T16:52:51+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-part-0</id>
    <content type="html"><![CDATA[<h3 id="lisp">第零部分： LISP和解释器</h3>
<p>Part Zero 
LISP and Interpreters</p>

<h4 id="section">递归方程</h4>
<p>Recursion Equations</p>

<p>Contrary to popular belief, LISP was not originally derived from
Church’s λ—calculus [Church] [LISP History]. The earliest LISP did not
have a well—defined notion of free variables or procedural objects. Early
LISP programs were similar to recursion equations, defining functions on
symbolic expressions (“S—expressions”). They differed from the equations
of pure recursive function theory [Kleene] by introducing the conditional
expression construction (often called the “McCarthy conditional”), to avoid
“pattern-directed invocation”. That is, in recursive function theory one
would define the factorial function by the following two equations:</p>

<p>与流行的说法相反，LISP最初不是从邱奇的λ演算中派生出来的。最早的LISP没有一个对自由变量和过程对象的良好定义的记号。早期的LISP程序与递归方程类似，在符号表达式(“S-expressions”)上定义函数。他们不同于纯粹递归函数理论公式，是在于引入了条件表达式构造(经常称为”McCarthy条件”)，从而避免“模式导向的调用”。也就是，在递归函数理论中，可以通过如下两个方程定义阶乘函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factorial</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="nb">=</span> <span class="mi">1</span>
</span><span class="line"><span class="nv">factoria1</span><span class="p">(</span><span class="nv">successor</span><span class="p">(</span><span class="nv">x</span><span class="p">))</span> <span class="nb">=</span> <span class="nv">successor</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span> <span class="nb">*</span> <span class="nv">factorial</span><span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>In early LISP, however, one would have written:</p>

<p>但是在早期的LISP中，需要写成这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factoria1[x]</span> <span class="nb">=</span> <span class="nv">[x=0</span> <span class="nv">-&gt;</span> <span class="mi">1</span><span class="c1">; T -&gt; x*factorial[x-1]]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>where “[a -&gt; b; T —&gt; c]” essentially means “if a then b else c”. The
recursive function theory version depends on selecting which of two
equations to use by matching the argument to the left-hand sides (such a
discipline is actually used in the PROLOG language [Warren]); the early
LISP version represents this decision as a conditional expression.</p>

<p>这里 [a -&gt; b; T —&gt; c] 根本上意指 “如果a就b，或者c”。这个递归函数理论的版本在于，通过将参数匹配到左侧(这样的规则的确在PROLOG语言中用到)，来选择要使用哪个公式；早期的LISP版本将这个决策表示为一个条件表达式。</p>

<p>The theory of recursion equations deals with functions over the
natural numbers. In LISP, however, one is interested in being able to manipulate algebraic expressions, programs, and other symbolic expressions
as data structures. While such expressions can be encoded as numbers
(using the technique of “arithmetization” developed by Kurt Godel), such an
encoding is not very convenient. Instead, a new kind of data called “S-
expressions” .(for “symbolic expressions”) is introduced specifically to
provide convenient encodings. S-expressions can be defined by a set of
formal inductive axioms analogous to the Peano Postulates used to define
natural numbers. Here we will give only an informal and incomplete definition of S—expressions; for a more complete description, see {Note S-
expression Postulates and Notation}.</p>

<p>递归公式处理自然数的函数。然而，在LISP里，人们的兴趣在于能够操作代数表达式、程序和如数据结构一样的符号表达式。虽然这样的表达式能用数字编码(使用Kurt Godel开发的”算术化“技术)，但这样的编码不是很方便。相反，一种称为”S表达式“(即：符号化表达式, symbolic expression)的新的类型的数据被特别引入进来，为了提供方便的编码。S-表达式能通过一组正规的归纳公理来定义，它与Peano假定用以定义自然数的类似。这里，我们仅给出一个非正规和不完备的S表达式定义；对于一个更为完备的描述，请看注释{Note S-
expression Postulates and Notation}。</p>

<p>For our purposes we will need only the special cases of S-expressions called atoms and lists. An atom is an “indivisible” data object, which we denote by writing a string of letters and digits; if only digits are used, then the atom is considered to be a number. Many special characters such as “-“ and “+” are considered to be letters; we will see below that it is not necessary to specially reserve them for use as operator symbols. A list is a (possibly empty) sequence of S—expressions, notated by writing the S—expressions in order, between a set of parentheses and separated by spaces. A list of the atoms “F00”, “43”, and “BAR” would be written “(F00 43 BAR)”. Notice that the definition of a list is
recursive. For example,</p>

<p>对于我们的目的，我们只需要S表达式特殊的情形，称为atom和list。一个“原子”是不可分割的数字对象，我们表示为字母和数字的串；如果只用到数字，那么原子就被认为是数字。许多特殊的字符，比如”-“和”+“，被认为是字母；我们将在后面看到，没有必要特别地将它们保留下来作为操作符号。一个列表是S表达式的序列(可能是空的)，表示为按顺序写S表达式，用空格分开，在一组括号中间。原子”F00”, “43”和”BAR”的列表写为”(FOO 43 BA)”。注意列表的定义是递归的。例如：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">SECOND</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CAR</span> <span class="p">(</span><span class="nv">CUR</span> <span class="nv">X</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>is a list of three things: the atomic symbol DEFINE, a list of the two
atomic symbols SECOND and X, and another list of two other things.</p>

<p>是有3个事物的列表：原子符号 DEFINE，一个有两个原子符号SECOND和X的列表，和另一个列表，它包含两个其它事物。</p>

<p>We can use S-expressions to represent algebraic expressions by
using “Cambridge Polish” notation, essentially a parenthesized version of
prefix Polish notation. Numeric constants are encoded as numeric atoms;
variables are encoded as non—numeric atoms (which henceforth we will call
atomic symbols); and procedure invocations are encoded as lists, where the
first element of the list represents the procedure and the rest represent
the arguments. For example, the algebraic expression “a<em>b+c</em>d” can be
represented as “(+ (* a b) (* c d))”. Notice that LISP does not need the
usual precedence rules concerning whether multiplication or addition is
performed first; the parentheses explicitly define the order. Also, all
procedure invocations have a uniform syntax, no matter how many arguments
are involved. Infix, superscript, and subscript notations are not used;
thus the expression “$J_p (x^2+1)$” would be written “(J p (+ (^ x 2) 1))”.</p>

<p>我们通过使用”剑桥波兰“记号来表示代数表达式，它本质上是加括号的前缀波兰版本。数字常数被编码为数字原子；变量被编码为非数字的原子(今后我们将称其为原子符号)；一个过程的调用被编码为列表，其中列表的第一个元素代表过程，剩余的部分代表参数。例如，代数表达式”a<em>b+c</em>d”可以表示为”(+ (* a b) (* c d))”。注意LISP不需要通常的优先级规则，比如先执行乘法还是加法；括号已经显式地定义了次序。而且，所有的过程调用有一致的语法，无论有多少个参数。没有用到，中缀、上标或下标：因此表达式”$J_p (x_2+1)$”，将被写成”(J p (+ (^ x 2)1))”。</p>

<p>To encode a conditional expression：</p>

<p>为了编码一个条件表达式：</p>

<script type="math/tex; mode=display">[p_1 -> e_1; p_2 -> e_2; ... ; p_n -> e_n]</script>

<p>(which means to evaluate the predicates p_i in order until a true one is found, at which point the value of $e_j$ is taken to be the value of the
conditional) we write the S-expression</p>

<p>其含义是对判定式p_i按顺序求值，直到发现一个为真，此时$e_j$会被取出作为条件的值。我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">COND</span> <span class="p">(</span><span class="nv">p_1</span> <span class="nv">e_1</span><span class="p">)</span> <span class="p">(</span><span class="nv">p_2</span> <span class="nv">e_2</span><span class="p">)</span> <span class="o">...</span> <span class="p">(</span><span class="nv">p_n</span> <span class="nv">e_n</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we can now encode sets of LISP recursion equations as S-expressions. For the equation</p>

<p>我们能将一组LISP递归等式编码为S表达式的形式。对于等式：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nv">factoria1[x]</span> <span class="nb">=</span> <span class="nv">[x=0</span> <span class="nv">-&gt;</span> <span class="mi">1</span><span class="c1">; T -&gt; x*factoria1[x-1]]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>we write the S-expression</p>

<p>我们将S表达式写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">	<span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nb">=</span> <span class="nv">X</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span>
</span><span class="line">		  <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(we could also have written</p>

<p>(我们也能写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">=</span>
</span><span class="line"><span class="nv">x</span> <span class="mi">0</span><span class="p">)</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">FACTORIAL</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">x</span>
</span><span class="line"><span class="mi">1</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>but we conventionally lay out S-expressions so that they are easy to read.)</p>

<p>但是我们习惯上会排版S表达式以便易于阅读。</p>

<p>We now have a complete encoding for algebraic expressions and LISP
recursion equations in the form of S-expressions. Suppose that we now want
to write a LISP program which will take such an S-expression and perform
some useful operation on it, such as determining the value of an algebraic
expression. We need some procedures for distinguishing, decomposing, and
constructing S-expressions.</p>

<p>我们现在已经有了对代数表达式的完整编码，以及S表达式的形式下的递归等式。假设我们现在想写一个LISP程序，它能拿起这样的S表达式并对其执行一些有用的操作，比如确定代数表达式的值。我们需要一些过程来区分、分解、构造S表达式。</p>

<p>The predicate ATOM, when applied to an S-expression, produces true
when given an atom and false otherwise. The empty list is considered to be
an atom. The predicate NULL is true of only the empty list; its argument
need not be a list, but may be any S-expression. The predicate NUMBERP is
true of numbers and false of atomic symbols and lists. The predicate EQ,
when applied to two atomic symbols, is true if the two atomic symbols are
identical. It is false when applied to an atomic symbol and any other S-
expression. (We have not defined EQ on two lists yet; this will not
become important, or even meaningful, until we discuss side effects.)</p>

<p>断言ATOM，当应用到S表达式上，如果给的是原子，则产生真，否则为假。空列表被认为是一个原子。断言NULL只有对空列表是为真；它的参数不必要是列表，可以是任何表达式。当一个原则符号和列表是数字时，断言NUMBERP是真，否则为假。断言EQ，当应用到两个原子符号时，如果两个原子符号相等，则为真。如果应用到一个原子符号，和任何其他S表达式上，则为假。(我们还没有定义两个列表的EQ；这将不那么重要，或甚至有意义，直到我们讨论副作用。)</p>

<p>The decomposition operators for lists are traditionally called CAR
and CDR for historical reasons. [LISP History] CAR extracts the first
element of a list, while CDR produces a list containing all elements but
the first. Because compositions of CAR and CDR are commonly used in LISP,
an abbreviation is provided: all the C’s and R’s in the middle can be
squeezed out. For example, ‘(CDR (CDR (CAR (CDR X))))’ can be written as
“(CDDADR X)”.</p>

<p>由于历史的原因，列表的分解操作符传统上被称为car和cdr。[LISP History] CAR提取列表的第一个元素，而CDR生成一个除过第一个元素之外的所有剩余元素的列表。因为car和cdr的组合在LISP中经常用到，就提供了一个缩写：所有中间的C和R可以积压出去。例如’(CDR (CDR (CAR (CDR X))))’，可以写为”(CDDADR X)”。</p>

<p>The construction operator CONS, given an S-expression and a list,
produces a new list whose CAR is the S-expression and whose CDR is the
list. The operator LIST can take any number of arguments (a special
feature), and produces a list of its arguments.</p>

<p>构造操作符CONS，给定S表达式和一个列表，生成一个新的列表，其CAR是S表达式，而CDR是列表。操作符LIST能接收任意数目的参数(一个特殊特性)，然后产生这些参数的列表。</p>

<p>We can now write some interesting programs in LISP to deal with S-expressions. For example, we can write a predicate EQUAL, which determines whether two S-expressions have the same CAR-CDR structure:</p>

<p>我们现在可用LISP写一些有趣的程序，来处理S表达式。例如，我们写一个断言EQUAL, 它确定两个S表达式有相同的CAR-CDR结构。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">X</span><span class="p">)</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">Y</span><span class="p">)</span> <span class="p">(</span><span class="nb">=</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                       <span class="p">(</span><span class="no">T</span> <span class="no">NIL</span><span class="p">)))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">EQ</span> <span class="nv">X</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">Y</span><span class="p">)</span> <span class="no">NIL</span><span class="p">)</span>
</span><span class="line">                <span class="p">((</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">Y</span><span class="p">))</span>
</span><span class="line">                 <span class="p">(</span><span class="nv">EQUAL</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">X</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">Y</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Here we have used the standard names T and NIL to represent ture and false.
(Traditionally NIL is also considered to be the empty list, but we will
avoid this here, writing “()” for the empty list.)</p>

<p>这里我们使用标准的名字T和NIL来表示和false。(传统上，NIL也被认为是空列表，但是我们将在这里避免这些，写”()”代表空列表)。</p>

<p>Because LISP programs are represented as LISP data structures (S-expressions), there is a difficulty with representing constants. For
example, suppose we want to determine whether or not the value of the
variable X is the atomic symbol “FOO”. we might try writing:</p>

<p>因为LISP程序表示为LISP数据结构(S表达式)，在表达常量时有些困难。比如，假设我们想确定变量X的值是否为原子符号”F00”，我们可能试图写为：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQ</span> <span class="nv">X</span> <span class="nv">FOO</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>This doesn’t work. The occurrence of “FOO” does not refer to the atomic
symbol FOO as a constant; it is treated as a variable, just as “X” is.</p>

<p>这不能奏效。FOO的出现没有将FOO引用为一个常量；它被看做一个变量，如同X一样。</p>

<p>The essential problem is that we want to be able to write any 5-
expression as a constant in a program, but some S—expressions must be used
to represent other things, such as variables and procedure invocations. To
solve this problem we invent a new notation: (QUOTE X) in a program
represents the constant S-expression x. {Note QUOTE Mapping} Thus we can
write our test as “(EQ X (QUOTE FOO)”. Similarly,</p>

<p>本质的问题是，我们想能够在程序中将任何S表达式按照常量的方式书写，但是一些S表达式必须被用来表示其它一些，比如变量和过程调用。为了解决这个问题，我们发明了一个新记号：(QUOTE X)在程序中表示常数S表达式X。{注释： QUOTE Mapping} 因此我们能将我们的测试写为：(EQ X (QUOTE FOO)。类似的：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">Y</span> <span class="nv">Z</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>constructs a list from the values of Y and z, and compares the result to
the value of X, while</p>

<p>从X和Y的值中构造一个列表，然后将结果与X的值比较，而：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">EQUAL</span> <span class="nv">X</span> <span class="p">(</span><span class="nv">QUOTE</span> <span class="p">(</span><span class="nv">LIST</span> <span class="nv">Y</span> <span class="nv">Z</span><span class="p">)))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>compares the value of X to the constant S-expression “(LIST Y Z)”. Because
the QUOTE construction is used so frequently in LISP, we use an abbreviated
notation: “‘FOO” is equivalent to “(QUOTE FOO)”. This is only a notational
convenience; the two notations denote the same S-expression. (S-
expressions are not character strings, but data objects with a certain
structure. We use character strings to notate S-expressions on paper, but
we can use other notations as well, such as little boxes and arrows. We 
can and do allow several different character strings to denote the same S-
expression.) </p>

<p>将X的值与常数表达式(LIST Y Z)去比较。因为在LISP中QUOTE构造经常被用到，我们使用一个缩写记号：”’FOO”等价于”(QUOTE FOO)”。这只是一个记号的惯例。两个记号表示相同的S表达式。(S表达式不是字符串，而是带有特定结构的数据对象。我们使用字符串去表示文章中的S表达式。我们能够且也允许几种不同的字符串去表示相同的S表达式)。</p>

<h4 id="lisp-">LISP 递归等式的解释器</h4>
<p>An Interpreter for LISP Recursion Equations</p>

<p>We now have enough machinery to begin our examination of the
genetic history of LISP. We first present a complete interpreter for LISP
recursion equations. The language interpreted is a dialect of LISP which
allows no free variables except for names of primitive or defined
procedures, and no definitions of procedures within other procedures.</p>

<p>我们现在有足够的机制去开始对LISP起源历史的检视。我们首先展现一个LISP递归等式的完全解释器。被解释的语言是LISP的一个方案，它不允许自由变量，除过原语或已定义过程的名字，在别的过程中没有过程的定义。</p>

<p>The driver loop reads in definitions of procedures of the form:</p>

<p>驱动循环的读取 form的过程定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">F</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">...</span><span class="p">)</span> <span class="nv">&lt;expression</span> <span class="nv">in</span> <span class="nv">A</span> <span class="nv">B</span> <span class="nv">C</span> <span class="o">...</span> <span class="nb">and</span> <span class="nv">F</span> <span class="nv">G</span> <span class="nv">H</span> <span class="o">...</span><span class="nb">&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>and saves them. It can also read in requests to apply some defined
procedure to some arguments (or, more generally, to evaluate any
expression), in which case it prints the resulting value. An expression
may consist of variable references, constants (numbers and quoted s-
expressions), procedure calls, and conditional expressions (COND). The
defined procedures may refer to each other and to initially supplied
primitive procedures (such as CAR, CONS, etc.). Definitions may contain
“forward references”, as long as all necessary definitions are present at
the time of a request for a computation. The interpreter itself is
presented here as a set of such definitions, and so is meta—circular.</p>

<p>并保存它们。它也能读入请求去将一些定义的过程应用到一些参数(或者，更通常，去求值任意表达式)，在这种情况下它打印结果值。一个表达式可以包含变量引用，常数(数字和引号的S-表达式)，过程调用和条件表达式。被定义的过程可能相互引用，并引用到初始提供的原语过程(比如CAR, CONS，等等)。定义可能包括“向前引用”，只要所有必须的定义在请求计算的那一刻是存在的。这呈现的解释器自身是一组如此的定义，也就是元循环。</p>

<p>The language is intended to be evaluated in applicative order; that is, all arguments to a procedure are fully evaluated before an attempt
is made to apply the procedure to the arguments. (It is necessary to state
this explicitly here, as it is not inherent in the form of the meta-circular definition. See [Reynolds] for an explication of this problem.)</p>

<p>语言打算被按应用的次序去求值；也就是，对一个过程所有的参数都被完全求值之后，才试图将过程应用到参数上。(有必要在这里这里显式地说，这不是元循环定义的形式本自具有的。看[Reynolds]对这个问题的解释。)</p>

<p>The driver loop (see Figure 1) is conceptually started by a request
to invoke DRIVER with no arguments. Its task is to first print the message
“LITHP ITH LITHTENING” (a tradition of sorts) and then invoke DRIVER—LOOP.
The expression <the-primitive-procedures> is intended to represent a constant
list structure, containing definitions of primitive procedures, to be supplied to DRIVER—LOOP.</the-primitive-procedures></p>

<p>驱动循环(看图1)是概念性第启动，通过请求不带参数的调用DRIVER。它的任务首先是打印消息“”LITHP ITH LITHTENING”，然后调用DRIVER-LOOP。表达式<the-primitive-procedures>目的是打印一个常量列表结构，包含原语过程的定义，以便提供给DRIVER—LOOP。</the-primitive-procedures></p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">&lt;THE-PRIMITIVE</span><span class="err">—</span><span class="nv">PROCEDURES&gt;</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="ss">&#39;|LITHP ITH LITHTENlNG|</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span> <span class="nv">PROCEDURES</span> <span class="nv">HUNOZ</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">DRIVER</span><span class="err">—</span><span class="nv">LOOP</span><span class="err">—</span><span class="mi">1</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">READ</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">DRIVER-LOOP-1</span> <span class="nv">PROCEDURES</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">FORM</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="o">&#39;</span><span class="p">()</span> <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="ss">&#39;DEFINE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))</span>
</span><span class="line">                                  <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">LIST</span> <span class="p">(</span><span class="nv">CDADR</span> <span class="nv">FORM</span><span class="p">)</span> <span class="p">(</span><span class="nv">CADDR</span> <span class="nv">FORM</span><span class="p">)))</span>
</span><span class="line">                                  <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                            <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">CAADR</span> <span class="nv">FORM</span><span class="p">))))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">DRIVER-LOOP</span> <span class="nv">PROCEDURES</span> <span class="p">(</span><span class="nv">PRINT</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">FORM</span> <span class="o">&#39;</span><span class="p">()</span> <span class="nv">PROCEDURES</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>
Figure 1
<br />
Top Level Driver Loop for a Recursion Equations Interpreter
</center>

<p>DRIVER-LOOP reads an S—expression from the input stream and passes
it, along with the current procedure definitions, to DRIVER-LOOP-1. This
procedure in turn determines whether the input S-expression is a definition. If it is, then it uses amp (described below) to produce an augmented set of procedure definitions, prints the name of the defined procedure, and calls DRIVER-LOOP to repeat the process. The augmented set of procedures is passed to DRIVER-LOOP, and so the variable PROCEDURES always contains all the accumulated definitions ever read. If the input S-expression is not a definition, then it is given to the evaluator EVAL, whose purpose is to determine the values of expressions. {Note Value Quibble} The set of currently defined procedures is also passed to EVAL.</p>

<p>DRIVER-LOOP 从输入流读一个S表达式，然后将它，连同当前的过程定义，给DRIVER-LOOP-1。这个过程然后确定输入的S表达式是否是一个定义。如果是，则它利用amp(下面描述)来产生一个过程定义的扩充集，打印定义所定义过程的名字，然后调用DRIVER-LOOP来重复过程。扩充的过程集被传输给DRIVER-LOOP，从而变量PROCEDURES总是包含所有曾经读取的累计的定义。如果输入的S表达式不是一个定义，那么它会交给求值器eval，其目的是确定变量的值。{注释：Value Quibble} 当前所定义的过程集也会传输给EVAL。</p>

<p>The process carried on by the driver loop is often called the “top
level”; all user programs and requests are run‘ “under” it. The growing set of procedure definitions is called the “top—level environment”; this environment changes in the course of the user interaction, and contains the state of the machine as perceived by the user. It is within this environment that user programs are executed. </p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
<span class="line-number">22</span>
<span class="line-number">23</span>
<span class="line-number">24</span>
<span class="line-number">25</span>
<span class="line-number">26</span>
<span class="line-number">27</span>
<span class="line-number">28</span>
<span class="line-number">29</span>
<span class="line-number">30</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="nv">EXP</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">ATOM</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">EQ</span> <span class="nv">EXP</span> <span class="ss">&#39;NIL</span><span class="p">)</span> <span class="ss">&#39;NIL</span><span class="p">)</span>
</span><span class="line">                     <span class="p">((</span><span class="nv">EQ</span> <span class="nv">EXP</span> <span class="ss">&#39;T</span><span class="p">)</span> <span class="ss">&#39;T</span><span class="p">)</span>
</span><span class="line">                     <span class="p">((</span><span class="nv">NUMBERP</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">EXP</span><span class="p">)</span>
</span><span class="line">                     <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">EXP</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;QUOTE</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CADR</span> <span class="nv">EXP</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="ss">&#39;COND</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                        <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">EXP</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                        <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">PRIMOP</span> <span class="nv">FUN</span><span class="p">)</span> <span class="p">(</span><span class="nv">PRIMOP-APPLY</span> <span class="nv">FUN</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADR</span> <span class="nv">FUN</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">BIND</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">FUN</span><span class="p">)</span> <span class="nv">ARGS</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">                       <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="nv">CLAUSES</span> <span class="nv">ENV</span> <span class="nv">PROCEDURED</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">               <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CADAR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">EVCOND</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">CLAUSES</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">EVLIS</span> <span class="nv">ARGLIST</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">EVAL</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)</span>
</span><span class="line">                       <span class="p">(</span><span class="nv">EVLIS</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">ARGLIST</span><span class="p">)</span> <span class="nv">ENV</span> <span class="nv">PROCEDURES</span><span class="p">)))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>                    
Figure 2
<br />
Evaluator for a Recursion Equations Interpreter
</center>

<p>The evaluator proper (see Figure 2) is divided into two conceptual
components: EVAL and APPLY. EVAL classifies expressions and directs their
evaluation. Simple expressions (such as constants and variables) can be
evaluated directly. For the complex case of procedure invocations
(technically called “combinations”), EVAL looks up the procedure
definition, recursively evaluates the arguments (using EVLIS), and then
calls APPLY. APPLY classifies procedures and directs their application.
Simple procedures (primitive operators) are applied directly. For the
complex case of user-defined procedures, APPLY uses BIND to build an
environment, a kind of symbol table, associating the formal parameters from
the procedure definition with the actual argument values provided by EVAL.
The body of the procedure definition is then passed to EVAL, along with the
environment just constructed, which is used to determine the values of variables occurring in the body.</p>

<p>求值器章节(见图2)被分为两概念部分：EVAL和APPLY。EVAL 将表达式分类并引导他们的求值。简单的表达式(比如常量和变量)能直接求值。对于过程调用这样复杂的情形(技术上称为“组合”)，EVAL查找过程定义，递归地对参数求值(使用EVLLIS)，然后调用APPLY。APPLY区分过程，然后引导它们的应用。简单的过程(原语过程)，被直接应用。对于用户所定义过程这样复杂的情形，APPLY使用BIND来构造一个环境，一种符号表，将来自过程定义的正规参数与EVAL所提供的真实参数值关联起来。然后，过程定义体连同构造的环境，被传给EVAL，这个环境用以确定函数体中出现的变量值。</p>

<p>In more detail, EVAL is a case analysis on the structure of the S-
expression EXP. If it is an atom, there are several subcases. The special
atoms T and NIL are defined to evaluate to T and NIL (this is strictly for
convenience, because they are used as truth values). Similarly, for
convenience numeric atoms evaluate to themselves. (These cases could be
eliminated by requiring the user to write lots of QUOTE forms: ‘T, ‘NIL,
‘43, etc. This would have been quite inconvenient in early LISP, before
the “’” notation had been introduced; one would have had to write (QUOTE
43), etc.) Atomic symbols, however, encode variables; the value
associated with that symbol is extracted from the environment ENV using the
function VALUE (see below).</p>

<p>说的更详细一些，EVAL是对S表达式EXP的结构的情形分析。如果它是一个原子，会有几种子情况。特别的原子T和NIL被定义，以便求值出T和NIL(严格说，这是为了方便，因为它们被当真值使用)。类似地，为了方便，数值的原子被定义求值为它们自己。(这种情况可以省掉，通过要求用户写大量的QUOTE forms： ‘T, ‘NIL, ‘43 等等。在”&#8217;”记号被引入之前，这在早期的LISP中很不方便；一个人不得不 (QUOTE 43)，等等) 但是，原子符号编码了变量；使用函数VALUE，把与符号关联的值从环境ENV中提取出来(见下)。</p>

<p>If the expression to be evaluated is not atomic, then it may be a
QUOTE form, a COND form, or a combination. For a QUOTE form, EVAL extracts
the S-expression constant using CADR. Conditionals are handled by EVCOND,
which calls EVAL on a predicate expression; if the predicate is true,
EVCOND evaluates the corresponding result expression (by calling EVAL, of course); if the predicate is false, EVCOND calls itself to test the predicate of the next clause of the COND body. For combinations, the procedure is obtained, the arguments evaluated (using EVLIST), and APPLY called as described earlier. Notice that VALUE is used to get the procedure definition from the set PROCEDURES; we can do this because, as an engineering trick, we arrange for ENV and PROCEDURES to have the same structure, because they are both symbol tables.</p>

<p>如果被求值的表达式不是原子的，那么它可能是一个QUOTE form，一个COND form，或者一个组合。对一个QUOTE form, EVAL使用CADR提取S表达式的常熟。条件语句由EVCOND处理，它在一个判定表达式上调用EVAL；如果判定是真的，EVCOND对相应的结果表达式求值(当然，通过调用EVAL)；如果判定式为假，EVCOND调用自身去测试COND 主体中下一个子句的判定式。对于组合，先得到过程，然后对参数求值(使用EVLIST)，然后如前面所描述那样调用APPLY。注意VALUE被用以从集合PROCEDURES中得到变量定义；我们可以这么做，是因为作为工程的技巧，我们组织ENV和PROCEDURES让他们有相同的结构，因为它们都是符号表。</p>

<p>EVLIS is a simple recursive function which calls EVAL on successive arguments in ARGLIST and produces a list of the values in order. </p>

<p>EVLIS是个简单的函数，它对ARGLIST中相继的参数调用EVAL，然后顺序产生值的列表。</p>

<p>APPLY distinguishes two kinds of procedures: primitive and user-defined. For now we avoid describing the precise implementation of primitive procedures by assuming the existence of a predicate PRIMOP which is true only of primitive procedures, and a function PRIMOP-APPLY which deals with the application of such primitive procedures. (See {Note Primitive Operators} for the details of a possible implementation of PRIMOP and PRIMOP-APPLY.) We consider primitive procedures to be a kind of atomic S-expression other than numbers and atomic symbols; we define no particular written notation for them here. However, primitive procedures are not to be confused with the atomic symbols used as their names. The result of (VALUE ‘CAR PROCEDURES) is not the atomic symbol CAR, but rather some bizarre object which is meaningful only to PRIMOP-APPLY.</p>

<p>APPLY区分两种类型的过程：原语和用户定义。迄今我们避免描述原语过程的准确定义，通过假设存在一个判定式PRIMOP，它只对原语过程为真，同时有一个函数PRIMOP-APPLY，它处理如此原语过程的应用。(参看 {Note Primitive Operators} 详细了解PRIMOP和PRIMOP-APPLY的可能实现的细节。) 我们认为原语过程是一类原子表达式，而非数字或原子符号；我们这里为她们诶有定义特别的书写记号。但是，原语过程不能与使用它们名字的原子符号混淆。(VALUE ‘CAR PROCEDURES)的结果不是原子符号CAR，而是有些奇怪的对象，它只对PRIMOP-APPLY有意义。</p>

<p>User-defined procedures are represented here as lists. These lists are constructed by DRIVER-LOOP-1. The car of the list is the list of formal parameters, and the cadr is the body of the definition.</p>

<p>用户定义的过程在这里用列表表示。这些列表通过DRIVER-LOOP-1构造。list的car部分，是正规参数的列表，而cadr部分是过程定义的主体。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">BIND</span> <span class="nv">VARS</span> <span class="nv">ARGS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nb">=</span> <span class="p">(</span><span class="nv">LENGTH</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">LENGTH</span> <span class="nv">ARGS</span><span class="p">))</span>
</span><span class="line">               <span class="p">(</span><span class="nv">CONS</span> <span class="p">(</span><span class="nv">CONS</span> <span class="nv">VARS</span> <span class="nv">ARGS</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">VALUE</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">VALUEI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">VALUEI</span> <span class="nv">NAME</span> <span class="nv">SLOT</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">EQ</span> <span class="nv">SLOT</span> <span class="ss">&#39;&amp;UNBOUND</span><span class="p">)</span> <span class="p">(</span><span class="nv">ERROR</span><span class="p">))</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">SLOT</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">ENV</span><span class="p">)</span> <span class="ss">&#39;&amp;UNBOUND</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CAAR</span> <span class="nv">ENV</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDAR</span> <span class="nv">ENV</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span><span class="line">
</span><span class="line"><span class="p">(</span><span class="nv">DEFINE</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="nv">VARS</span> <span class="nv">VALS</span> <span class="nv">ENV</span><span class="p">)</span>
</span><span class="line">        <span class="p">(</span><span class="nv">COND</span> <span class="p">((</span><span class="nv">NULL</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">LOOKUP</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">ENV</span><span class="p">)))</span>
</span><span class="line">              <span class="p">((</span><span class="nv">EQ</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CAR</span> <span class="nv">VARS</span><span class="p">))</span> <span class="nv">VALS</span><span class="p">)</span>
</span><span class="line">              <span class="p">(</span><span class="no">T</span> <span class="p">(</span><span class="nv">LOOKUPI</span> <span class="nv">NAME</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">VARS</span><span class="p">)</span> <span class="p">(</span><span class="nv">CDR</span> <span class="nv">VALS</span><span class="p">)</span> <span class="nv">ENV</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<center>
Figure 3
<br />
Utility Routines for Maintaining Environments
</center>

<p>The interpreter uses several utility procedures for maintaining
symbol tables (see Figure 3). A symbol table is represented as a list of
buckets; each bucket is a list whose car is a list of names and whose cdr
is a list of corresponding values. {Note This ain’t A—lists} If a variable
name occurs in more than one bucket, the leftmost such bucket has priority;
in this way new symbol definitions added to the front of the list can
supersede old ones.</p>

<p>解释器使用几个工具过程来维护符号表(见图3)。一个符号表被表示为桶的列表；每个桶也是个列表，其car是列表的名字，而cdr是对应值的列表。{Note This ain’t A—lists} 如果一个变量名出现在多个桶，最左边的桶优先；新的符号定义添加到符号的前端，按照这个方式，旧的会被取代。</p>

<p>BIND takes a list of names, a list of values, and a symbol table,
and produces a new symbol table which is the old one augmented by an extra
bucket containing the new set of associations. (It’s also performs a useful
error check —- LENGTH returns the length of a list.)</p>

<p>BIND 获得一个名字的列表，一个值的列表，一个符号表，然后将旧的符号表扩展一个桶，桶里包含关联的新集合，由此产生一个新的符号表。(它也执行一个有用的错误检查 —- LENGTH 返回列表的长度)</p>

<p>VALUE is essentially an interface to LOOKUP. We define it because later, in Part Three, we will want to use different versions of VALUE1 without changing the underlying algorithm in LOOKUP. The check for &amp;UNBOUND catches incorrect references to undefined variables.</p>

<p>VALUE 本质上是LOOKUP的接口。我们随后在第三部分定义它，我们将想使用不同版本的VALUE1，而不改变LOOKUP的基础算法。 对 &amp;UNBOUND 的检查捕获对未定义变量的不正确的引用。 </p>

<p>LOOKUP takes a name and a symbol table, and returns that portion of a bucket whose car is the associated value. (This definition will be more useful later than one in which the value itself is returned.)</p>

<p>LOOKUP 取得一个名字和一个符号表，然后返回桶的一部分，其car是关联的值。(这个定义随后将比返回值本身更加重要)</p>

<p>Note carefully the use of the variable PROCEDURES in the
interpreter. When DRIVER-LOOP-1 calls EVAL it passes the current list of
defined procedures (both primitive and user-defined). DRIVER-LOOP-1 is the
only routine which augments the value of PROCEDURES, and this value is only
used in EVAL, when it is passed to VALUE. However, <u>all</u> of the routines
APPLY, EVCOND, and EVLIS have to know about PROCEDURES, and dutifully pass it
along so that it may be eventually used by EVAL. The set of definitions
must be passed along because there is no provision for free variables or
side effects; there is no way to have “memory” or “state” other than in
passed variables. The absence of free variables effectively causes our
language to be referentially transparent. However, we sense a disturbing
lack of modularity in the use of PROCEDURES (and, to a lesser extent, in the
use of ENV — look at EVCOND and EVLIS). We will return to this point later.</p>

<p>仔细地注意在解释器中使用变量PROCEDURES。当DRIVER-LOOP-1调用EVAL，它传入所定义过程的当前列表(既有原语的，也有用户定义的)。DRIVER-LOOP-1 是唯一例程，它扩展PROCEDURES的值，并且这个值只在EVAL中使用，当它被传给VALUE时。但是，所有例程APPLY, EVCOND, EVLIS都必须知道PROCEDURES, 并尽责地顺延传递它，从而它可能最终被EVAL用到。定义的集合必须被顺延传递，因为对自由变量或副作用没有预先准备; 也没有方法去有“内存”或“状态”，除了在传递的变量中。缺少自由变量实际上致使我们的语言是引用透明的。但是，我们感觉到在PROCEDURES中缺少模块化的一种不安(并且，在较小的程度，在ENV的使用中 — 看看EVCOND和EVLIS)。我们后面再回到这个话题。</p>

<p>Our recursion equations language has no special iteration or
looping constructs, such as the Algol <u>for</u> statement or the FORTRAN DO loop.
All loops are constructed by arranging for recursive procedures to call
themselves or each other. For example, EVCOND (see Figure 2) iterates over
the clauses of a COND by calling itself on successive “tails” of the list
of clauses. Now such recursive calls may strike the reader familiar with
other languages (such as Algol, FORTRAN, PL/I, etc.) on an intuitive level
as being rather inefficient for implementing real programs. Even granted
that calls might be made fast, they would seem to consume space in the form
of return addresses and other control information. Examination of the
recursion equations evaluator will show, however, that this phenomenon does
not have to occur. This is because no extra information is saved if there
is nothing left to do on return from a recursive call. See [SCHEME] and
[Debunking] for a more thorough discussion of this.</p>

<p>我们的递归方程语言没有特殊的迭代或循环构造物，如同Algol的for语句或者FORTRAN的DO循环。通过安排递归过程去调用它们自身或相互调用，构造出所有的循环。例如，通过对子句列表的后续”尾部(tails)”调用自身，EVCOND(见图2)对COND的子句实现了迭代。现在这样的迭代调用可能让熟悉其它语言(比如Algol, FORTRAN, PL/I, 等等)的读者在直觉层面觉得实现真实的程序不太有效率。甚至想当然认识，调用可以更快一些，它们应该看似以返回地址和其它控制信息的形式消耗了空间。然而，对递归函数求值器的检验显示，这个现象没有发生。这是因为，如果从递归调用中没有剩下什么事情去做，那么没有额外的信息要被保存。参见[SCHEME]和[Debunking]，对此有更彻底的讨论。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Art of Interpreter: Introduction]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-Introduction/"/>
    <updated>2015-08-18T10:22:59+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/08/the-art-of-interpreter-Introduction</id>
    <content type="html"><![CDATA[<p>原文地址：<a href="http://c2.com/cgi/wiki?TheArtOfTheInterpreter">http://c2.com/cgi/wiki?TheArtOfTheInterpreter</a>
<br /></p>
<hr />

<center> 
MASSACHUSETTSINSTYTUTECHTTECHNOLOCY ARTIFICIAL INTELLIGENCE LABORATORY
<br />

AI Memo No.453                May 1978
<br />

<strong>The Art of the Interpreter
<br />
or, The Modularity Complex
(Parts Zero, One, and Two)</strong>

<br />
by
<br />

Guy Lewis Steele Jr.* and Gerald Jay Sussman**

</center>

<h3 id="section">摘要</h3>
<p>Abstract:</p>

<p>We examine the effects of various language design decisions on the
programming styles available to a user of the language, with particular
emphasis on the ability to incrementally construct modular systems. At
each step we exhibit an interactive meta-circular interpreter for the
language under consideration. Each new interpreter is the result of an
incremental change to a previous interpreter.</p>

<p>我们检验了现存编程风格上的语言设计决策对语言使用者的影响，特别关注增量构造模块化系统的能力。在每一个步，针对所考虑的语言，我们展示了一个交互式的元-循环解释器。每个新的解释器都是对先前解释器增量修改的结果。</p>

<p>We explore the consequences of various variable binding disciplines
and the introduction of side effects. We find that dynamic scoping is
unsuitable for constructing procedural abstractions, but has another role
as an agent of modularity, being a structured form of side effect. More
general side effects are also found to be necessary to promote modular
style. We find that the notion of side effect and the notion of equality
(object identity) are mutually constraining; to define one is to define
the other.</p>

<p>我们探索了不同变量绑定纪律的后果，并引入了副作用(side-effect)。我们发现，动态范围不适合构造过程的抽象，但是有作为模块代理的另一作用，是副作用的一个结构化形式。也发现了更多普遍的副作用，对提升模块化风格是必要的。我们发现副作用的记号和相等的记号(对象同一性)是相互约束的。为了定义其中一个，就必须定义另一个。</p>

<p>The interpreters we exhibit are all written in a simple dialect of
LISP, and all implement LISP-like languages. A subset of these interpreters constitute a partial historical reconstruction of the actual evolution of LISP.</p>

<p>我们展示的解释器都用LISP的简单方言写出，它们都实现了类LISP的语言。这些解释器的子集包含LISP实际进化的部分历史再现。</p>

<p>Keywords: abstraction, actors, applicative order, bindings, control structures, debugging, dynamic scoping, environments, fluid variables, FUNARG
problem, functional objects, interactive programming, lambda-calculus.
lexical scoping, LISP, modularity, procedural data, recursion equations,referential transparency, SCHEME, side effects, static scoping, structured programming</p>

<p>This report describes research done at the Artificial Intelligence
Laboratory of the Massachusetts Institute of Technology. Support for the
laboratory’s artificial intelligence research is provided in part by the</p>

<p>Advanced Research Projects Agency of the Department of Defense under Office
of Naval Research contract N000l4-75-C-0643.</p>

<h3 id="section-1">内容</h3>

<ul>
  <li>Introduction
    <ul>
      <li>Modularity</li>
      <li>LISP-like Languages</li>
      <li>Structure of the Paper</li>
    </ul>
  </li>
  <li>Part Zero-— LISP and Interpreters
    <ul>
      <li>Recursion{Equations</li>
      <li>An Interpreter for LISP Recursion Equations</li>
    </ul>
  </li>
  <li>Part One —— Variable Scoping Disciplines
    <ul>
      <li>Procedures as Data</li>
      <li>Local Procedures</li>
      <li>Lexical Scoping</li>
      <li>Top Levels versus Referential Transparency</li>
    </ul>
  </li>
  <li>Part Two — State
    <ul>
      <li>Decomposition of State</li>
      <li>Side Effects and Local State</li>
      <li>Side Effects in the Interpreter</li>
      <li>Equipotency of SETQ and RPLACA</li>
      <li>Side Effects and Equality</li>
      <li>Dynamic Scoping as a State-Decomposition Discipline</li>
    </ul>
  </li>
  <li>Summary</li>
  <li>Acknowledgements</li>
  <li>Notes
    <ul>
      <li>{Can George do Better?}</li>
      <li>{Debugging}</li>
      <li>{Driver Loop with Side Effects}</li>
      <li>{EVALQUOTE}</li>
      <li>{Gaussian}</li>
      <li>{LABEL5}</li>
      <li>{LABEL5 with Side Effects}*</li>
      <li>{Primitive Operators}</li>
      <li>{PROGN wizardry}</li>
      <li>{QUOTE Mapping}</li>
      <li>{QUOTE Shafts the Compiler}</li>
      <li>{RPLACA Can Alter CAR Instead}</li>
      <li>{S—expression Postulates and Notation}</li>
      <li>{This ain’t A-lists}</li>
      <li>{Value Quibb1e}</li>
      <li>{Weber}</li>
      <li>{Y-operator}</li>
    </ul>
  </li>
  <li>References</li>
</ul>

<h3 id="section-2">介绍</h3>
<p>Introduction</p>

<h4 id="section-3">模块化</h4>
<p>Modularity</p>

<p>The entities constructed by programming are extremely complex.
Accurate construction of large programs would be impossible without
specific techniques for controlling this complexity. Most such techniques
are based on finding ways to decompose a problem into almost independently
solvable subproblems, allowing a programmer to concentrate on one
subproblem at a time, ignoring the others. When the subproblems are
solved, the programmer must be able to combine the solutions with a minimum
of unanticipated interactions. To the extent that a decomposition succeeds
in breaking a programming problem into manageable pieces, we say that the
resulting program is modular; each part of the solution is called a
module. Well—designed programming languages provide features which support
the construction of modular programs.</p>

<p>编程产生的实体极端复杂。如果没有控制这一复杂性的特定技术，要准确无误地构造大型程序是不可能的。绝大多数这样的技术是基于寻找一些方法，将问题分解为几乎独立可求解的子问题，允许程序员一次聚焦于一个子问题，而忽略其它的。当自问题被解决了，程序员必须能够以最小的不可预见的互作用，将解决方案组合在一起。如果一个分解达到了成功地将一个编程问题拆分成可管理部分的程度，我们称如此生成的程序是模块化的；解决方案的每个部分称为一个模块。设计良好的编程语言提供了支持构建模块化程序的特性。</p>

<p>One decomposition strategy is the packaging of common patterns of
the use of a language. For example, in Algol a for loop captures a common
pattern of if and goto statements. Packages of common patterns are not
necessarily merely abbreviations to save typing. While a simple
abbreviation has little abstraction power because a user must know what the
abbreviation expands into, a good package encapsulates a higher level
concept which has meaning independent of its implementation. Once a
package is constructed the programmer can use it directly, without regard
for the details it contains, precisely because it corresponds to a single
notion he uses in dealing with the programming problem.</p>

<p>一个分解策略是将使用一个语言的共同模式打包。例如，在Algol中，一个for loop 语句捕获了if和goto语句的共同模式。共同模式的包并非只是为了节约打字的缩写而需的。虽然一个简单的缩写没有什么抽象能力，因为用户必须知道缩写扩展成什么，但是一个好的包，能在更高层次的概念上封装，具有独立于实现的含义。一旦一个包构造出来，程序员能直接使用它，不需要考虑它包含的细节，正好是因为程序员在处理编程问题时将它作为单一的记号来使用。</p>

<p>A package is most useful if its behavior is independent of the
context of its use, thus reducing possible interference with other
packages. Such a package is called referentially transparent.
Intuitively, referential transparency requires that the meanings of parts
of a program be apparent and not change, so that such meanings can be
reliably depended upon. In particular, names internal to one module should
not affect or be affected by other modules — the external behavior of a
module should be independent of the choice of names for its local
identifiers.</p>

<p>如果一个包的行为独立于使用它的上下文，它是最有用的，从而减少了与其它包可能的干扰。这样的包被称为<strong>引用透明(referentially transparent)</strong>。直觉地，引用透明要求一个程序某部分的意思是明明白白的，不会改变，从而能可靠地依赖此意思。特别地，一个模块内部的名字不能影响到其它模块，或者被影响 – 一个模块的外部行为必须独立于它局部标识符的名字的选择。</p>

<p>To make a modular program, it is often necessary to think of a
computational process as having state. In such cases, if the state can be
naturally divided into independent parts, an important decomposition may be
the division of the program into pieces which separately deal with the
parts of the state.</p>

<p>为了编写模块化程序，经常有必要想起带状态的计算过程。在这些案例中，如果状态能被自然地分解为独立的部分，一种重要的分解可能是将程序划分为独立处理状态各部分的片段。</p>

<p>We will discuss various stylistic techniques for achieving
modularity. One would expect these techniques to complement each other.
We will instead discover that they can come into conflict. Pushing one to
an extreme in a language can seriously compromise others.</p>

<p>我们将讨论达到模块化的不同的风格化技术。有人会期待这些技术会相互补充。相反，我们将发现它们会产生冲突。在语言中，将一个推到极致能严重地损害其它的。</p>

<h3 id="lisp">类LISP语言</h3>
<p>LISP-like Languages</p>

<p>Of the hundreds or thousands of computer languages which have been
invented, there is one particular family of languages whose common ancestor
was the original LISP, developed by McCarthy and others in the late 1950’s.
[LISP History] These languages are generally characterized by in simple,
fully parenthesized (“Cambridge Polish”) syntax; the ability to manipulate
general, linked—list data structures; a standard representation for
programs of the language in terms of these structures; and an interactive
programming system based on an interpreter for the standard representation.
Examples of such languages are LISP 1.5 [LISP 1.5M], MacLISP [Moon],
InterLISP [Teitelman], CONNIVER [HcDermott and Sussman], QA4 [Rulifson],
PLASMA [Smith and Hewitt] [Hewitt and Smith], and SCHEME [SCHEME] [Revised
Report]. We will call this family the LISP—like languages.</p>

<p>在成百上千被发明的计算机语言中，有特殊的一个语言家族，其祖先是原始的LISP，由McCarthy和其他人在1950年代后期开发出来。这些语言的特征是：通常都与简单、封闭括号的语法(Cambridge Polish)；能够操作普遍的、链式列表数据结构；以这些结构的方式对程序的标准表示；有基于标准表示解释器的一个交互式编程系统。这样语言的例子是LISP 1.5, MacLISP, InterLISP, CONNIVER, QA4, PLASMA和Scheme。我们称这个家族为类LISP语言。</p>

<p>The various members of this family differ in some interesting and
often subtle ways. These differences have a profound impact on the styles
of programming each may encourage or support. We will explore some of
these differences by examining a series of small (“toy”) evaluators which
exhibit these differences without the clutter of “extra features” provided
in real, production versions of LISP-like language systems.</p>

<p>这个家族的各种成员的不同之处，在一些有趣和经常微妙的地方。这些差别对鼓励或支持每种编程风格有深刻的影响。我们将探索这些差别的一些，通过检视一系列小(玩具)求值器，这些求值器展示了这些差别，而没有被类LISP语言系统的真实、生产性版本所提供的“附加特性”搞乱。</p>

<p>The series of evaluators to be considered partially constitute a
reconstruction of what we believe to be the paths along which the family
evolved. These paths can be explained after the fact by viewing the historical changes to the language as being guided by the requirements of
various aspects of modularity.</p>

<p>这些被考虑的求值器系列，部分构成了一个再现，我们认为是此语言家族进化所沿着的路径。这些路径可以被这样的事实来解释，即看到对语言历史上所做的改变，是被模块化各种方面的需求推动引导着。</p>

<h4 id="section-4">文章的结构</h4>
<p>Structure of the Paper</p>

<p>Our discussion is divided into several parts, which form a linear
progression. In addition, there are numerous large digressions which
explore interesting side developments. These digressions are placed at the
end as notes, cross-referenced to and from the text.</p>

<p>我们的讨论分为几个部分，它们形成线性的推进。此外，有很多大的题外话，去探索有趣的侧面开发。这些题外话放在最后作为注解，被交叉引用到或来自正文。</p>

<p>We exhibit a large number of LISP interpreters whose code differs
from one to another in small ways (though their behavior differs greatly!).
In order to avoid writing identical pieces of code over and over, each
figure exhibits only routines which differ, and also contains cross-
references to preceding figures from which missing routines for that figure
are to be drawn.</p>

<p>我们展示很多LISP解释器，它们的代码相互间有很小的差别（但是它们的行为差别巨大）。为了避免到处写出相同的片段，每个图仅展示不同的例程，也包含一个交叉引用到前面的图，在那里图中缺失的例程被画出来。</p>

<p>Part Zero introduces the restricted dialect of the LISP language in
which most of our examples are written. It also discusses the basic
structure of an interpreter, and exhibits a meta-circular interpreter for
the language.</p>

<p>第零部分介绍了LISP语言中受限制的方言，我们大多数的例子都它写成。这部分也讨论解释器的基本结构，并展示了语言的一个元-循环解释器。</p>

<p>Part One introduces procedural data as an abstraction mechanism,
and considers its impact on variable scoping disciplines in the language.
We are forced through a series of such disciplines as unexpected
interactions are uncovered and fixed. Interpreters are exhibited for
dynamic scoping and lexical scoping.</p>

<p>第一部分介绍作为一个抽象机制的过程数据，并考虑它在语言的变量范围规则中的影响。随着未曾预期的交互性被发现和修正，我们被迫使穿越一些列这样的规则。为了动态范围和词法范围而展示了解释器。</p>

<p>Part Two considers the problems associated with the decomposition of state. Side effects are introduced as a mechanism for effecting such decompositions. We find that the notion of side effect is inextricably wound up with the notion of identity. Dynamic scoping is retrospectively viewed as a restricted kind of side effect.</p>

<p>第三部分考虑与分解状态相伴的问题。副作用被引入，作为影响如此分解的一个机制。我们发现，副作用的记号无法摆脱地与相等性的记号缠绕在一起。回想起来，动态范围被看作一种受限的副作用类别。</p>

<p>With this we summarize and conclude with many tantalizing questions yet unanswered.</p>

<p>带着这些，我们总结并给出结论，很多扰人的问题尚未有答案。</p>

<p>In Part Three (in a separate paper) we will find that the
introduction of side effects forces the issue of the order of evaluation of
expressions. We will contrast call-by-name and its variants with call—by-
value, and discuss how these control disciplines arise as a consequence of
different models of packaging. In particular, call-by-name arises
naturally from the syntactic nature of the Algol 60 copy rule. As before,
many little interpreters for these disciplines will be exhibited. </p>

<p>在第三部分(一个单独的论文)，我们将发现，副作用的引入将催生表达式求值的次序问题。我们将通过名称调用(call-by-name)及它的变体，与通过值调用，进行比较。然后讨论这些控制记录如何作为不同包建模的结果而产生。特别地，按名称调用自然地从Algol 60拷贝机制的语法属性中自然产生。正如以前，这些规则的很多小解释器也被展示出来。</p>

<p>In Part Four we will be led to generalize the notion of a syntactic package. We will discuss meta-procedures, which deal with the representations of procedures. The distinction between a procedure and its representation will be more carefully considered. Macro processors, algebraic simplifiers, and compilers will be considered as meta-procedures. Various interpreters, compilers, and simplifiers will be exhibited.</p>

<p>在第四部分，我们将导向推广语法包的记号。我们将讨论元过程，这处理过程的表示。过程及其表示的区分将被更加仔细地考虑。宏处理器，代数化简器和编译器，将被看做元过程。不同的解释器、编译器和化简器将被展示。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell Resources]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/08/haskell-resources/"/>
    <updated>2015-08-07T15:31:00+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/08/haskell-resources</id>
    <content type="html"><![CDATA[<h2 id="books">Books</h2>

<ul>
  <li><a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a></li>
  <li><a href="http://book.realworldhaskell.org/read/">Real World Haskell</a></li>
  <li></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Lisp中实现算术]]></title>
    <link href="http://hack.the-lifematrix.net/blog/2015/07/implementing-arithmetic-in-lisp/"/>
    <updated>2015-07-27T11:51:18+08:00</updated>
    <id>http://hack.the-lifematrix.net/blog/2015/07/implementing-arithmetic-in-lisp</id>
    <content type="html"><![CDATA[<p>在上一篇文章中，Paul Graham介绍了Lisp的基础。通过7个原语操作，就可定义一些基本函数，进而实现对表达式求值函数eval.。本文将探索，基于这些Lisp的基本语言素材，如何实现算术。</p>

<p>整个背后的想法是，只要我们定义了语言的原语操作，就可推演出整个语言的体系。数字，本质上也是符号。而算术，则是对符号的操作。</p>

<h3 id="section">预备函数</h3>

<p>我们需要增加几个函数，作为预备：</p>

<p>(neq. x y) 判断x和y是否不相等。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">&gt; (defun neq. (x y)
</span><span class="line">    (not. (eq x y))) </span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(member. x y)判断x是否是列表y的元素。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">member.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="ss">&#39;t</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">member.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="no">T</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(reverse. x) 反转整个列表x</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">reverse.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">concat.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">C</span> <span class="nv">B</span> <span class="nv">A</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(findsub. x y) 在y中找元素x，如果找到，返回包含x在内的尾部。找不到，返回空。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">findsub.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">())</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="ss">&#39;t</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">x</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;b</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="nv">B</span> <span class="nv">C</span> <span class="nv">D</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="ss">&#39;f</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span><span class="p">))</span>
</span><span class="line"><span class="no">NIL</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>(longer. x y) 比较两个列表x和y，哪个更长，即元素更多。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">longer.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">and.</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="p">(</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">()))</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">())</span> <span class="ss">&#39;LT</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">longer.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">)))))</span>
</span><span class="line">
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-1">实现整数加法</h3>

<p>我们先实现整数的加法，而且先不考虑负数的情况。我们用列表表示数字，例如1234，表示为(1 2 3 4)。
高位在左，低位在右，以便符合人的阅读习惯。</p>

<p>我们先定义函数(basecomp. x y)，比较单个数字符号的大小。思路是比较它们在符号列表(0 1 2 3 4 5 6 7 8 9)中的位置，哪个靠前，哪个小。具体的算法，是处理相等的情况，直接返回相等。然后取得含有y的符号列表的尾部，如果包含x，则x要靠后，否则靠前。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">basecomp.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">   <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;EQ</span><span class="p">)</span>
</span><span class="line">         <span class="p">((</span><span class="nv">member.</span> <span class="nv">x</span> <span class="p">(</span><span class="nv">findsub.</span> <span class="nv">y</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">)))</span> <span class="ss">&#39;GT</span><span class="p">)</span>
</span><span class="line">         <span class="p">(</span><span class="no">t</span> <span class="ss">&#39;LT</span><span class="p">)))</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;3</span> <span class="ss">&#39;4</span><span class="p">)</span>
</span><span class="line"><span class="nv">LT</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;8</span><span class="p">)</span>
</span><span class="line"><span class="nv">EQ</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="ss">&#39;9</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="nv">GT</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后，我们可以定义单个数字的加法，就如同小学时学的加法表一样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">baseadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="p">(</span><span class="nv">basecomp.</span> <span class="nv">x</span> <span class="nv">y</span><span class="p">)</span> <span class="ss">&#39;GT</span><span class="p">)</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="nv">y</span> <span class="nv">x</span><span class="p">))</span>
</span><span class="line">      <span class="p">((</span><span class="nb">eq</span> <span class="nv">x</span> <span class="ss">&#39;0</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">      <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">y</span> <span class="p">(</span><span class="nv">assoc.</span> <span class="nv">x</span> <span class="o">&#39;</span><span class="p">((</span><span class="mi">1</span> <span class="p">((</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="p">(</span><span class="mi">2</span> <span class="mi">3</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">2</span> <span class="p">((</span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="mi">3</span> <span class="mi">5</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">3</span> <span class="p">((</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span> <span class="p">(</span><span class="mi">4</span> <span class="mi">7</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">4</span> <span class="p">((</span><span class="mi">4</span> <span class="mi">8</span><span class="p">)</span> <span class="p">(</span><span class="mi">5</span> <span class="mi">9</span><span class="p">)</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">5</span> <span class="p">((</span><span class="mi">5</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">0</span><span class="p">))</span> <span class="p">(</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">1</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">6</span> <span class="p">((</span><span class="mi">6</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">))</span> <span class="p">(</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">3</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">7</span> <span class="p">((</span><span class="mi">7</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">))</span> <span class="p">(</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">8</span> <span class="p">((</span><span class="mi">8</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">6</span><span class="p">))</span> <span class="p">(</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">7</span><span class="p">))))</span>
</span><span class="line">                            <span class="p">(</span><span class="mi">9</span> <span class="p">((</span><span class="mi">9</span> <span class="p">(</span><span class="mi">1</span> <span class="mi">8</span><span class="p">))))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>先按照x, 再按y，查找加法表，返回结果。如果有进位，就返回列表，比如(1 5)。由于加法表，要求y&gt;=x。所以用到比较函数basecomp.，如果x大于y，则将次序调换在调用baseadd.。如果不要求x和y的次序，亦可，但加法表要多写一倍，这是冗余而无趣的工作。</p>

<p>试试我们的一位数加法：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;2</span> <span class="ss">&#39;3</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;8</span> <span class="ss">&#39;7</span><span class="p">)</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">5</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="ss">&#39;5</span> <span class="ss">&#39;0</span><span class="p">)</span>
</span><span class="line"><span class="mi">5</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>万事俱备了，可以写最终的加法函数。但别急，还有点小的问题。我们知道多位数的加法，是先算低位再算高位。但是，我们的数字用列表表示时，是高位在左，低位在右。用lisp的car, cdr要先取出最右边(尾部)的元素很不方便。一个解决办法是，先将列表反转过来计算，计算完毕后，再反转回来。</p>

<p>这个就是整数加法的函数：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intadd.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nv">reverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nv">reverse.</span> <span class="nv">y</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>反转后列表的加法函数，intaddreverse. 如下</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="p">(</span><span class="nb">defun</span> <span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">x</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">y</span><span class="p">)</span>
</span><span class="line">          <span class="p">((</span><span class="nv">null.</span> <span class="nv">y</span><span class="p">)</span> <span class="nv">x</span><span class="p">)</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nb">atom</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                    <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">))</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))</span>
</span><span class="line">                   <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">cadr</span> <span class="p">(</span><span class="nv">baseadd.</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">y</span><span class="p">)))</span>
</span><span class="line">                            <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="p">(</span><span class="nv">intaddreverse.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">y</span><span class="p">))))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>看看效果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">3</span> <span class="mi">6</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">2</span> <span class="mi">4</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">)</span>
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">8</span> <span class="mi">9</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">3</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="section-2">应用</h3>

<p>利用上面的加法函数，我们可以写一个计算列表长度的函数</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nb">defun</span> <span class="nv">length.</span> <span class="p">(</span><span class="nv">x</span><span class="p">)</span>
</span><span class="line">    <span class="p">(</span><span class="nb">cond</span> <span class="p">((</span><span class="nv">null.</span> <span class="nv">x</span><span class="p">)</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
</span><span class="line">          <span class="p">(</span><span class="no">t</span> <span class="p">(</span><span class="nv">intadd.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nv">length.</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))))))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>测试一下：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="lisp"><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</span><span class="line">
</span><span class="line"><span class="nb">&gt;</span> <span class="p">(</span><span class="nv">length.</span> <span class="o">&#39;</span><span class="p">(</span><span class="nv">a</span> <span class="nv">b</span> <span class="nv">c</span> <span class="nv">d</span> <span class="nv">e</span> <span class="nv">f</span> <span class="nv">g</span> <span class="nv">h</span> <span class="nv">i</span> <span class="nv">j</span> <span class="nv">k</span> <span class="nv">l</span> <span class="nv">m</span> <span class="nv">n</span><span class="p">))</span>
</span><span class="line"><span class="p">(</span><span class="mi">1</span> <span class="mi">4</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
<p>(1 4)就是14。</p>

<h3 id="section-3">回顾</h3>

<p>上面通过简单的符号计算规则，就实现了整数的加法运算，让我们更进一步理解，一切计算皆是符号的本质。当然，基本规则的定义稍有冗余。上面定义了自然数的大小和加法表。更简洁的定义，只需包含三个部分：</p>

<ul>
  <li>自然数 $a_0$ = 1</li>
  <li>$a_n$ = $a_{n-1}$ + 1</li>
  <li>十进制的进位和表示法</li>
</ul>

<p>循着类似的思路，减法运算也可定义出来。</p>

]]></content>
  </entry>
  
</feed>
